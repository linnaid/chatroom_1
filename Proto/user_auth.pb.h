// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user_auth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_5fauth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_5fauth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_5fauth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_5fauth_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_5fauth_2eproto;
namespace auth {
class Auth;
struct AuthDefaultTypeInternal;
extern AuthDefaultTypeInternal _Auth_default_instance_;
class LogInRequest;
struct LogInRequestDefaultTypeInternal;
extern LogInRequestDefaultTypeInternal _LogInRequest_default_instance_;
class LogInResponse;
struct LogInResponseDefaultTypeInternal;
extern LogInResponseDefaultTypeInternal _LogInResponse_default_instance_;
class Login_Ver;
struct Login_VerDefaultTypeInternal;
extern Login_VerDefaultTypeInternal _Login_Ver_default_instance_;
class LogoutResquest;
struct LogoutResquestDefaultTypeInternal;
extern LogoutResquestDefaultTypeInternal _LogoutResquest_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class Register_Ver;
struct Register_VerDefaultTypeInternal;
extern Register_VerDefaultTypeInternal _Register_Ver_default_instance_;
}  // namespace auth
PROTOBUF_NAMESPACE_OPEN
template<> ::auth::Auth* Arena::CreateMaybeMessage<::auth::Auth>(Arena*);
template<> ::auth::LogInRequest* Arena::CreateMaybeMessage<::auth::LogInRequest>(Arena*);
template<> ::auth::LogInResponse* Arena::CreateMaybeMessage<::auth::LogInResponse>(Arena*);
template<> ::auth::Login_Ver* Arena::CreateMaybeMessage<::auth::Login_Ver>(Arena*);
template<> ::auth::LogoutResquest* Arena::CreateMaybeMessage<::auth::LogoutResquest>(Arena*);
template<> ::auth::RegisterRequest* Arena::CreateMaybeMessage<::auth::RegisterRequest>(Arena*);
template<> ::auth::RegisterResponse* Arena::CreateMaybeMessage<::auth::RegisterResponse>(Arena*);
template<> ::auth::Register_Ver* Arena::CreateMaybeMessage<::auth::Register_Ver>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace auth {

enum actions : int {
  UNKNOWN = 0,
  LOGIN = 1,
  LOGOUT = 2,
  REGISTER = 3,
  RVERIFY = 4,
  LVERIFY = 5,
  actions_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  actions_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool actions_IsValid(int value);
constexpr actions actions_MIN = UNKNOWN;
constexpr actions actions_MAX = LVERIFY;
constexpr int actions_ARRAYSIZE = actions_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* actions_descriptor();
template<typename T>
inline const std::string& actions_Name(T enum_t_value) {
  static_assert(::std::is_same<T, actions>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function actions_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    actions_descriptor(), enum_t_value);
}
inline bool actions_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, actions* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<actions>(
    actions_descriptor(), name, value);
}
enum Select : int {
  PASSWORD = 0,
  EMAIL = 1,
  Select_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Select_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Select_IsValid(int value);
constexpr Select Select_MIN = PASSWORD;
constexpr Select Select_MAX = EMAIL;
constexpr int Select_ARRAYSIZE = Select_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Select_descriptor();
template<typename T>
inline const std::string& Select_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Select>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Select_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Select_descriptor(), enum_t_value);
}
inline bool Select_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Select* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Select>(
    Select_descriptor(), name, value);
}
// ===================================================================

class Auth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Auth) */ {
 public:
  inline Auth() : Auth(nullptr) {}
  ~Auth() override;
  explicit PROTOBUF_CONSTEXPR Auth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Auth(const Auth& from);
  Auth(Auth&& from) noexcept
    : Auth() {
    *this = ::std::move(from);
  }

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Auth& operator=(Auth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Auth& default_instance() {
    return *internal_default_instance();
  }
  static inline const Auth* internal_default_instance() {
    return reinterpret_cast<const Auth*>(
               &_Auth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Auth& a, Auth& b) {
    a.Swap(&b);
  }
  inline void Swap(Auth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Auth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Auth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Auth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Auth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Auth& from) {
    Auth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Auth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Auth";
  }
  protected:
  explicit Auth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 8,
    kReqFieldNumber = 2,
    kResFieldNumber = 3,
    kLoqFieldNumber = 4,
    kLosFieldNumber = 5,
    kRVerFieldNumber = 6,
    kLVerFieldNumber = 7,
    kActionFieldNumber = 1,
  };
  // string msg = 8;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .auth.RegisterRequest req = 2;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::auth::RegisterRequest& req() const;
  PROTOBUF_NODISCARD ::auth::RegisterRequest* release_req();
  ::auth::RegisterRequest* mutable_req();
  void set_allocated_req(::auth::RegisterRequest* req);
  private:
  const ::auth::RegisterRequest& _internal_req() const;
  ::auth::RegisterRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::auth::RegisterRequest* req);
  ::auth::RegisterRequest* unsafe_arena_release_req();

  // .auth.RegisterResponse res = 3;
  bool has_res() const;
  private:
  bool _internal_has_res() const;
  public:
  void clear_res();
  const ::auth::RegisterResponse& res() const;
  PROTOBUF_NODISCARD ::auth::RegisterResponse* release_res();
  ::auth::RegisterResponse* mutable_res();
  void set_allocated_res(::auth::RegisterResponse* res);
  private:
  const ::auth::RegisterResponse& _internal_res() const;
  ::auth::RegisterResponse* _internal_mutable_res();
  public:
  void unsafe_arena_set_allocated_res(
      ::auth::RegisterResponse* res);
  ::auth::RegisterResponse* unsafe_arena_release_res();

  // .auth.LogInRequest loq = 4;
  bool has_loq() const;
  private:
  bool _internal_has_loq() const;
  public:
  void clear_loq();
  const ::auth::LogInRequest& loq() const;
  PROTOBUF_NODISCARD ::auth::LogInRequest* release_loq();
  ::auth::LogInRequest* mutable_loq();
  void set_allocated_loq(::auth::LogInRequest* loq);
  private:
  const ::auth::LogInRequest& _internal_loq() const;
  ::auth::LogInRequest* _internal_mutable_loq();
  public:
  void unsafe_arena_set_allocated_loq(
      ::auth::LogInRequest* loq);
  ::auth::LogInRequest* unsafe_arena_release_loq();

  // .auth.LogInResponse los = 5;
  bool has_los() const;
  private:
  bool _internal_has_los() const;
  public:
  void clear_los();
  const ::auth::LogInResponse& los() const;
  PROTOBUF_NODISCARD ::auth::LogInResponse* release_los();
  ::auth::LogInResponse* mutable_los();
  void set_allocated_los(::auth::LogInResponse* los);
  private:
  const ::auth::LogInResponse& _internal_los() const;
  ::auth::LogInResponse* _internal_mutable_los();
  public:
  void unsafe_arena_set_allocated_los(
      ::auth::LogInResponse* los);
  ::auth::LogInResponse* unsafe_arena_release_los();

  // .auth.Register_Ver R_ver = 6;
  bool has_r_ver() const;
  private:
  bool _internal_has_r_ver() const;
  public:
  void clear_r_ver();
  const ::auth::Register_Ver& r_ver() const;
  PROTOBUF_NODISCARD ::auth::Register_Ver* release_r_ver();
  ::auth::Register_Ver* mutable_r_ver();
  void set_allocated_r_ver(::auth::Register_Ver* r_ver);
  private:
  const ::auth::Register_Ver& _internal_r_ver() const;
  ::auth::Register_Ver* _internal_mutable_r_ver();
  public:
  void unsafe_arena_set_allocated_r_ver(
      ::auth::Register_Ver* r_ver);
  ::auth::Register_Ver* unsafe_arena_release_r_ver();

  // .auth.Login_Ver L_ver = 7;
  bool has_l_ver() const;
  private:
  bool _internal_has_l_ver() const;
  public:
  void clear_l_ver();
  const ::auth::Login_Ver& l_ver() const;
  PROTOBUF_NODISCARD ::auth::Login_Ver* release_l_ver();
  ::auth::Login_Ver* mutable_l_ver();
  void set_allocated_l_ver(::auth::Login_Ver* l_ver);
  private:
  const ::auth::Login_Ver& _internal_l_ver() const;
  ::auth::Login_Ver* _internal_mutable_l_ver();
  public:
  void unsafe_arena_set_allocated_l_ver(
      ::auth::Login_Ver* l_ver);
  ::auth::Login_Ver* unsafe_arena_release_l_ver();

  // .auth.actions action = 1;
  void clear_action();
  ::auth::actions action() const;
  void set_action(::auth::actions value);
  private:
  ::auth::actions _internal_action() const;
  void _internal_set_action(::auth::actions value);
  public:

  // @@protoc_insertion_point(class_scope:auth.Auth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::auth::RegisterRequest* req_;
    ::auth::RegisterResponse* res_;
    ::auth::LogInRequest* loq_;
    ::auth::LogInResponse* los_;
    ::auth::Register_Ver* r_ver_;
    ::auth::Login_Ver* l_ver_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// -------------------------------------------------------------------

class Register_Ver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Register_Ver) */ {
 public:
  inline Register_Ver() : Register_Ver(nullptr) {}
  ~Register_Ver() override;
  explicit PROTOBUF_CONSTEXPR Register_Ver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Register_Ver(const Register_Ver& from);
  Register_Ver(Register_Ver&& from) noexcept
    : Register_Ver() {
    *this = ::std::move(from);
  }

  inline Register_Ver& operator=(const Register_Ver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Register_Ver& operator=(Register_Ver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Register_Ver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Register_Ver* internal_default_instance() {
    return reinterpret_cast<const Register_Ver*>(
               &_Register_Ver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Register_Ver& a, Register_Ver& b) {
    a.Swap(&b);
  }
  inline void Swap(Register_Ver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Register_Ver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Register_Ver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Register_Ver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Register_Ver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Register_Ver& from) {
    Register_Ver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Register_Ver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Register_Ver";
  }
  protected:
  explicit Register_Ver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailMsgFieldNumber = 1,
    kTimeFieldNumber = 3,
    kUsernameFieldNumber = 4,
    kDecideFieldNumber = 2,
  };
  // string email_msg = 1;
  void clear_email_msg();
  const std::string& email_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_msg();
  PROTOBUF_NODISCARD std::string* release_email_msg();
  void set_allocated_email_msg(std::string* email_msg);
  private:
  const std::string& _internal_email_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_msg(const std::string& value);
  std::string* _internal_mutable_email_msg();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bool decide = 2;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:auth.Register_Ver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// -------------------------------------------------------------------

class Login_Ver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Login_Ver) */ {
 public:
  inline Login_Ver() : Login_Ver(nullptr) {}
  ~Login_Ver() override;
  explicit PROTOBUF_CONSTEXPR Login_Ver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login_Ver(const Login_Ver& from);
  Login_Ver(Login_Ver&& from) noexcept
    : Login_Ver() {
    *this = ::std::move(from);
  }

  inline Login_Ver& operator=(const Login_Ver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login_Ver& operator=(Login_Ver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login_Ver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login_Ver* internal_default_instance() {
    return reinterpret_cast<const Login_Ver*>(
               &_Login_Ver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Login_Ver& a, Login_Ver& b) {
    a.Swap(&b);
  }
  inline void Swap(Login_Ver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login_Ver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login_Ver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Login_Ver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login_Ver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Login_Ver& from) {
    Login_Ver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login_Ver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Login_Ver";
  }
  protected:
  explicit Login_Ver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailMsgFieldNumber = 2,
    kTimeFieldNumber = 3,
    kUsernameFieldNumber = 4,
    kDecideFieldNumber = 1,
  };
  // string email_msg = 2;
  void clear_email_msg();
  const std::string& email_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_msg();
  PROTOBUF_NODISCARD std::string* release_email_msg();
  void set_allocated_email_msg(std::string* email_msg);
  private:
  const std::string& _internal_email_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_msg(const std::string& value);
  std::string* _internal_mutable_email_msg();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bool decide = 1;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:auth.Login_Ver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kEmailFieldNumber = 3,
    kPhoneFieldNumber = 4,
    kVerificationCodeFieldNumber = 5,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string email = 3;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string phone = 4;
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // string verification_code = 5;
  void clear_verification_code();
  const std::string& verification_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verification_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verification_code();
  PROTOBUF_NODISCARD std::string* release_verification_code();
  void set_allocated_verification_code(std::string* verification_code);
  private:
  const std::string& _internal_verification_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_code(const std::string& value);
  std::string* _internal_mutable_verification_code();
  public:

  // @@protoc_insertion_point(class_scope:auth.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kTimeFieldNumber = 4,
    kDecideFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string time = 4;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // bool decide = 1;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:auth.RegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// -------------------------------------------------------------------

class LogInRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.LogInRequest) */ {
 public:
  inline LogInRequest() : LogInRequest(nullptr) {}
  ~LogInRequest() override;
  explicit PROTOBUF_CONSTEXPR LogInRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogInRequest(const LogInRequest& from);
  LogInRequest(LogInRequest&& from) noexcept
    : LogInRequest() {
    *this = ::std::move(from);
  }

  inline LogInRequest& operator=(const LogInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogInRequest& operator=(LogInRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogInRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogInRequest* internal_default_instance() {
    return reinterpret_cast<const LogInRequest*>(
               &_LogInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogInRequest& a, LogInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogInRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogInRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogInRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogInRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogInRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogInRequest& from) {
    LogInRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogInRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.LogInRequest";
  }
  protected:
  explicit LogInRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kEmailFieldNumber = 4,
    kVerificationCodeFieldNumber = 5,
    kSelectFieldNumber = 1,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string email = 4;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string Verification_code = 5;
  void clear_verification_code();
  const std::string& verification_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verification_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verification_code();
  PROTOBUF_NODISCARD std::string* release_verification_code();
  void set_allocated_verification_code(std::string* verification_code);
  private:
  const std::string& _internal_verification_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_code(const std::string& value);
  std::string* _internal_mutable_verification_code();
  public:

  // .auth.Select select = 1;
  void clear_select();
  ::auth::Select select() const;
  void set_select(::auth::Select value);
  private:
  ::auth::Select _internal_select() const;
  void _internal_set_select(::auth::Select value);
  public:

  // @@protoc_insertion_point(class_scope:auth.LogInRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_code_;
    int select_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// -------------------------------------------------------------------

class LogInResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.LogInResponse) */ {
 public:
  inline LogInResponse() : LogInResponse(nullptr) {}
  ~LogInResponse() override;
  explicit PROTOBUF_CONSTEXPR LogInResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogInResponse(const LogInResponse& from);
  LogInResponse(LogInResponse&& from) noexcept
    : LogInResponse() {
    *this = ::std::move(from);
  }

  inline LogInResponse& operator=(const LogInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogInResponse& operator=(LogInResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogInResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogInResponse* internal_default_instance() {
    return reinterpret_cast<const LogInResponse*>(
               &_LogInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LogInResponse& a, LogInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogInResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogInResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogInResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogInResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogInResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogInResponse& from) {
    LogInResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogInResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.LogInResponse";
  }
  protected:
  explicit LogInResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecideFieldNumber = 1,
  };
  // int32 decide = 1;
  void clear_decide();
  int32_t decide() const;
  void set_decide(int32_t value);
  private:
  int32_t _internal_decide() const;
  void _internal_set_decide(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.LogInResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// -------------------------------------------------------------------

class LogoutResquest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.LogoutResquest) */ {
 public:
  inline LogoutResquest() : LogoutResquest(nullptr) {}
  ~LogoutResquest() override;
  explicit PROTOBUF_CONSTEXPR LogoutResquest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutResquest(const LogoutResquest& from);
  LogoutResquest(LogoutResquest&& from) noexcept
    : LogoutResquest() {
    *this = ::std::move(from);
  }

  inline LogoutResquest& operator=(const LogoutResquest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutResquest& operator=(LogoutResquest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutResquest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutResquest* internal_default_instance() {
    return reinterpret_cast<const LogoutResquest*>(
               &_LogoutResquest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogoutResquest& a, LogoutResquest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutResquest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutResquest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutResquest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutResquest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutResquest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutResquest& from) {
    LogoutResquest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutResquest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.LogoutResquest";
  }
  protected:
  explicit LogoutResquest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:auth.LogoutResquest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fauth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Auth

// .auth.actions action = 1;
inline void Auth::clear_action() {
  _impl_.action_ = 0;
}
inline ::auth::actions Auth::_internal_action() const {
  return static_cast< ::auth::actions >(_impl_.action_);
}
inline ::auth::actions Auth::action() const {
  // @@protoc_insertion_point(field_get:auth.Auth.action)
  return _internal_action();
}
inline void Auth::_internal_set_action(::auth::actions value) {
  
  _impl_.action_ = value;
}
inline void Auth::set_action(::auth::actions value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:auth.Auth.action)
}

// .auth.RegisterRequest req = 2;
inline bool Auth::_internal_has_req() const {
  return this != internal_default_instance() && _impl_.req_ != nullptr;
}
inline bool Auth::has_req() const {
  return _internal_has_req();
}
inline void Auth::clear_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.req_ != nullptr) {
    delete _impl_.req_;
  }
  _impl_.req_ = nullptr;
}
inline const ::auth::RegisterRequest& Auth::_internal_req() const {
  const ::auth::RegisterRequest* p = _impl_.req_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::RegisterRequest&>(
      ::auth::_RegisterRequest_default_instance_);
}
inline const ::auth::RegisterRequest& Auth::req() const {
  // @@protoc_insertion_point(field_get:auth.Auth.req)
  return _internal_req();
}
inline void Auth::unsafe_arena_set_allocated_req(
    ::auth::RegisterRequest* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.req_);
  }
  _impl_.req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Auth.req)
}
inline ::auth::RegisterRequest* Auth::release_req() {
  
  ::auth::RegisterRequest* temp = _impl_.req_;
  _impl_.req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::RegisterRequest* Auth::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:auth.Auth.req)
  
  ::auth::RegisterRequest* temp = _impl_.req_;
  _impl_.req_ = nullptr;
  return temp;
}
inline ::auth::RegisterRequest* Auth::_internal_mutable_req() {
  
  if (_impl_.req_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::RegisterRequest>(GetArenaForAllocation());
    _impl_.req_ = p;
  }
  return _impl_.req_;
}
inline ::auth::RegisterRequest* Auth::mutable_req() {
  ::auth::RegisterRequest* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:auth.Auth.req)
  return _msg;
}
inline void Auth::set_allocated_req(::auth::RegisterRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.req_ = req;
  // @@protoc_insertion_point(field_set_allocated:auth.Auth.req)
}

// .auth.RegisterResponse res = 3;
inline bool Auth::_internal_has_res() const {
  return this != internal_default_instance() && _impl_.res_ != nullptr;
}
inline bool Auth::has_res() const {
  return _internal_has_res();
}
inline void Auth::clear_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.res_ != nullptr) {
    delete _impl_.res_;
  }
  _impl_.res_ = nullptr;
}
inline const ::auth::RegisterResponse& Auth::_internal_res() const {
  const ::auth::RegisterResponse* p = _impl_.res_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::RegisterResponse&>(
      ::auth::_RegisterResponse_default_instance_);
}
inline const ::auth::RegisterResponse& Auth::res() const {
  // @@protoc_insertion_point(field_get:auth.Auth.res)
  return _internal_res();
}
inline void Auth::unsafe_arena_set_allocated_res(
    ::auth::RegisterResponse* res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.res_);
  }
  _impl_.res_ = res;
  if (res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Auth.res)
}
inline ::auth::RegisterResponse* Auth::release_res() {
  
  ::auth::RegisterResponse* temp = _impl_.res_;
  _impl_.res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::RegisterResponse* Auth::unsafe_arena_release_res() {
  // @@protoc_insertion_point(field_release:auth.Auth.res)
  
  ::auth::RegisterResponse* temp = _impl_.res_;
  _impl_.res_ = nullptr;
  return temp;
}
inline ::auth::RegisterResponse* Auth::_internal_mutable_res() {
  
  if (_impl_.res_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::RegisterResponse>(GetArenaForAllocation());
    _impl_.res_ = p;
  }
  return _impl_.res_;
}
inline ::auth::RegisterResponse* Auth::mutable_res() {
  ::auth::RegisterResponse* _msg = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:auth.Auth.res)
  return _msg;
}
inline void Auth::set_allocated_res(::auth::RegisterResponse* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(res);
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.res_ = res;
  // @@protoc_insertion_point(field_set_allocated:auth.Auth.res)
}

// .auth.LogInRequest loq = 4;
inline bool Auth::_internal_has_loq() const {
  return this != internal_default_instance() && _impl_.loq_ != nullptr;
}
inline bool Auth::has_loq() const {
  return _internal_has_loq();
}
inline void Auth::clear_loq() {
  if (GetArenaForAllocation() == nullptr && _impl_.loq_ != nullptr) {
    delete _impl_.loq_;
  }
  _impl_.loq_ = nullptr;
}
inline const ::auth::LogInRequest& Auth::_internal_loq() const {
  const ::auth::LogInRequest* p = _impl_.loq_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::LogInRequest&>(
      ::auth::_LogInRequest_default_instance_);
}
inline const ::auth::LogInRequest& Auth::loq() const {
  // @@protoc_insertion_point(field_get:auth.Auth.loq)
  return _internal_loq();
}
inline void Auth::unsafe_arena_set_allocated_loq(
    ::auth::LogInRequest* loq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loq_);
  }
  _impl_.loq_ = loq;
  if (loq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Auth.loq)
}
inline ::auth::LogInRequest* Auth::release_loq() {
  
  ::auth::LogInRequest* temp = _impl_.loq_;
  _impl_.loq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::LogInRequest* Auth::unsafe_arena_release_loq() {
  // @@protoc_insertion_point(field_release:auth.Auth.loq)
  
  ::auth::LogInRequest* temp = _impl_.loq_;
  _impl_.loq_ = nullptr;
  return temp;
}
inline ::auth::LogInRequest* Auth::_internal_mutable_loq() {
  
  if (_impl_.loq_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::LogInRequest>(GetArenaForAllocation());
    _impl_.loq_ = p;
  }
  return _impl_.loq_;
}
inline ::auth::LogInRequest* Auth::mutable_loq() {
  ::auth::LogInRequest* _msg = _internal_mutable_loq();
  // @@protoc_insertion_point(field_mutable:auth.Auth.loq)
  return _msg;
}
inline void Auth::set_allocated_loq(::auth::LogInRequest* loq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loq_;
  }
  if (loq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loq);
    if (message_arena != submessage_arena) {
      loq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loq, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.loq_ = loq;
  // @@protoc_insertion_point(field_set_allocated:auth.Auth.loq)
}

// .auth.LogInResponse los = 5;
inline bool Auth::_internal_has_los() const {
  return this != internal_default_instance() && _impl_.los_ != nullptr;
}
inline bool Auth::has_los() const {
  return _internal_has_los();
}
inline void Auth::clear_los() {
  if (GetArenaForAllocation() == nullptr && _impl_.los_ != nullptr) {
    delete _impl_.los_;
  }
  _impl_.los_ = nullptr;
}
inline const ::auth::LogInResponse& Auth::_internal_los() const {
  const ::auth::LogInResponse* p = _impl_.los_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::LogInResponse&>(
      ::auth::_LogInResponse_default_instance_);
}
inline const ::auth::LogInResponse& Auth::los() const {
  // @@protoc_insertion_point(field_get:auth.Auth.los)
  return _internal_los();
}
inline void Auth::unsafe_arena_set_allocated_los(
    ::auth::LogInResponse* los) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.los_);
  }
  _impl_.los_ = los;
  if (los) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Auth.los)
}
inline ::auth::LogInResponse* Auth::release_los() {
  
  ::auth::LogInResponse* temp = _impl_.los_;
  _impl_.los_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::LogInResponse* Auth::unsafe_arena_release_los() {
  // @@protoc_insertion_point(field_release:auth.Auth.los)
  
  ::auth::LogInResponse* temp = _impl_.los_;
  _impl_.los_ = nullptr;
  return temp;
}
inline ::auth::LogInResponse* Auth::_internal_mutable_los() {
  
  if (_impl_.los_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::LogInResponse>(GetArenaForAllocation());
    _impl_.los_ = p;
  }
  return _impl_.los_;
}
inline ::auth::LogInResponse* Auth::mutable_los() {
  ::auth::LogInResponse* _msg = _internal_mutable_los();
  // @@protoc_insertion_point(field_mutable:auth.Auth.los)
  return _msg;
}
inline void Auth::set_allocated_los(::auth::LogInResponse* los) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.los_;
  }
  if (los) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(los);
    if (message_arena != submessage_arena) {
      los = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, los, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.los_ = los;
  // @@protoc_insertion_point(field_set_allocated:auth.Auth.los)
}

// .auth.Register_Ver R_ver = 6;
inline bool Auth::_internal_has_r_ver() const {
  return this != internal_default_instance() && _impl_.r_ver_ != nullptr;
}
inline bool Auth::has_r_ver() const {
  return _internal_has_r_ver();
}
inline void Auth::clear_r_ver() {
  if (GetArenaForAllocation() == nullptr && _impl_.r_ver_ != nullptr) {
    delete _impl_.r_ver_;
  }
  _impl_.r_ver_ = nullptr;
}
inline const ::auth::Register_Ver& Auth::_internal_r_ver() const {
  const ::auth::Register_Ver* p = _impl_.r_ver_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::Register_Ver&>(
      ::auth::_Register_Ver_default_instance_);
}
inline const ::auth::Register_Ver& Auth::r_ver() const {
  // @@protoc_insertion_point(field_get:auth.Auth.R_ver)
  return _internal_r_ver();
}
inline void Auth::unsafe_arena_set_allocated_r_ver(
    ::auth::Register_Ver* r_ver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.r_ver_);
  }
  _impl_.r_ver_ = r_ver;
  if (r_ver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Auth.R_ver)
}
inline ::auth::Register_Ver* Auth::release_r_ver() {
  
  ::auth::Register_Ver* temp = _impl_.r_ver_;
  _impl_.r_ver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::Register_Ver* Auth::unsafe_arena_release_r_ver() {
  // @@protoc_insertion_point(field_release:auth.Auth.R_ver)
  
  ::auth::Register_Ver* temp = _impl_.r_ver_;
  _impl_.r_ver_ = nullptr;
  return temp;
}
inline ::auth::Register_Ver* Auth::_internal_mutable_r_ver() {
  
  if (_impl_.r_ver_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::Register_Ver>(GetArenaForAllocation());
    _impl_.r_ver_ = p;
  }
  return _impl_.r_ver_;
}
inline ::auth::Register_Ver* Auth::mutable_r_ver() {
  ::auth::Register_Ver* _msg = _internal_mutable_r_ver();
  // @@protoc_insertion_point(field_mutable:auth.Auth.R_ver)
  return _msg;
}
inline void Auth::set_allocated_r_ver(::auth::Register_Ver* r_ver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.r_ver_;
  }
  if (r_ver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(r_ver);
    if (message_arena != submessage_arena) {
      r_ver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, r_ver, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.r_ver_ = r_ver;
  // @@protoc_insertion_point(field_set_allocated:auth.Auth.R_ver)
}

// .auth.Login_Ver L_ver = 7;
inline bool Auth::_internal_has_l_ver() const {
  return this != internal_default_instance() && _impl_.l_ver_ != nullptr;
}
inline bool Auth::has_l_ver() const {
  return _internal_has_l_ver();
}
inline void Auth::clear_l_ver() {
  if (GetArenaForAllocation() == nullptr && _impl_.l_ver_ != nullptr) {
    delete _impl_.l_ver_;
  }
  _impl_.l_ver_ = nullptr;
}
inline const ::auth::Login_Ver& Auth::_internal_l_ver() const {
  const ::auth::Login_Ver* p = _impl_.l_ver_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::Login_Ver&>(
      ::auth::_Login_Ver_default_instance_);
}
inline const ::auth::Login_Ver& Auth::l_ver() const {
  // @@protoc_insertion_point(field_get:auth.Auth.L_ver)
  return _internal_l_ver();
}
inline void Auth::unsafe_arena_set_allocated_l_ver(
    ::auth::Login_Ver* l_ver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.l_ver_);
  }
  _impl_.l_ver_ = l_ver;
  if (l_ver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Auth.L_ver)
}
inline ::auth::Login_Ver* Auth::release_l_ver() {
  
  ::auth::Login_Ver* temp = _impl_.l_ver_;
  _impl_.l_ver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::Login_Ver* Auth::unsafe_arena_release_l_ver() {
  // @@protoc_insertion_point(field_release:auth.Auth.L_ver)
  
  ::auth::Login_Ver* temp = _impl_.l_ver_;
  _impl_.l_ver_ = nullptr;
  return temp;
}
inline ::auth::Login_Ver* Auth::_internal_mutable_l_ver() {
  
  if (_impl_.l_ver_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::Login_Ver>(GetArenaForAllocation());
    _impl_.l_ver_ = p;
  }
  return _impl_.l_ver_;
}
inline ::auth::Login_Ver* Auth::mutable_l_ver() {
  ::auth::Login_Ver* _msg = _internal_mutable_l_ver();
  // @@protoc_insertion_point(field_mutable:auth.Auth.L_ver)
  return _msg;
}
inline void Auth::set_allocated_l_ver(::auth::Login_Ver* l_ver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.l_ver_;
  }
  if (l_ver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(l_ver);
    if (message_arena != submessage_arena) {
      l_ver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, l_ver, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.l_ver_ = l_ver;
  // @@protoc_insertion_point(field_set_allocated:auth.Auth.L_ver)
}

// string msg = 8;
inline void Auth::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& Auth::msg() const {
  // @@protoc_insertion_point(field_get:auth.Auth.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Auth::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Auth.msg)
}
inline std::string* Auth::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:auth.Auth.msg)
  return _s;
}
inline const std::string& Auth::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void Auth::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Auth::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Auth::release_msg() {
  // @@protoc_insertion_point(field_release:auth.Auth.msg)
  return _impl_.msg_.Release();
}
inline void Auth::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Auth.msg)
}

// -------------------------------------------------------------------

// Register_Ver

// string email_msg = 1;
inline void Register_Ver::clear_email_msg() {
  _impl_.email_msg_.ClearToEmpty();
}
inline const std::string& Register_Ver::email_msg() const {
  // @@protoc_insertion_point(field_get:auth.Register_Ver.email_msg)
  return _internal_email_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register_Ver::set_email_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Register_Ver.email_msg)
}
inline std::string* Register_Ver::mutable_email_msg() {
  std::string* _s = _internal_mutable_email_msg();
  // @@protoc_insertion_point(field_mutable:auth.Register_Ver.email_msg)
  return _s;
}
inline const std::string& Register_Ver::_internal_email_msg() const {
  return _impl_.email_msg_.Get();
}
inline void Register_Ver::_internal_set_email_msg(const std::string& value) {
  
  _impl_.email_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Register_Ver::_internal_mutable_email_msg() {
  
  return _impl_.email_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Register_Ver::release_email_msg() {
  // @@protoc_insertion_point(field_release:auth.Register_Ver.email_msg)
  return _impl_.email_msg_.Release();
}
inline void Register_Ver::set_allocated_email_msg(std::string* email_msg) {
  if (email_msg != nullptr) {
    
  } else {
    
  }
  _impl_.email_msg_.SetAllocated(email_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_msg_.IsDefault()) {
    _impl_.email_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Register_Ver.email_msg)
}

// bool decide = 2;
inline void Register_Ver::clear_decide() {
  _impl_.decide_ = false;
}
inline bool Register_Ver::_internal_decide() const {
  return _impl_.decide_;
}
inline bool Register_Ver::decide() const {
  // @@protoc_insertion_point(field_get:auth.Register_Ver.decide)
  return _internal_decide();
}
inline void Register_Ver::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void Register_Ver::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:auth.Register_Ver.decide)
}

// string time = 3;
inline void Register_Ver::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& Register_Ver::time() const {
  // @@protoc_insertion_point(field_get:auth.Register_Ver.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register_Ver::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Register_Ver.time)
}
inline std::string* Register_Ver::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:auth.Register_Ver.time)
  return _s;
}
inline const std::string& Register_Ver::_internal_time() const {
  return _impl_.time_.Get();
}
inline void Register_Ver::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* Register_Ver::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* Register_Ver::release_time() {
  // @@protoc_insertion_point(field_release:auth.Register_Ver.time)
  return _impl_.time_.Release();
}
inline void Register_Ver::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Register_Ver.time)
}

// string username = 4;
inline void Register_Ver::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Register_Ver::username() const {
  // @@protoc_insertion_point(field_get:auth.Register_Ver.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register_Ver::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Register_Ver.username)
}
inline std::string* Register_Ver::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:auth.Register_Ver.username)
  return _s;
}
inline const std::string& Register_Ver::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Register_Ver::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Register_Ver::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Register_Ver::release_username() {
  // @@protoc_insertion_point(field_release:auth.Register_Ver.username)
  return _impl_.username_.Release();
}
inline void Register_Ver::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Register_Ver.username)
}

// -------------------------------------------------------------------

// Login_Ver

// bool decide = 1;
inline void Login_Ver::clear_decide() {
  _impl_.decide_ = false;
}
inline bool Login_Ver::_internal_decide() const {
  return _impl_.decide_;
}
inline bool Login_Ver::decide() const {
  // @@protoc_insertion_point(field_get:auth.Login_Ver.decide)
  return _internal_decide();
}
inline void Login_Ver::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void Login_Ver::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:auth.Login_Ver.decide)
}

// string email_msg = 2;
inline void Login_Ver::clear_email_msg() {
  _impl_.email_msg_.ClearToEmpty();
}
inline const std::string& Login_Ver::email_msg() const {
  // @@protoc_insertion_point(field_get:auth.Login_Ver.email_msg)
  return _internal_email_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login_Ver::set_email_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Login_Ver.email_msg)
}
inline std::string* Login_Ver::mutable_email_msg() {
  std::string* _s = _internal_mutable_email_msg();
  // @@protoc_insertion_point(field_mutable:auth.Login_Ver.email_msg)
  return _s;
}
inline const std::string& Login_Ver::_internal_email_msg() const {
  return _impl_.email_msg_.Get();
}
inline void Login_Ver::_internal_set_email_msg(const std::string& value) {
  
  _impl_.email_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Login_Ver::_internal_mutable_email_msg() {
  
  return _impl_.email_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Login_Ver::release_email_msg() {
  // @@protoc_insertion_point(field_release:auth.Login_Ver.email_msg)
  return _impl_.email_msg_.Release();
}
inline void Login_Ver::set_allocated_email_msg(std::string* email_msg) {
  if (email_msg != nullptr) {
    
  } else {
    
  }
  _impl_.email_msg_.SetAllocated(email_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_msg_.IsDefault()) {
    _impl_.email_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Login_Ver.email_msg)
}

// string time = 3;
inline void Login_Ver::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& Login_Ver::time() const {
  // @@protoc_insertion_point(field_get:auth.Login_Ver.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login_Ver::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Login_Ver.time)
}
inline std::string* Login_Ver::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:auth.Login_Ver.time)
  return _s;
}
inline const std::string& Login_Ver::_internal_time() const {
  return _impl_.time_.Get();
}
inline void Login_Ver::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* Login_Ver::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* Login_Ver::release_time() {
  // @@protoc_insertion_point(field_release:auth.Login_Ver.time)
  return _impl_.time_.Release();
}
inline void Login_Ver::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Login_Ver.time)
}

// string username = 4;
inline void Login_Ver::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Login_Ver::username() const {
  // @@protoc_insertion_point(field_get:auth.Login_Ver.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login_Ver::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Login_Ver.username)
}
inline std::string* Login_Ver::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:auth.Login_Ver.username)
  return _s;
}
inline const std::string& Login_Ver::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Login_Ver::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Login_Ver::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Login_Ver::release_username() {
  // @@protoc_insertion_point(field_release:auth.Login_Ver.username)
  return _impl_.username_.Release();
}
inline void Login_Ver::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Login_Ver.username)
}

// -------------------------------------------------------------------

// RegisterRequest

// string username = 1;
inline void RegisterRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:auth.RegisterRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.RegisterRequest.username)
}
inline std::string* RegisterRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:auth.RegisterRequest.username)
  return _s;
}
inline const std::string& RegisterRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void RegisterRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:auth.RegisterRequest.username)
  return _impl_.username_.Release();
}
inline void RegisterRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.RegisterRequest.username)
}

// string password = 2;
inline void RegisterRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::password() const {
  // @@protoc_insertion_point(field_get:auth.RegisterRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:auth.RegisterRequest.password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void RegisterRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_password() {
  // @@protoc_insertion_point(field_release:auth.RegisterRequest.password)
  return _impl_.password_.Release();
}
inline void RegisterRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.RegisterRequest.password)
}

// string email = 3;
inline void RegisterRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterRequest::email() const {
  // @@protoc_insertion_point(field_get:auth.RegisterRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.RegisterRequest.email)
}
inline std::string* RegisterRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:auth.RegisterRequest.email)
  return _s;
}
inline const std::string& RegisterRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void RegisterRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_email() {
  // @@protoc_insertion_point(field_release:auth.RegisterRequest.email)
  return _impl_.email_.Release();
}
inline void RegisterRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.RegisterRequest.email)
}

// string phone = 4;
inline void RegisterRequest::clear_phone() {
  _impl_.phone_.ClearToEmpty();
}
inline const std::string& RegisterRequest::phone() const {
  // @@protoc_insertion_point(field_get:auth.RegisterRequest.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_phone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.RegisterRequest.phone)
}
inline std::string* RegisterRequest::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:auth.RegisterRequest.phone)
  return _s;
}
inline const std::string& RegisterRequest::_internal_phone() const {
  return _impl_.phone_.Get();
}
inline void RegisterRequest::_internal_set_phone(const std::string& value) {
  
  _impl_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_phone() {
  
  return _impl_.phone_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_phone() {
  // @@protoc_insertion_point(field_release:auth.RegisterRequest.phone)
  return _impl_.phone_.Release();
}
inline void RegisterRequest::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  _impl_.phone_.SetAllocated(phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phone_.IsDefault()) {
    _impl_.phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.RegisterRequest.phone)
}

// string verification_code = 5;
inline void RegisterRequest::clear_verification_code() {
  _impl_.verification_code_.ClearToEmpty();
}
inline const std::string& RegisterRequest::verification_code() const {
  // @@protoc_insertion_point(field_get:auth.RegisterRequest.verification_code)
  return _internal_verification_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_verification_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verification_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.RegisterRequest.verification_code)
}
inline std::string* RegisterRequest::mutable_verification_code() {
  std::string* _s = _internal_mutable_verification_code();
  // @@protoc_insertion_point(field_mutable:auth.RegisterRequest.verification_code)
  return _s;
}
inline const std::string& RegisterRequest::_internal_verification_code() const {
  return _impl_.verification_code_.Get();
}
inline void RegisterRequest::_internal_set_verification_code(const std::string& value) {
  
  _impl_.verification_code_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_verification_code() {
  
  return _impl_.verification_code_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_verification_code() {
  // @@protoc_insertion_point(field_release:auth.RegisterRequest.verification_code)
  return _impl_.verification_code_.Release();
}
inline void RegisterRequest::set_allocated_verification_code(std::string* verification_code) {
  if (verification_code != nullptr) {
    
  } else {
    
  }
  _impl_.verification_code_.SetAllocated(verification_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_code_.IsDefault()) {
    _impl_.verification_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.RegisterRequest.verification_code)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool decide = 1;
inline void RegisterResponse::clear_decide() {
  _impl_.decide_ = false;
}
inline bool RegisterResponse::_internal_decide() const {
  return _impl_.decide_;
}
inline bool RegisterResponse::decide() const {
  // @@protoc_insertion_point(field_get:auth.RegisterResponse.decide)
  return _internal_decide();
}
inline void RegisterResponse::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void RegisterResponse::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:auth.RegisterResponse.decide)
}

// string msg = 2;
inline void RegisterResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& RegisterResponse::msg() const {
  // @@protoc_insertion_point(field_get:auth.RegisterResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.RegisterResponse.msg)
}
inline std::string* RegisterResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:auth.RegisterResponse.msg)
  return _s;
}
inline const std::string& RegisterResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void RegisterResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_msg() {
  // @@protoc_insertion_point(field_release:auth.RegisterResponse.msg)
  return _impl_.msg_.Release();
}
inline void RegisterResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.RegisterResponse.msg)
}

// string time = 4;
inline void RegisterResponse::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& RegisterResponse::time() const {
  // @@protoc_insertion_point(field_get:auth.RegisterResponse.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.RegisterResponse.time)
}
inline std::string* RegisterResponse::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:auth.RegisterResponse.time)
  return _s;
}
inline const std::string& RegisterResponse::_internal_time() const {
  return _impl_.time_.Get();
}
inline void RegisterResponse::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_time() {
  // @@protoc_insertion_point(field_release:auth.RegisterResponse.time)
  return _impl_.time_.Release();
}
inline void RegisterResponse::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.RegisterResponse.time)
}

// -------------------------------------------------------------------

// LogInRequest

// .auth.Select select = 1;
inline void LogInRequest::clear_select() {
  _impl_.select_ = 0;
}
inline ::auth::Select LogInRequest::_internal_select() const {
  return static_cast< ::auth::Select >(_impl_.select_);
}
inline ::auth::Select LogInRequest::select() const {
  // @@protoc_insertion_point(field_get:auth.LogInRequest.select)
  return _internal_select();
}
inline void LogInRequest::_internal_set_select(::auth::Select value) {
  
  _impl_.select_ = value;
}
inline void LogInRequest::set_select(::auth::Select value) {
  _internal_set_select(value);
  // @@protoc_insertion_point(field_set:auth.LogInRequest.select)
}

// string username = 2;
inline void LogInRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LogInRequest::username() const {
  // @@protoc_insertion_point(field_get:auth.LogInRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogInRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.LogInRequest.username)
}
inline std::string* LogInRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:auth.LogInRequest.username)
  return _s;
}
inline const std::string& LogInRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LogInRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LogInRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LogInRequest::release_username() {
  // @@protoc_insertion_point(field_release:auth.LogInRequest.username)
  return _impl_.username_.Release();
}
inline void LogInRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.LogInRequest.username)
}

// string password = 3;
inline void LogInRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LogInRequest::password() const {
  // @@protoc_insertion_point(field_get:auth.LogInRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogInRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.LogInRequest.password)
}
inline std::string* LogInRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:auth.LogInRequest.password)
  return _s;
}
inline const std::string& LogInRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LogInRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LogInRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LogInRequest::release_password() {
  // @@protoc_insertion_point(field_release:auth.LogInRequest.password)
  return _impl_.password_.Release();
}
inline void LogInRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.LogInRequest.password)
}

// string email = 4;
inline void LogInRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& LogInRequest::email() const {
  // @@protoc_insertion_point(field_get:auth.LogInRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogInRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.LogInRequest.email)
}
inline std::string* LogInRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:auth.LogInRequest.email)
  return _s;
}
inline const std::string& LogInRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void LogInRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* LogInRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* LogInRequest::release_email() {
  // @@protoc_insertion_point(field_release:auth.LogInRequest.email)
  return _impl_.email_.Release();
}
inline void LogInRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.LogInRequest.email)
}

// string Verification_code = 5;
inline void LogInRequest::clear_verification_code() {
  _impl_.verification_code_.ClearToEmpty();
}
inline const std::string& LogInRequest::verification_code() const {
  // @@protoc_insertion_point(field_get:auth.LogInRequest.Verification_code)
  return _internal_verification_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogInRequest::set_verification_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verification_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.LogInRequest.Verification_code)
}
inline std::string* LogInRequest::mutable_verification_code() {
  std::string* _s = _internal_mutable_verification_code();
  // @@protoc_insertion_point(field_mutable:auth.LogInRequest.Verification_code)
  return _s;
}
inline const std::string& LogInRequest::_internal_verification_code() const {
  return _impl_.verification_code_.Get();
}
inline void LogInRequest::_internal_set_verification_code(const std::string& value) {
  
  _impl_.verification_code_.Set(value, GetArenaForAllocation());
}
inline std::string* LogInRequest::_internal_mutable_verification_code() {
  
  return _impl_.verification_code_.Mutable(GetArenaForAllocation());
}
inline std::string* LogInRequest::release_verification_code() {
  // @@protoc_insertion_point(field_release:auth.LogInRequest.Verification_code)
  return _impl_.verification_code_.Release();
}
inline void LogInRequest::set_allocated_verification_code(std::string* verification_code) {
  if (verification_code != nullptr) {
    
  } else {
    
  }
  _impl_.verification_code_.SetAllocated(verification_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_code_.IsDefault()) {
    _impl_.verification_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.LogInRequest.Verification_code)
}

// -------------------------------------------------------------------

// LogInResponse

// int32 decide = 1;
inline void LogInResponse::clear_decide() {
  _impl_.decide_ = 0;
}
inline int32_t LogInResponse::_internal_decide() const {
  return _impl_.decide_;
}
inline int32_t LogInResponse::decide() const {
  // @@protoc_insertion_point(field_get:auth.LogInResponse.decide)
  return _internal_decide();
}
inline void LogInResponse::_internal_set_decide(int32_t value) {
  
  _impl_.decide_ = value;
}
inline void LogInResponse::set_decide(int32_t value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:auth.LogInResponse.decide)
}

// -------------------------------------------------------------------

// LogoutResquest

// string username = 1;
inline void LogoutResquest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LogoutResquest::username() const {
  // @@protoc_insertion_point(field_get:auth.LogoutResquest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutResquest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.LogoutResquest.username)
}
inline std::string* LogoutResquest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:auth.LogoutResquest.username)
  return _s;
}
inline const std::string& LogoutResquest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LogoutResquest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutResquest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutResquest::release_username() {
  // @@protoc_insertion_point(field_release:auth.LogoutResquest.username)
  return _impl_.username_.Release();
}
inline void LogoutResquest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.LogoutResquest.username)
}

// string password = 2;
inline void LogoutResquest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LogoutResquest::password() const {
  // @@protoc_insertion_point(field_get:auth.LogoutResquest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutResquest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.LogoutResquest.password)
}
inline std::string* LogoutResquest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:auth.LogoutResquest.password)
  return _s;
}
inline const std::string& LogoutResquest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LogoutResquest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutResquest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutResquest::release_password() {
  // @@protoc_insertion_point(field_release:auth.LogoutResquest.password)
  return _impl_.password_.Release();
}
inline void LogoutResquest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.LogoutResquest.password)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace auth

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::auth::actions> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::auth::actions>() {
  return ::auth::actions_descriptor();
}
template <> struct is_proto_enum< ::auth::Select> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::auth::Select>() {
  return ::auth::Select_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_5fauth_2eproto
