// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user_chat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_5fchat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_5fchat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_5fchat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_5fchat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_5fchat_2eproto;
namespace chat {
class AddFriendRequest;
struct AddFriendRequestDefaultTypeInternal;
extern AddFriendRequestDefaultTypeInternal _AddFriendRequest_default_instance_;
class AddFriendResponse;
struct AddFriendResponseDefaultTypeInternal;
extern AddFriendResponseDefaultTypeInternal _AddFriendResponse_default_instance_;
class AddGroup;
struct AddGroupDefaultTypeInternal;
extern AddGroupDefaultTypeInternal _AddGroup_default_instance_;
class AddManager;
struct AddManagerDefaultTypeInternal;
extern AddManagerDefaultTypeInternal _AddManager_default_instance_;
class AddMember;
struct AddMemberDefaultTypeInternal;
extern AddMemberDefaultTypeInternal _AddMember_default_instance_;
class AddMemberResponse;
struct AddMemberResponseDefaultTypeInternal;
extern AddMemberResponseDefaultTypeInternal _AddMemberResponse_default_instance_;
class BlockFriend;
struct BlockFriendDefaultTypeInternal;
extern BlockFriendDefaultTypeInternal _BlockFriend_default_instance_;
class Chat;
struct ChatDefaultTypeInternal;
extern ChatDefaultTypeInternal _Chat_default_instance_;
class ChoiceGroup;
struct ChoiceGroupDefaultTypeInternal;
extern ChoiceGroupDefaultTypeInternal _ChoiceGroup_default_instance_;
class DelManager;
struct DelManagerDefaultTypeInternal;
extern DelManagerDefaultTypeInternal _DelManager_default_instance_;
class DelMember;
struct DelMemberDefaultTypeInternal;
extern DelMemberDefaultTypeInternal _DelMember_default_instance_;
class DelMemberResponse;
struct DelMemberResponseDefaultTypeInternal;
extern DelMemberResponseDefaultTypeInternal _DelMemberResponse_default_instance_;
class DeleteFriendRequest;
struct DeleteFriendRequestDefaultTypeInternal;
extern DeleteFriendRequestDefaultTypeInternal _DeleteFriendRequest_default_instance_;
class DeleteFriendResponse;
struct DeleteFriendResponseDefaultTypeInternal;
extern DeleteFriendResponseDefaultTypeInternal _DeleteFriendResponse_default_instance_;
class DisbandGroup;
struct DisbandGroupDefaultTypeInternal;
extern DisbandGroupDefaultTypeInternal _DisbandGroup_default_instance_;
class FileList;
struct FileListDefaultTypeInternal;
extern FileListDefaultTypeInternal _FileList_default_instance_;
class FileListGroup;
struct FileListGroupDefaultTypeInternal;
extern FileListGroupDefaultTypeInternal _FileListGroup_default_instance_;
class FindRequest;
struct FindRequestDefaultTypeInternal;
extern FindRequestDefaultTypeInternal _FindRequest_default_instance_;
class FindRequest_ResponseEntry_DoNotUse;
struct FindRequest_ResponseEntry_DoNotUseDefaultTypeInternal;
extern FindRequest_ResponseEntry_DoNotUseDefaultTypeInternal _FindRequest_ResponseEntry_DoNotUse_default_instance_;
class FriendChatMessage;
struct FriendChatMessageDefaultTypeInternal;
extern FriendChatMessageDefaultTypeInternal _FriendChatMessage_default_instance_;
class FriendLists;
struct FriendListsDefaultTypeInternal;
extern FriendListsDefaultTypeInternal _FriendLists_default_instance_;
class FriendLists_FriendsEntry_DoNotUse;
struct FriendLists_FriendsEntry_DoNotUseDefaultTypeInternal;
extern FriendLists_FriendsEntry_DoNotUseDefaultTypeInternal _FriendLists_FriendsEntry_DoNotUse_default_instance_;
class GroupChat;
struct GroupChatDefaultTypeInternal;
extern GroupChatDefaultTypeInternal _GroupChat_default_instance_;
class GroupChatList;
struct GroupChatListDefaultTypeInternal;
extern GroupChatListDefaultTypeInternal _GroupChatList_default_instance_;
class GroupList;
struct GroupListDefaultTypeInternal;
extern GroupListDefaultTypeInternal _GroupList_default_instance_;
class GroupMembers;
struct GroupMembersDefaultTypeInternal;
extern GroupMembersDefaultTypeInternal _GroupMembers_default_instance_;
class GroupMembers_MembersEntry_DoNotUse;
struct GroupMembers_MembersEntry_DoNotUseDefaultTypeInternal;
extern GroupMembers_MembersEntry_DoNotUseDefaultTypeInternal _GroupMembers_MembersEntry_DoNotUse_default_instance_;
class JoinGroup;
struct JoinGroupDefaultTypeInternal;
extern JoinGroupDefaultTypeInternal _JoinGroup_default_instance_;
class JoinGroupResponse;
struct JoinGroupResponseDefaultTypeInternal;
extern JoinGroupResponseDefaultTypeInternal _JoinGroupResponse_default_instance_;
class LeaveGroup;
struct LeaveGroupDefaultTypeInternal;
extern LeaveGroupDefaultTypeInternal _LeaveGroup_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LoginResponse_ResultEntry_DoNotUse;
struct LoginResponse_ResultEntry_DoNotUseDefaultTypeInternal;
extern LoginResponse_ResultEntry_DoNotUseDefaultTypeInternal _LoginResponse_ResultEntry_DoNotUse_default_instance_;
class LookFileRequest;
struct LookFileRequestDefaultTypeInternal;
extern LookFileRequestDefaultTypeInternal _LookFileRequest_default_instance_;
class LookFileRequestGroup;
struct LookFileRequestGroupDefaultTypeInternal;
extern LookFileRequestGroupDefaultTypeInternal _LookFileRequestGroup_default_instance_;
class LookFileRequestGroup_ResultEntry_DoNotUse;
struct LookFileRequestGroup_ResultEntry_DoNotUseDefaultTypeInternal;
extern LookFileRequestGroup_ResultEntry_DoNotUseDefaultTypeInternal _LookFileRequestGroup_ResultEntry_DoNotUse_default_instance_;
class LookFileRequest_ResultEntry_DoNotUse;
struct LookFileRequest_ResultEntry_DoNotUseDefaultTypeInternal;
extern LookFileRequest_ResultEntry_DoNotUseDefaultTypeInternal _LookFileRequest_ResultEntry_DoNotUse_default_instance_;
class OfflineMSG;
struct OfflineMSGDefaultTypeInternal;
extern OfflineMSGDefaultTypeInternal _OfflineMSG_default_instance_;
class RecvFile;
struct RecvFileDefaultTypeInternal;
extern RecvFileDefaultTypeInternal _RecvFile_default_instance_;
class RecvFileGroup;
struct RecvFileGroupDefaultTypeInternal;
extern RecvFileGroupDefaultTypeInternal _RecvFileGroup_default_instance_;
class SendFile;
struct SendFileDefaultTypeInternal;
extern SendFileDefaultTypeInternal _SendFile_default_instance_;
class SendFileGroup;
struct SendFileGroupDefaultTypeInternal;
extern SendFileGroupDefaultTypeInternal _SendFileGroup_default_instance_;
class UserRequest;
struct UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
class UserRequest_ResultEntry_DoNotUse;
struct UserRequest_ResultEntry_DoNotUseDefaultTypeInternal;
extern UserRequest_ResultEntry_DoNotUseDefaultTypeInternal _UserRequest_ResultEntry_DoNotUse_default_instance_;
class delAccount;
struct delAccountDefaultTypeInternal;
extern delAccountDefaultTypeInternal _delAccount_default_instance_;
class delAccount_GroupNameEntry_DoNotUse;
struct delAccount_GroupNameEntry_DoNotUseDefaultTypeInternal;
extern delAccount_GroupNameEntry_DoNotUseDefaultTypeInternal _delAccount_GroupNameEntry_DoNotUse_default_instance_;
}  // namespace chat
PROTOBUF_NAMESPACE_OPEN
template<> ::chat::AddFriendRequest* Arena::CreateMaybeMessage<::chat::AddFriendRequest>(Arena*);
template<> ::chat::AddFriendResponse* Arena::CreateMaybeMessage<::chat::AddFriendResponse>(Arena*);
template<> ::chat::AddGroup* Arena::CreateMaybeMessage<::chat::AddGroup>(Arena*);
template<> ::chat::AddManager* Arena::CreateMaybeMessage<::chat::AddManager>(Arena*);
template<> ::chat::AddMember* Arena::CreateMaybeMessage<::chat::AddMember>(Arena*);
template<> ::chat::AddMemberResponse* Arena::CreateMaybeMessage<::chat::AddMemberResponse>(Arena*);
template<> ::chat::BlockFriend* Arena::CreateMaybeMessage<::chat::BlockFriend>(Arena*);
template<> ::chat::Chat* Arena::CreateMaybeMessage<::chat::Chat>(Arena*);
template<> ::chat::ChoiceGroup* Arena::CreateMaybeMessage<::chat::ChoiceGroup>(Arena*);
template<> ::chat::DelManager* Arena::CreateMaybeMessage<::chat::DelManager>(Arena*);
template<> ::chat::DelMember* Arena::CreateMaybeMessage<::chat::DelMember>(Arena*);
template<> ::chat::DelMemberResponse* Arena::CreateMaybeMessage<::chat::DelMemberResponse>(Arena*);
template<> ::chat::DeleteFriendRequest* Arena::CreateMaybeMessage<::chat::DeleteFriendRequest>(Arena*);
template<> ::chat::DeleteFriendResponse* Arena::CreateMaybeMessage<::chat::DeleteFriendResponse>(Arena*);
template<> ::chat::DisbandGroup* Arena::CreateMaybeMessage<::chat::DisbandGroup>(Arena*);
template<> ::chat::FileList* Arena::CreateMaybeMessage<::chat::FileList>(Arena*);
template<> ::chat::FileListGroup* Arena::CreateMaybeMessage<::chat::FileListGroup>(Arena*);
template<> ::chat::FindRequest* Arena::CreateMaybeMessage<::chat::FindRequest>(Arena*);
template<> ::chat::FindRequest_ResponseEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::FindRequest_ResponseEntry_DoNotUse>(Arena*);
template<> ::chat::FriendChatMessage* Arena::CreateMaybeMessage<::chat::FriendChatMessage>(Arena*);
template<> ::chat::FriendLists* Arena::CreateMaybeMessage<::chat::FriendLists>(Arena*);
template<> ::chat::FriendLists_FriendsEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::FriendLists_FriendsEntry_DoNotUse>(Arena*);
template<> ::chat::GroupChat* Arena::CreateMaybeMessage<::chat::GroupChat>(Arena*);
template<> ::chat::GroupChatList* Arena::CreateMaybeMessage<::chat::GroupChatList>(Arena*);
template<> ::chat::GroupList* Arena::CreateMaybeMessage<::chat::GroupList>(Arena*);
template<> ::chat::GroupMembers* Arena::CreateMaybeMessage<::chat::GroupMembers>(Arena*);
template<> ::chat::GroupMembers_MembersEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::GroupMembers_MembersEntry_DoNotUse>(Arena*);
template<> ::chat::JoinGroup* Arena::CreateMaybeMessage<::chat::JoinGroup>(Arena*);
template<> ::chat::JoinGroupResponse* Arena::CreateMaybeMessage<::chat::JoinGroupResponse>(Arena*);
template<> ::chat::LeaveGroup* Arena::CreateMaybeMessage<::chat::LeaveGroup>(Arena*);
template<> ::chat::Login* Arena::CreateMaybeMessage<::chat::Login>(Arena*);
template<> ::chat::LoginResponse* Arena::CreateMaybeMessage<::chat::LoginResponse>(Arena*);
template<> ::chat::LoginResponse_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::LoginResponse_ResultEntry_DoNotUse>(Arena*);
template<> ::chat::LookFileRequest* Arena::CreateMaybeMessage<::chat::LookFileRequest>(Arena*);
template<> ::chat::LookFileRequestGroup* Arena::CreateMaybeMessage<::chat::LookFileRequestGroup>(Arena*);
template<> ::chat::LookFileRequestGroup_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::LookFileRequestGroup_ResultEntry_DoNotUse>(Arena*);
template<> ::chat::LookFileRequest_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::LookFileRequest_ResultEntry_DoNotUse>(Arena*);
template<> ::chat::OfflineMSG* Arena::CreateMaybeMessage<::chat::OfflineMSG>(Arena*);
template<> ::chat::RecvFile* Arena::CreateMaybeMessage<::chat::RecvFile>(Arena*);
template<> ::chat::RecvFileGroup* Arena::CreateMaybeMessage<::chat::RecvFileGroup>(Arena*);
template<> ::chat::SendFile* Arena::CreateMaybeMessage<::chat::SendFile>(Arena*);
template<> ::chat::SendFileGroup* Arena::CreateMaybeMessage<::chat::SendFileGroup>(Arena*);
template<> ::chat::UserRequest* Arena::CreateMaybeMessage<::chat::UserRequest>(Arena*);
template<> ::chat::UserRequest_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::UserRequest_ResultEntry_DoNotUse>(Arena*);
template<> ::chat::delAccount* Arena::CreateMaybeMessage<::chat::delAccount>(Arena*);
template<> ::chat::delAccount_GroupNameEntry_DoNotUse* Arena::CreateMaybeMessage<::chat::delAccount_GroupNameEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chat {

enum Actions : int {
  ACTION_QUIT = 0,
  LOGIN = 21,
  UNLOGIN = 15,
  ADDFDREQ = 3,
  ADDFDRES = 4,
  HEART = 5,
  FDLIST = 6,
  FRIENDMSG = 7,
  USERNTF = 8,
  UNUSERNTF = 9,
  DELFDREQ = 10,
  DELFDRES = 11,
  RESPONSE = 12,
  OFFLINEMSG = 13,
  LOGINLIST = 14,
  BLOCKFRIEND = 16,
  UNBLOCKFRIEND = 17,
  SENDFILE = 18,
  RECVFILE = 19,
  LOOKFILE = 20,
  DELACCOUNT = 22,
  Actions_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Actions_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Actions_IsValid(int value);
constexpr Actions Actions_MIN = ACTION_QUIT;
constexpr Actions Actions_MAX = DELACCOUNT;
constexpr int Actions_ARRAYSIZE = Actions_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Actions_descriptor();
template<typename T>
inline const std::string& Actions_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Actions>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Actions_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Actions_descriptor(), enum_t_value);
}
inline bool Actions_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Actions* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Actions>(
    Actions_descriptor(), name, value);
}
enum Group : int {
  GROUP_QUIT = 0,
  GROUPLIST = 1,
  ADDGROUP = 2,
  JOINGROUP = 3,
  JOINGROUPRESPONSE = 4,
  FINDREQ = 5,
  CHOICEGROUP = 6,
  GROUPMEMBERS = 7,
  GROUPMSG = 8,
  CHATGROUPLIST = 9,
  LEAVEGROUP = 10,
  ADDMEMBER = 11,
  DELMEMBER = 12,
  ADDMEMBERRES = 13,
  DELMEMBERRES = 14,
  DISBANDGROUP = 15,
  ADDMANAGER = 16,
  ADDMANAGERRES = 18,
  DELMANAGER = 17,
  DELMANAGERRES = 19,
  SENDFILEGROUP = 20,
  RECVFILEGROUP = 21,
  LOOKFILEGROUP = 22,
  Group_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Group_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Group_IsValid(int value);
constexpr Group Group_MIN = GROUP_QUIT;
constexpr Group Group_MAX = LOOKFILEGROUP;
constexpr int Group_ARRAYSIZE = Group_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Group_descriptor();
template<typename T>
inline const std::string& Group_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Group>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Group_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Group_descriptor(), enum_t_value);
}
inline bool Group_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Group* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Group>(
    Group_descriptor(), name, value);
}
// ===================================================================

class Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.Chat) */ {
 public:
  inline Chat() : Chat(nullptr) {}
  ~Chat() override;
  explicit PROTOBUF_CONSTEXPR Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chat(const Chat& from);
  Chat(Chat&& from) noexcept
    : Chat() {
    *this = ::std::move(from);
  }

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chat& operator=(Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chat* internal_default_instance() {
    return reinterpret_cast<const Chat*>(
               &_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Chat& a, Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(Chat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Chat& from) {
    Chat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.Chat";
  }
  protected:
  explicit Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartFieldNumber = 9,
    kChatFdFieldNumber = 2,
    kFriendReqFieldNumber = 4,
    kFriendResFieldNumber = 5,
    kFriendsFieldNumber = 6,
    kReqFieldNumber = 7,
    kLogFieldNumber = 8,
    kFriendDelReqFieldNumber = 10,
    kFriendDelResFieldNumber = 11,
    kResponseFieldNumber = 12,
    kOffMsgFieldNumber = 13,
    kBlockFriendFieldNumber = 14,
    kSendFileFieldNumber = 15,
    kRecvFileFieldNumber = 16,
    kFileReqFieldNumber = 17,
    kAddGroupFieldNumber = 19,
    kJoinGroupFieldNumber = 20,
    kJoinResFieldNumber = 21,
    kGroupListFieldNumber = 22,
    kGroupNotifyFieldNumber = 23,
    kGroupChoiceFieldNumber = 24,
    kGroupMembersFieldNumber = 25,
    kGroupChatFieldNumber = 26,
    kChatListFieldNumber = 27,
    kLeaveGroupFieldNumber = 28,
    kAddMemberFieldNumber = 29,
    kDelMemberFieldNumber = 30,
    kAddMemberResFieldNumber = 31,
    kDelMemberResFieldNumber = 32,
    kDisbandGroupFieldNumber = 33,
    kAddManagerFieldNumber = 34,
    kDelManagerFieldNumber = 35,
    kRecvFileGroupFieldNumber = 36,
    kSendFileGroupFieldNumber = 37,
    kFileListGroupFieldNumber = 38,
    kLookFieleReqGroupFieldNumber = 39,
    kDelAccountFieldNumber = 40,
    kActionFieldNumber = 1,
    kGroupFieldNumber = 18,
  };
  // string heart = 9;
  void clear_heart();
  const std::string& heart() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_heart(ArgT0&& arg0, ArgT... args);
  std::string* mutable_heart();
  PROTOBUF_NODISCARD std::string* release_heart();
  void set_allocated_heart(std::string* heart);
  private:
  const std::string& _internal_heart() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heart(const std::string& value);
  std::string* _internal_mutable_heart();
  public:

  // .chat.FriendChatMessage chat_fd = 2;
  bool has_chat_fd() const;
  private:
  bool _internal_has_chat_fd() const;
  public:
  void clear_chat_fd();
  const ::chat::FriendChatMessage& chat_fd() const;
  PROTOBUF_NODISCARD ::chat::FriendChatMessage* release_chat_fd();
  ::chat::FriendChatMessage* mutable_chat_fd();
  void set_allocated_chat_fd(::chat::FriendChatMessage* chat_fd);
  private:
  const ::chat::FriendChatMessage& _internal_chat_fd() const;
  ::chat::FriendChatMessage* _internal_mutable_chat_fd();
  public:
  void unsafe_arena_set_allocated_chat_fd(
      ::chat::FriendChatMessage* chat_fd);
  ::chat::FriendChatMessage* unsafe_arena_release_chat_fd();

  // .chat.AddFriendRequest friend_req = 4;
  bool has_friend_req() const;
  private:
  bool _internal_has_friend_req() const;
  public:
  void clear_friend_req();
  const ::chat::AddFriendRequest& friend_req() const;
  PROTOBUF_NODISCARD ::chat::AddFriendRequest* release_friend_req();
  ::chat::AddFriendRequest* mutable_friend_req();
  void set_allocated_friend_req(::chat::AddFriendRequest* friend_req);
  private:
  const ::chat::AddFriendRequest& _internal_friend_req() const;
  ::chat::AddFriendRequest* _internal_mutable_friend_req();
  public:
  void unsafe_arena_set_allocated_friend_req(
      ::chat::AddFriendRequest* friend_req);
  ::chat::AddFriendRequest* unsafe_arena_release_friend_req();

  // .chat.AddFriendResponse friend_res = 5;
  bool has_friend_res() const;
  private:
  bool _internal_has_friend_res() const;
  public:
  void clear_friend_res();
  const ::chat::AddFriendResponse& friend_res() const;
  PROTOBUF_NODISCARD ::chat::AddFriendResponse* release_friend_res();
  ::chat::AddFriendResponse* mutable_friend_res();
  void set_allocated_friend_res(::chat::AddFriendResponse* friend_res);
  private:
  const ::chat::AddFriendResponse& _internal_friend_res() const;
  ::chat::AddFriendResponse* _internal_mutable_friend_res();
  public:
  void unsafe_arena_set_allocated_friend_res(
      ::chat::AddFriendResponse* friend_res);
  ::chat::AddFriendResponse* unsafe_arena_release_friend_res();

  // .chat.FriendLists friends = 6;
  bool has_friends() const;
  private:
  bool _internal_has_friends() const;
  public:
  void clear_friends();
  const ::chat::FriendLists& friends() const;
  PROTOBUF_NODISCARD ::chat::FriendLists* release_friends();
  ::chat::FriendLists* mutable_friends();
  void set_allocated_friends(::chat::FriendLists* friends);
  private:
  const ::chat::FriendLists& _internal_friends() const;
  ::chat::FriendLists* _internal_mutable_friends();
  public:
  void unsafe_arena_set_allocated_friends(
      ::chat::FriendLists* friends);
  ::chat::FriendLists* unsafe_arena_release_friends();

  // .chat.UserRequest req = 7;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::chat::UserRequest& req() const;
  PROTOBUF_NODISCARD ::chat::UserRequest* release_req();
  ::chat::UserRequest* mutable_req();
  void set_allocated_req(::chat::UserRequest* req);
  private:
  const ::chat::UserRequest& _internal_req() const;
  ::chat::UserRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::chat::UserRequest* req);
  ::chat::UserRequest* unsafe_arena_release_req();

  // .chat.Login log = 8;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::chat::Login& log() const;
  PROTOBUF_NODISCARD ::chat::Login* release_log();
  ::chat::Login* mutable_log();
  void set_allocated_log(::chat::Login* log);
  private:
  const ::chat::Login& _internal_log() const;
  ::chat::Login* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::chat::Login* log);
  ::chat::Login* unsafe_arena_release_log();

  // .chat.DeleteFriendRequest friend_del_req = 10;
  bool has_friend_del_req() const;
  private:
  bool _internal_has_friend_del_req() const;
  public:
  void clear_friend_del_req();
  const ::chat::DeleteFriendRequest& friend_del_req() const;
  PROTOBUF_NODISCARD ::chat::DeleteFriendRequest* release_friend_del_req();
  ::chat::DeleteFriendRequest* mutable_friend_del_req();
  void set_allocated_friend_del_req(::chat::DeleteFriendRequest* friend_del_req);
  private:
  const ::chat::DeleteFriendRequest& _internal_friend_del_req() const;
  ::chat::DeleteFriendRequest* _internal_mutable_friend_del_req();
  public:
  void unsafe_arena_set_allocated_friend_del_req(
      ::chat::DeleteFriendRequest* friend_del_req);
  ::chat::DeleteFriendRequest* unsafe_arena_release_friend_del_req();

  // .chat.DeleteFriendResponse friend_del_res = 11;
  bool has_friend_del_res() const;
  private:
  bool _internal_has_friend_del_res() const;
  public:
  void clear_friend_del_res();
  const ::chat::DeleteFriendResponse& friend_del_res() const;
  PROTOBUF_NODISCARD ::chat::DeleteFriendResponse* release_friend_del_res();
  ::chat::DeleteFriendResponse* mutable_friend_del_res();
  void set_allocated_friend_del_res(::chat::DeleteFriendResponse* friend_del_res);
  private:
  const ::chat::DeleteFriendResponse& _internal_friend_del_res() const;
  ::chat::DeleteFriendResponse* _internal_mutable_friend_del_res();
  public:
  void unsafe_arena_set_allocated_friend_del_res(
      ::chat::DeleteFriendResponse* friend_del_res);
  ::chat::DeleteFriendResponse* unsafe_arena_release_friend_del_res();

  // .chat.LoginResponse response = 12;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::chat::LoginResponse& response() const;
  PROTOBUF_NODISCARD ::chat::LoginResponse* release_response();
  ::chat::LoginResponse* mutable_response();
  void set_allocated_response(::chat::LoginResponse* response);
  private:
  const ::chat::LoginResponse& _internal_response() const;
  ::chat::LoginResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::chat::LoginResponse* response);
  ::chat::LoginResponse* unsafe_arena_release_response();

  // .chat.OfflineMSG off_msg = 13;
  bool has_off_msg() const;
  private:
  bool _internal_has_off_msg() const;
  public:
  void clear_off_msg();
  const ::chat::OfflineMSG& off_msg() const;
  PROTOBUF_NODISCARD ::chat::OfflineMSG* release_off_msg();
  ::chat::OfflineMSG* mutable_off_msg();
  void set_allocated_off_msg(::chat::OfflineMSG* off_msg);
  private:
  const ::chat::OfflineMSG& _internal_off_msg() const;
  ::chat::OfflineMSG* _internal_mutable_off_msg();
  public:
  void unsafe_arena_set_allocated_off_msg(
      ::chat::OfflineMSG* off_msg);
  ::chat::OfflineMSG* unsafe_arena_release_off_msg();

  // .chat.BlockFriend block_friend = 14;
  bool has_block_friend() const;
  private:
  bool _internal_has_block_friend() const;
  public:
  void clear_block_friend();
  const ::chat::BlockFriend& block_friend() const;
  PROTOBUF_NODISCARD ::chat::BlockFriend* release_block_friend();
  ::chat::BlockFriend* mutable_block_friend();
  void set_allocated_block_friend(::chat::BlockFriend* block_friend);
  private:
  const ::chat::BlockFriend& _internal_block_friend() const;
  ::chat::BlockFriend* _internal_mutable_block_friend();
  public:
  void unsafe_arena_set_allocated_block_friend(
      ::chat::BlockFriend* block_friend);
  ::chat::BlockFriend* unsafe_arena_release_block_friend();

  // .chat.SendFile send_file = 15;
  bool has_send_file() const;
  private:
  bool _internal_has_send_file() const;
  public:
  void clear_send_file();
  const ::chat::SendFile& send_file() const;
  PROTOBUF_NODISCARD ::chat::SendFile* release_send_file();
  ::chat::SendFile* mutable_send_file();
  void set_allocated_send_file(::chat::SendFile* send_file);
  private:
  const ::chat::SendFile& _internal_send_file() const;
  ::chat::SendFile* _internal_mutable_send_file();
  public:
  void unsafe_arena_set_allocated_send_file(
      ::chat::SendFile* send_file);
  ::chat::SendFile* unsafe_arena_release_send_file();

  // .chat.RecvFile recv_file = 16;
  bool has_recv_file() const;
  private:
  bool _internal_has_recv_file() const;
  public:
  void clear_recv_file();
  const ::chat::RecvFile& recv_file() const;
  PROTOBUF_NODISCARD ::chat::RecvFile* release_recv_file();
  ::chat::RecvFile* mutable_recv_file();
  void set_allocated_recv_file(::chat::RecvFile* recv_file);
  private:
  const ::chat::RecvFile& _internal_recv_file() const;
  ::chat::RecvFile* _internal_mutable_recv_file();
  public:
  void unsafe_arena_set_allocated_recv_file(
      ::chat::RecvFile* recv_file);
  ::chat::RecvFile* unsafe_arena_release_recv_file();

  // .chat.LookFileRequest file_req = 17;
  bool has_file_req() const;
  private:
  bool _internal_has_file_req() const;
  public:
  void clear_file_req();
  const ::chat::LookFileRequest& file_req() const;
  PROTOBUF_NODISCARD ::chat::LookFileRequest* release_file_req();
  ::chat::LookFileRequest* mutable_file_req();
  void set_allocated_file_req(::chat::LookFileRequest* file_req);
  private:
  const ::chat::LookFileRequest& _internal_file_req() const;
  ::chat::LookFileRequest* _internal_mutable_file_req();
  public:
  void unsafe_arena_set_allocated_file_req(
      ::chat::LookFileRequest* file_req);
  ::chat::LookFileRequest* unsafe_arena_release_file_req();

  // .chat.AddGroup add_group = 19;
  bool has_add_group() const;
  private:
  bool _internal_has_add_group() const;
  public:
  void clear_add_group();
  const ::chat::AddGroup& add_group() const;
  PROTOBUF_NODISCARD ::chat::AddGroup* release_add_group();
  ::chat::AddGroup* mutable_add_group();
  void set_allocated_add_group(::chat::AddGroup* add_group);
  private:
  const ::chat::AddGroup& _internal_add_group() const;
  ::chat::AddGroup* _internal_mutable_add_group();
  public:
  void unsafe_arena_set_allocated_add_group(
      ::chat::AddGroup* add_group);
  ::chat::AddGroup* unsafe_arena_release_add_group();

  // .chat.JoinGroup join_group = 20;
  bool has_join_group() const;
  private:
  bool _internal_has_join_group() const;
  public:
  void clear_join_group();
  const ::chat::JoinGroup& join_group() const;
  PROTOBUF_NODISCARD ::chat::JoinGroup* release_join_group();
  ::chat::JoinGroup* mutable_join_group();
  void set_allocated_join_group(::chat::JoinGroup* join_group);
  private:
  const ::chat::JoinGroup& _internal_join_group() const;
  ::chat::JoinGroup* _internal_mutable_join_group();
  public:
  void unsafe_arena_set_allocated_join_group(
      ::chat::JoinGroup* join_group);
  ::chat::JoinGroup* unsafe_arena_release_join_group();

  // .chat.JoinGroupResponse join_res = 21;
  bool has_join_res() const;
  private:
  bool _internal_has_join_res() const;
  public:
  void clear_join_res();
  const ::chat::JoinGroupResponse& join_res() const;
  PROTOBUF_NODISCARD ::chat::JoinGroupResponse* release_join_res();
  ::chat::JoinGroupResponse* mutable_join_res();
  void set_allocated_join_res(::chat::JoinGroupResponse* join_res);
  private:
  const ::chat::JoinGroupResponse& _internal_join_res() const;
  ::chat::JoinGroupResponse* _internal_mutable_join_res();
  public:
  void unsafe_arena_set_allocated_join_res(
      ::chat::JoinGroupResponse* join_res);
  ::chat::JoinGroupResponse* unsafe_arena_release_join_res();

  // .chat.GroupList group_list = 22;
  bool has_group_list() const;
  private:
  bool _internal_has_group_list() const;
  public:
  void clear_group_list();
  const ::chat::GroupList& group_list() const;
  PROTOBUF_NODISCARD ::chat::GroupList* release_group_list();
  ::chat::GroupList* mutable_group_list();
  void set_allocated_group_list(::chat::GroupList* group_list);
  private:
  const ::chat::GroupList& _internal_group_list() const;
  ::chat::GroupList* _internal_mutable_group_list();
  public:
  void unsafe_arena_set_allocated_group_list(
      ::chat::GroupList* group_list);
  ::chat::GroupList* unsafe_arena_release_group_list();

  // .chat.FindRequest group_notify = 23;
  bool has_group_notify() const;
  private:
  bool _internal_has_group_notify() const;
  public:
  void clear_group_notify();
  const ::chat::FindRequest& group_notify() const;
  PROTOBUF_NODISCARD ::chat::FindRequest* release_group_notify();
  ::chat::FindRequest* mutable_group_notify();
  void set_allocated_group_notify(::chat::FindRequest* group_notify);
  private:
  const ::chat::FindRequest& _internal_group_notify() const;
  ::chat::FindRequest* _internal_mutable_group_notify();
  public:
  void unsafe_arena_set_allocated_group_notify(
      ::chat::FindRequest* group_notify);
  ::chat::FindRequest* unsafe_arena_release_group_notify();

  // .chat.ChoiceGroup group_choice = 24;
  bool has_group_choice() const;
  private:
  bool _internal_has_group_choice() const;
  public:
  void clear_group_choice();
  const ::chat::ChoiceGroup& group_choice() const;
  PROTOBUF_NODISCARD ::chat::ChoiceGroup* release_group_choice();
  ::chat::ChoiceGroup* mutable_group_choice();
  void set_allocated_group_choice(::chat::ChoiceGroup* group_choice);
  private:
  const ::chat::ChoiceGroup& _internal_group_choice() const;
  ::chat::ChoiceGroup* _internal_mutable_group_choice();
  public:
  void unsafe_arena_set_allocated_group_choice(
      ::chat::ChoiceGroup* group_choice);
  ::chat::ChoiceGroup* unsafe_arena_release_group_choice();

  // .chat.GroupMembers group_members = 25;
  bool has_group_members() const;
  private:
  bool _internal_has_group_members() const;
  public:
  void clear_group_members();
  const ::chat::GroupMembers& group_members() const;
  PROTOBUF_NODISCARD ::chat::GroupMembers* release_group_members();
  ::chat::GroupMembers* mutable_group_members();
  void set_allocated_group_members(::chat::GroupMembers* group_members);
  private:
  const ::chat::GroupMembers& _internal_group_members() const;
  ::chat::GroupMembers* _internal_mutable_group_members();
  public:
  void unsafe_arena_set_allocated_group_members(
      ::chat::GroupMembers* group_members);
  ::chat::GroupMembers* unsafe_arena_release_group_members();

  // .chat.GroupChat group_chat = 26;
  bool has_group_chat() const;
  private:
  bool _internal_has_group_chat() const;
  public:
  void clear_group_chat();
  const ::chat::GroupChat& group_chat() const;
  PROTOBUF_NODISCARD ::chat::GroupChat* release_group_chat();
  ::chat::GroupChat* mutable_group_chat();
  void set_allocated_group_chat(::chat::GroupChat* group_chat);
  private:
  const ::chat::GroupChat& _internal_group_chat() const;
  ::chat::GroupChat* _internal_mutable_group_chat();
  public:
  void unsafe_arena_set_allocated_group_chat(
      ::chat::GroupChat* group_chat);
  ::chat::GroupChat* unsafe_arena_release_group_chat();

  // .chat.GroupChatList chat_list = 27;
  bool has_chat_list() const;
  private:
  bool _internal_has_chat_list() const;
  public:
  void clear_chat_list();
  const ::chat::GroupChatList& chat_list() const;
  PROTOBUF_NODISCARD ::chat::GroupChatList* release_chat_list();
  ::chat::GroupChatList* mutable_chat_list();
  void set_allocated_chat_list(::chat::GroupChatList* chat_list);
  private:
  const ::chat::GroupChatList& _internal_chat_list() const;
  ::chat::GroupChatList* _internal_mutable_chat_list();
  public:
  void unsafe_arena_set_allocated_chat_list(
      ::chat::GroupChatList* chat_list);
  ::chat::GroupChatList* unsafe_arena_release_chat_list();

  // .chat.LeaveGroup leave_group = 28;
  bool has_leave_group() const;
  private:
  bool _internal_has_leave_group() const;
  public:
  void clear_leave_group();
  const ::chat::LeaveGroup& leave_group() const;
  PROTOBUF_NODISCARD ::chat::LeaveGroup* release_leave_group();
  ::chat::LeaveGroup* mutable_leave_group();
  void set_allocated_leave_group(::chat::LeaveGroup* leave_group);
  private:
  const ::chat::LeaveGroup& _internal_leave_group() const;
  ::chat::LeaveGroup* _internal_mutable_leave_group();
  public:
  void unsafe_arena_set_allocated_leave_group(
      ::chat::LeaveGroup* leave_group);
  ::chat::LeaveGroup* unsafe_arena_release_leave_group();

  // .chat.AddMember add_member = 29;
  bool has_add_member() const;
  private:
  bool _internal_has_add_member() const;
  public:
  void clear_add_member();
  const ::chat::AddMember& add_member() const;
  PROTOBUF_NODISCARD ::chat::AddMember* release_add_member();
  ::chat::AddMember* mutable_add_member();
  void set_allocated_add_member(::chat::AddMember* add_member);
  private:
  const ::chat::AddMember& _internal_add_member() const;
  ::chat::AddMember* _internal_mutable_add_member();
  public:
  void unsafe_arena_set_allocated_add_member(
      ::chat::AddMember* add_member);
  ::chat::AddMember* unsafe_arena_release_add_member();

  // .chat.DelMember del_member = 30;
  bool has_del_member() const;
  private:
  bool _internal_has_del_member() const;
  public:
  void clear_del_member();
  const ::chat::DelMember& del_member() const;
  PROTOBUF_NODISCARD ::chat::DelMember* release_del_member();
  ::chat::DelMember* mutable_del_member();
  void set_allocated_del_member(::chat::DelMember* del_member);
  private:
  const ::chat::DelMember& _internal_del_member() const;
  ::chat::DelMember* _internal_mutable_del_member();
  public:
  void unsafe_arena_set_allocated_del_member(
      ::chat::DelMember* del_member);
  ::chat::DelMember* unsafe_arena_release_del_member();

  // .chat.AddMemberResponse add_member_res = 31;
  bool has_add_member_res() const;
  private:
  bool _internal_has_add_member_res() const;
  public:
  void clear_add_member_res();
  const ::chat::AddMemberResponse& add_member_res() const;
  PROTOBUF_NODISCARD ::chat::AddMemberResponse* release_add_member_res();
  ::chat::AddMemberResponse* mutable_add_member_res();
  void set_allocated_add_member_res(::chat::AddMemberResponse* add_member_res);
  private:
  const ::chat::AddMemberResponse& _internal_add_member_res() const;
  ::chat::AddMemberResponse* _internal_mutable_add_member_res();
  public:
  void unsafe_arena_set_allocated_add_member_res(
      ::chat::AddMemberResponse* add_member_res);
  ::chat::AddMemberResponse* unsafe_arena_release_add_member_res();

  // .chat.DelMemberResponse del_member_res = 32;
  bool has_del_member_res() const;
  private:
  bool _internal_has_del_member_res() const;
  public:
  void clear_del_member_res();
  const ::chat::DelMemberResponse& del_member_res() const;
  PROTOBUF_NODISCARD ::chat::DelMemberResponse* release_del_member_res();
  ::chat::DelMemberResponse* mutable_del_member_res();
  void set_allocated_del_member_res(::chat::DelMemberResponse* del_member_res);
  private:
  const ::chat::DelMemberResponse& _internal_del_member_res() const;
  ::chat::DelMemberResponse* _internal_mutable_del_member_res();
  public:
  void unsafe_arena_set_allocated_del_member_res(
      ::chat::DelMemberResponse* del_member_res);
  ::chat::DelMemberResponse* unsafe_arena_release_del_member_res();

  // .chat.DisbandGroup disband_group = 33;
  bool has_disband_group() const;
  private:
  bool _internal_has_disband_group() const;
  public:
  void clear_disband_group();
  const ::chat::DisbandGroup& disband_group() const;
  PROTOBUF_NODISCARD ::chat::DisbandGroup* release_disband_group();
  ::chat::DisbandGroup* mutable_disband_group();
  void set_allocated_disband_group(::chat::DisbandGroup* disband_group);
  private:
  const ::chat::DisbandGroup& _internal_disband_group() const;
  ::chat::DisbandGroup* _internal_mutable_disband_group();
  public:
  void unsafe_arena_set_allocated_disband_group(
      ::chat::DisbandGroup* disband_group);
  ::chat::DisbandGroup* unsafe_arena_release_disband_group();

  // .chat.AddManager add_manager = 34;
  bool has_add_manager() const;
  private:
  bool _internal_has_add_manager() const;
  public:
  void clear_add_manager();
  const ::chat::AddManager& add_manager() const;
  PROTOBUF_NODISCARD ::chat::AddManager* release_add_manager();
  ::chat::AddManager* mutable_add_manager();
  void set_allocated_add_manager(::chat::AddManager* add_manager);
  private:
  const ::chat::AddManager& _internal_add_manager() const;
  ::chat::AddManager* _internal_mutable_add_manager();
  public:
  void unsafe_arena_set_allocated_add_manager(
      ::chat::AddManager* add_manager);
  ::chat::AddManager* unsafe_arena_release_add_manager();

  // .chat.DelManager del_manager = 35;
  bool has_del_manager() const;
  private:
  bool _internal_has_del_manager() const;
  public:
  void clear_del_manager();
  const ::chat::DelManager& del_manager() const;
  PROTOBUF_NODISCARD ::chat::DelManager* release_del_manager();
  ::chat::DelManager* mutable_del_manager();
  void set_allocated_del_manager(::chat::DelManager* del_manager);
  private:
  const ::chat::DelManager& _internal_del_manager() const;
  ::chat::DelManager* _internal_mutable_del_manager();
  public:
  void unsafe_arena_set_allocated_del_manager(
      ::chat::DelManager* del_manager);
  ::chat::DelManager* unsafe_arena_release_del_manager();

  // .chat.RecvFileGroup recv_file_group = 36;
  bool has_recv_file_group() const;
  private:
  bool _internal_has_recv_file_group() const;
  public:
  void clear_recv_file_group();
  const ::chat::RecvFileGroup& recv_file_group() const;
  PROTOBUF_NODISCARD ::chat::RecvFileGroup* release_recv_file_group();
  ::chat::RecvFileGroup* mutable_recv_file_group();
  void set_allocated_recv_file_group(::chat::RecvFileGroup* recv_file_group);
  private:
  const ::chat::RecvFileGroup& _internal_recv_file_group() const;
  ::chat::RecvFileGroup* _internal_mutable_recv_file_group();
  public:
  void unsafe_arena_set_allocated_recv_file_group(
      ::chat::RecvFileGroup* recv_file_group);
  ::chat::RecvFileGroup* unsafe_arena_release_recv_file_group();

  // .chat.SendFileGroup send_file_group = 37;
  bool has_send_file_group() const;
  private:
  bool _internal_has_send_file_group() const;
  public:
  void clear_send_file_group();
  const ::chat::SendFileGroup& send_file_group() const;
  PROTOBUF_NODISCARD ::chat::SendFileGroup* release_send_file_group();
  ::chat::SendFileGroup* mutable_send_file_group();
  void set_allocated_send_file_group(::chat::SendFileGroup* send_file_group);
  private:
  const ::chat::SendFileGroup& _internal_send_file_group() const;
  ::chat::SendFileGroup* _internal_mutable_send_file_group();
  public:
  void unsafe_arena_set_allocated_send_file_group(
      ::chat::SendFileGroup* send_file_group);
  ::chat::SendFileGroup* unsafe_arena_release_send_file_group();

  // .chat.FileListGroup file_list_group = 38;
  bool has_file_list_group() const;
  private:
  bool _internal_has_file_list_group() const;
  public:
  void clear_file_list_group();
  const ::chat::FileListGroup& file_list_group() const;
  PROTOBUF_NODISCARD ::chat::FileListGroup* release_file_list_group();
  ::chat::FileListGroup* mutable_file_list_group();
  void set_allocated_file_list_group(::chat::FileListGroup* file_list_group);
  private:
  const ::chat::FileListGroup& _internal_file_list_group() const;
  ::chat::FileListGroup* _internal_mutable_file_list_group();
  public:
  void unsafe_arena_set_allocated_file_list_group(
      ::chat::FileListGroup* file_list_group);
  ::chat::FileListGroup* unsafe_arena_release_file_list_group();

  // .chat.LookFileRequestGroup look_fiele_req_group = 39;
  bool has_look_fiele_req_group() const;
  private:
  bool _internal_has_look_fiele_req_group() const;
  public:
  void clear_look_fiele_req_group();
  const ::chat::LookFileRequestGroup& look_fiele_req_group() const;
  PROTOBUF_NODISCARD ::chat::LookFileRequestGroup* release_look_fiele_req_group();
  ::chat::LookFileRequestGroup* mutable_look_fiele_req_group();
  void set_allocated_look_fiele_req_group(::chat::LookFileRequestGroup* look_fiele_req_group);
  private:
  const ::chat::LookFileRequestGroup& _internal_look_fiele_req_group() const;
  ::chat::LookFileRequestGroup* _internal_mutable_look_fiele_req_group();
  public:
  void unsafe_arena_set_allocated_look_fiele_req_group(
      ::chat::LookFileRequestGroup* look_fiele_req_group);
  ::chat::LookFileRequestGroup* unsafe_arena_release_look_fiele_req_group();

  // .chat.delAccount del_account = 40;
  bool has_del_account() const;
  private:
  bool _internal_has_del_account() const;
  public:
  void clear_del_account();
  const ::chat::delAccount& del_account() const;
  PROTOBUF_NODISCARD ::chat::delAccount* release_del_account();
  ::chat::delAccount* mutable_del_account();
  void set_allocated_del_account(::chat::delAccount* del_account);
  private:
  const ::chat::delAccount& _internal_del_account() const;
  ::chat::delAccount* _internal_mutable_del_account();
  public:
  void unsafe_arena_set_allocated_del_account(
      ::chat::delAccount* del_account);
  ::chat::delAccount* unsafe_arena_release_del_account();

  // .chat.Actions action = 1;
  void clear_action();
  ::chat::Actions action() const;
  void set_action(::chat::Actions value);
  private:
  ::chat::Actions _internal_action() const;
  void _internal_set_action(::chat::Actions value);
  public:

  // .chat.Group group = 18;
  void clear_group();
  ::chat::Group group() const;
  void set_group(::chat::Group value);
  private:
  ::chat::Group _internal_group() const;
  void _internal_set_group(::chat::Group value);
  public:

  // @@protoc_insertion_point(class_scope:chat.Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heart_;
    ::chat::FriendChatMessage* chat_fd_;
    ::chat::AddFriendRequest* friend_req_;
    ::chat::AddFriendResponse* friend_res_;
    ::chat::FriendLists* friends_;
    ::chat::UserRequest* req_;
    ::chat::Login* log_;
    ::chat::DeleteFriendRequest* friend_del_req_;
    ::chat::DeleteFriendResponse* friend_del_res_;
    ::chat::LoginResponse* response_;
    ::chat::OfflineMSG* off_msg_;
    ::chat::BlockFriend* block_friend_;
    ::chat::SendFile* send_file_;
    ::chat::RecvFile* recv_file_;
    ::chat::LookFileRequest* file_req_;
    ::chat::AddGroup* add_group_;
    ::chat::JoinGroup* join_group_;
    ::chat::JoinGroupResponse* join_res_;
    ::chat::GroupList* group_list_;
    ::chat::FindRequest* group_notify_;
    ::chat::ChoiceGroup* group_choice_;
    ::chat::GroupMembers* group_members_;
    ::chat::GroupChat* group_chat_;
    ::chat::GroupChatList* chat_list_;
    ::chat::LeaveGroup* leave_group_;
    ::chat::AddMember* add_member_;
    ::chat::DelMember* del_member_;
    ::chat::AddMemberResponse* add_member_res_;
    ::chat::DelMemberResponse* del_member_res_;
    ::chat::DisbandGroup* disband_group_;
    ::chat::AddManager* add_manager_;
    ::chat::DelManager* del_manager_;
    ::chat::RecvFileGroup* recv_file_group_;
    ::chat::SendFileGroup* send_file_group_;
    ::chat::FileListGroup* file_list_group_;
    ::chat::LookFileRequestGroup* look_fiele_req_group_;
    ::chat::delAccount* del_account_;
    int action_;
    int group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class delAccount_GroupNameEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<delAccount_GroupNameEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<delAccount_GroupNameEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  delAccount_GroupNameEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR delAccount_GroupNameEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit delAccount_GroupNameEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const delAccount_GroupNameEntry_DoNotUse& other);
  static const delAccount_GroupNameEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const delAccount_GroupNameEntry_DoNotUse*>(&_delAccount_GroupNameEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.delAccount.GroupNameEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.delAccount.GroupNameEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class delAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.delAccount) */ {
 public:
  inline delAccount() : delAccount(nullptr) {}
  ~delAccount() override;
  explicit PROTOBUF_CONSTEXPR delAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  delAccount(const delAccount& from);
  delAccount(delAccount&& from) noexcept
    : delAccount() {
    *this = ::std::move(from);
  }

  inline delAccount& operator=(const delAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline delAccount& operator=(delAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const delAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const delAccount* internal_default_instance() {
    return reinterpret_cast<const delAccount*>(
               &_delAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(delAccount& a, delAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(delAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(delAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  delAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<delAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const delAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const delAccount& from) {
    delAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(delAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.delAccount";
  }
  protected:
  explicit delAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kGroupNameFieldNumber = 2,
    kFriendsFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // map<string, string> group_name = 2;
  int group_name_size() const;
  private:
  int _internal_group_name_size() const;
  public:
  void clear_group_name();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_group_name() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_group_name();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      group_name() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_group_name();

  // repeated string friends = 4;
  int friends_size() const;
  private:
  int _internal_friends_size() const;
  public:
  void clear_friends();
  const std::string& friends(int index) const;
  std::string* mutable_friends(int index);
  void set_friends(int index, const std::string& value);
  void set_friends(int index, std::string&& value);
  void set_friends(int index, const char* value);
  void set_friends(int index, const char* value, size_t size);
  std::string* add_friends();
  void add_friends(const std::string& value);
  void add_friends(std::string&& value);
  void add_friends(const char* value);
  void add_friends(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& friends() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_friends();
  private:
  const std::string& _internal_friends(int index) const;
  std::string* _internal_add_friends();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.delAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        delAccount_GroupNameEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> group_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> friends_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class LookFileRequestGroup_ResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LookFileRequestGroup_ResultEntry_DoNotUse, 
    std::string, ::chat::FileListGroup,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LookFileRequestGroup_ResultEntry_DoNotUse, 
    std::string, ::chat::FileListGroup,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LookFileRequestGroup_ResultEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LookFileRequestGroup_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LookFileRequestGroup_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LookFileRequestGroup_ResultEntry_DoNotUse& other);
  static const LookFileRequestGroup_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LookFileRequestGroup_ResultEntry_DoNotUse*>(&_LookFileRequestGroup_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.LookFileRequestGroup.ResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class LookFileRequestGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.LookFileRequestGroup) */ {
 public:
  inline LookFileRequestGroup() : LookFileRequestGroup(nullptr) {}
  ~LookFileRequestGroup() override;
  explicit PROTOBUF_CONSTEXPR LookFileRequestGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookFileRequestGroup(const LookFileRequestGroup& from);
  LookFileRequestGroup(LookFileRequestGroup&& from) noexcept
    : LookFileRequestGroup() {
    *this = ::std::move(from);
  }

  inline LookFileRequestGroup& operator=(const LookFileRequestGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookFileRequestGroup& operator=(LookFileRequestGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookFileRequestGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookFileRequestGroup* internal_default_instance() {
    return reinterpret_cast<const LookFileRequestGroup*>(
               &_LookFileRequestGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LookFileRequestGroup& a, LookFileRequestGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(LookFileRequestGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookFileRequestGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookFileRequestGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookFileRequestGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookFileRequestGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookFileRequestGroup& from) {
    LookFileRequestGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookFileRequestGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.LookFileRequestGroup";
  }
  protected:
  explicit LookFileRequestGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kUsernameFieldNumber = 1,
    kUNameFieldNumber = 3,
    kGNameFieldNumber = 4,
  };
  // map<string, .chat.FileListGroup> result = 2;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >*
      mutable_result();

  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string u_name = 3;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 4;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.LookFileRequestGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LookFileRequestGroup_ResultEntry_DoNotUse,
        std::string, ::chat::FileListGroup,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class FileListGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.FileListGroup) */ {
 public:
  inline FileListGroup() : FileListGroup(nullptr) {}
  ~FileListGroup() override;
  explicit PROTOBUF_CONSTEXPR FileListGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileListGroup(const FileListGroup& from);
  FileListGroup(FileListGroup&& from) noexcept
    : FileListGroup() {
    *this = ::std::move(from);
  }

  inline FileListGroup& operator=(const FileListGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileListGroup& operator=(FileListGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileListGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileListGroup* internal_default_instance() {
    return reinterpret_cast<const FileListGroup*>(
               &_FileListGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FileListGroup& a, FileListGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(FileListGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileListGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileListGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileListGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileListGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileListGroup& from) {
    FileListGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileListGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.FileListGroup";
  }
  protected:
  explicit FileListGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
  };
  // repeated string files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // @@protoc_insertion_point(class_scope:chat.FileListGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class SendFileGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.SendFileGroup) */ {
 public:
  inline SendFileGroup() : SendFileGroup(nullptr) {}
  ~SendFileGroup() override;
  explicit PROTOBUF_CONSTEXPR SendFileGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendFileGroup(const SendFileGroup& from);
  SendFileGroup(SendFileGroup&& from) noexcept
    : SendFileGroup() {
    *this = ::std::move(from);
  }

  inline SendFileGroup& operator=(const SendFileGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendFileGroup& operator=(SendFileGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendFileGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendFileGroup* internal_default_instance() {
    return reinterpret_cast<const SendFileGroup*>(
               &_SendFileGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SendFileGroup& a, SendFileGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(SendFileGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendFileGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendFileGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendFileGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendFileGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendFileGroup& from) {
    SendFileGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendFileGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.SendFileGroup";
  }
  protected:
  explicit SendFileGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kTimeFieldNumber = 3,
    kGNameFieldNumber = 4,
    kNameFieldNumber = 5,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string file_name = 2;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string g_name = 4;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.SendFileGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class RecvFileGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.RecvFileGroup) */ {
 public:
  inline RecvFileGroup() : RecvFileGroup(nullptr) {}
  ~RecvFileGroup() override;
  explicit PROTOBUF_CONSTEXPR RecvFileGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecvFileGroup(const RecvFileGroup& from);
  RecvFileGroup(RecvFileGroup&& from) noexcept
    : RecvFileGroup() {
    *this = ::std::move(from);
  }

  inline RecvFileGroup& operator=(const RecvFileGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecvFileGroup& operator=(RecvFileGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecvFileGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecvFileGroup* internal_default_instance() {
    return reinterpret_cast<const RecvFileGroup*>(
               &_RecvFileGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RecvFileGroup& a, RecvFileGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(RecvFileGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecvFileGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecvFileGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecvFileGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecvFileGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecvFileGroup& from) {
    RecvFileGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecvFileGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.RecvFileGroup";
  }
  protected:
  explicit RecvFileGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kTimeFieldNumber = 3,
    kUNameFieldNumber = 4,
    kGNameFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string file_name = 2;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string u_name = 4;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 5;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.RecvFileGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class DelManager final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DelManager) */ {
 public:
  inline DelManager() : DelManager(nullptr) {}
  ~DelManager() override;
  explicit PROTOBUF_CONSTEXPR DelManager(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelManager(const DelManager& from);
  DelManager(DelManager&& from) noexcept
    : DelManager() {
    *this = ::std::move(from);
  }

  inline DelManager& operator=(const DelManager& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelManager& operator=(DelManager&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelManager& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelManager* internal_default_instance() {
    return reinterpret_cast<const DelManager*>(
               &_DelManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DelManager& a, DelManager& b) {
    a.Swap(&b);
  }
  inline void Swap(DelManager* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelManager* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelManager* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelManager>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelManager& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelManager& from) {
    DelManager::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelManager* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DelManager";
  }
  protected:
  explicit DelManager(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kMsgFieldNumber = 4,
    kDecideFieldNumber = 5,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string msg = 4;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool decide = 5;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.DelManager)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class AddManager final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.AddManager) */ {
 public:
  inline AddManager() : AddManager(nullptr) {}
  ~AddManager() override;
  explicit PROTOBUF_CONSTEXPR AddManager(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddManager(const AddManager& from);
  AddManager(AddManager&& from) noexcept
    : AddManager() {
    *this = ::std::move(from);
  }

  inline AddManager& operator=(const AddManager& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddManager& operator=(AddManager&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddManager& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddManager* internal_default_instance() {
    return reinterpret_cast<const AddManager*>(
               &_AddManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AddManager& a, AddManager& b) {
    a.Swap(&b);
  }
  inline void Swap(AddManager* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddManager* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddManager* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddManager>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddManager& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddManager& from) {
    AddManager::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddManager* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.AddManager";
  }
  protected:
  explicit AddManager(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kMsgFieldNumber = 4,
    kDecideFieldNumber = 5,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string msg = 4;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool decide = 5;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.AddManager)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class DisbandGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DisbandGroup) */ {
 public:
  inline DisbandGroup() : DisbandGroup(nullptr) {}
  ~DisbandGroup() override;
  explicit PROTOBUF_CONSTEXPR DisbandGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisbandGroup(const DisbandGroup& from);
  DisbandGroup(DisbandGroup&& from) noexcept
    : DisbandGroup() {
    *this = ::std::move(from);
  }

  inline DisbandGroup& operator=(const DisbandGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisbandGroup& operator=(DisbandGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisbandGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisbandGroup* internal_default_instance() {
    return reinterpret_cast<const DisbandGroup*>(
               &_DisbandGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DisbandGroup& a, DisbandGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(DisbandGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisbandGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisbandGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisbandGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisbandGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisbandGroup& from) {
    DisbandGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisbandGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DisbandGroup";
  }
  protected:
  explicit DisbandGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.DisbandGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class DelMemberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DelMemberResponse) */ {
 public:
  inline DelMemberResponse() : DelMemberResponse(nullptr) {}
  ~DelMemberResponse() override;
  explicit PROTOBUF_CONSTEXPR DelMemberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelMemberResponse(const DelMemberResponse& from);
  DelMemberResponse(DelMemberResponse&& from) noexcept
    : DelMemberResponse() {
    *this = ::std::move(from);
  }

  inline DelMemberResponse& operator=(const DelMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelMemberResponse& operator=(DelMemberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelMemberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelMemberResponse* internal_default_instance() {
    return reinterpret_cast<const DelMemberResponse*>(
               &_DelMemberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DelMemberResponse& a, DelMemberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DelMemberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelMemberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelMemberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelMemberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelMemberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelMemberResponse& from) {
    DelMemberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelMemberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DelMemberResponse";
  }
  protected:
  explicit DelMemberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kUNameFieldNumber = 2,
    kGNameFieldNumber = 3,
    kMsgFieldNumber = 5,
    kStatueFieldNumber = 6,
    kDecideFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string u_name = 2;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 3;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string msg = 5;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string statue = 6;
  void clear_statue();
  const std::string& statue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statue();
  PROTOBUF_NODISCARD std::string* release_statue();
  void set_allocated_statue(std::string* statue);
  private:
  const std::string& _internal_statue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statue(const std::string& value);
  std::string* _internal_mutable_statue();
  public:

  // bool decide = 4;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.DelMemberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statue_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class DelMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DelMember) */ {
 public:
  inline DelMember() : DelMember(nullptr) {}
  ~DelMember() override;
  explicit PROTOBUF_CONSTEXPR DelMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelMember(const DelMember& from);
  DelMember(DelMember&& from) noexcept
    : DelMember() {
    *this = ::std::move(from);
  }

  inline DelMember& operator=(const DelMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelMember& operator=(DelMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelMember* internal_default_instance() {
    return reinterpret_cast<const DelMember*>(
               &_DelMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DelMember& a, DelMember& b) {
    a.Swap(&b);
  }
  inline void Swap(DelMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelMember& from) {
    DelMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DelMember";
  }
  protected:
  explicit DelMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kUNameFieldNumber = 2,
    kGNameFieldNumber = 3,
    kMsgFieldNumber = 5,
    kStatueFieldNumber = 6,
    kDecideFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string u_name = 2;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 3;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string msg = 5;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string statue = 6;
  void clear_statue();
  const std::string& statue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statue();
  PROTOBUF_NODISCARD std::string* release_statue();
  void set_allocated_statue(std::string* statue);
  private:
  const std::string& _internal_statue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statue(const std::string& value);
  std::string* _internal_mutable_statue();
  public:

  // bool decide = 4;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.DelMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statue_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class AddMemberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.AddMemberResponse) */ {
 public:
  inline AddMemberResponse() : AddMemberResponse(nullptr) {}
  ~AddMemberResponse() override;
  explicit PROTOBUF_CONSTEXPR AddMemberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddMemberResponse(const AddMemberResponse& from);
  AddMemberResponse(AddMemberResponse&& from) noexcept
    : AddMemberResponse() {
    *this = ::std::move(from);
  }

  inline AddMemberResponse& operator=(const AddMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddMemberResponse& operator=(AddMemberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddMemberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddMemberResponse* internal_default_instance() {
    return reinterpret_cast<const AddMemberResponse*>(
               &_AddMemberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AddMemberResponse& a, AddMemberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddMemberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddMemberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddMemberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddMemberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddMemberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddMemberResponse& from) {
    AddMemberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddMemberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.AddMemberResponse";
  }
  protected:
  explicit AddMemberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kUNameFieldNumber = 2,
    kGNameFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string u_name = 2;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 3;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.AddMemberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class AddMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.AddMember) */ {
 public:
  inline AddMember() : AddMember(nullptr) {}
  ~AddMember() override;
  explicit PROTOBUF_CONSTEXPR AddMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddMember(const AddMember& from);
  AddMember(AddMember&& from) noexcept
    : AddMember() {
    *this = ::std::move(from);
  }

  inline AddMember& operator=(const AddMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddMember& operator=(AddMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddMember* internal_default_instance() {
    return reinterpret_cast<const AddMember*>(
               &_AddMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AddMember& a, AddMember& b) {
    a.Swap(&b);
  }
  inline void Swap(AddMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddMember& from) {
    AddMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.AddMember";
  }
  protected:
  explicit AddMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kUNameFieldNumber = 2,
    kGNameFieldNumber = 3,
    kMsgFieldNumber = 5,
    kDecideFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string u_name = 2;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 3;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string msg = 5;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool decide = 4;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.AddMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class LeaveGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.LeaveGroup) */ {
 public:
  inline LeaveGroup() : LeaveGroup(nullptr) {}
  ~LeaveGroup() override;
  explicit PROTOBUF_CONSTEXPR LeaveGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveGroup(const LeaveGroup& from);
  LeaveGroup(LeaveGroup&& from) noexcept
    : LeaveGroup() {
    *this = ::std::move(from);
  }

  inline LeaveGroup& operator=(const LeaveGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveGroup& operator=(LeaveGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveGroup* internal_default_instance() {
    return reinterpret_cast<const LeaveGroup*>(
               &_LeaveGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LeaveGroup& a, LeaveGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaveGroup& from) {
    LeaveGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.LeaveGroup";
  }
  protected:
  explicit LeaveGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
    kStatueFieldNumber = 4,
    kDecideFieldNumber = 3,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string statue = 4;
  void clear_statue();
  const std::string& statue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statue();
  PROTOBUF_NODISCARD std::string* release_statue();
  void set_allocated_statue(std::string* statue);
  private:
  const std::string& _internal_statue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statue(const std::string& value);
  std::string* _internal_mutable_statue();
  public:

  // bool decide = 3;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.LeaveGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statue_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class GroupChatList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.GroupChatList) */ {
 public:
  inline GroupChatList() : GroupChatList(nullptr) {}
  ~GroupChatList() override;
  explicit PROTOBUF_CONSTEXPR GroupChatList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupChatList(const GroupChatList& from);
  GroupChatList(GroupChatList&& from) noexcept
    : GroupChatList() {
    *this = ::std::move(from);
  }

  inline GroupChatList& operator=(const GroupChatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupChatList& operator=(GroupChatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupChatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupChatList* internal_default_instance() {
    return reinterpret_cast<const GroupChatList*>(
               &_GroupChatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GroupChatList& a, GroupChatList& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupChatList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupChatList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupChatList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupChatList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupChatList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupChatList& from) {
    GroupChatList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupChatList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.GroupChatList";
  }
  protected:
  explicit GroupChatList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kUNameFieldNumber = 2,
    kGNameFieldNumber = 3,
  };
  // repeated string msg = 1;
  int msg_size() const;
  private:
  int _internal_msg_size() const;
  public:
  void clear_msg();
  const std::string& msg(int index) const;
  std::string* mutable_msg(int index);
  void set_msg(int index, const std::string& value);
  void set_msg(int index, std::string&& value);
  void set_msg(int index, const char* value);
  void set_msg(int index, const char* value, size_t size);
  std::string* add_msg();
  void add_msg(const std::string& value);
  void add_msg(std::string&& value);
  void add_msg(const char* value);
  void add_msg(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& msg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_msg();
  private:
  const std::string& _internal_msg(int index) const;
  std::string* _internal_add_msg();
  public:

  // string u_name = 2;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 3;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.GroupChatList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class GroupChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.GroupChat) */ {
 public:
  inline GroupChat() : GroupChat(nullptr) {}
  ~GroupChat() override;
  explicit PROTOBUF_CONSTEXPR GroupChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupChat(const GroupChat& from);
  GroupChat(GroupChat&& from) noexcept
    : GroupChat() {
    *this = ::std::move(from);
  }

  inline GroupChat& operator=(const GroupChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupChat& operator=(GroupChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupChat* internal_default_instance() {
    return reinterpret_cast<const GroupChat*>(
               &_GroupChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GroupChat& a, GroupChat& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupChat& from) {
    GroupChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.GroupChat";
  }
  protected:
  explicit GroupChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kUNameFieldNumber = 3,
    kGNameFieldNumber = 4,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string u_name = 3;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 4;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.GroupChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class GroupMembers_MembersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GroupMembers_MembersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GroupMembers_MembersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GroupMembers_MembersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GroupMembers_MembersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GroupMembers_MembersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GroupMembers_MembersEntry_DoNotUse& other);
  static const GroupMembers_MembersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GroupMembers_MembersEntry_DoNotUse*>(&_GroupMembers_MembersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.GroupMembers.MembersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.GroupMembers.MembersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class GroupMembers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.GroupMembers) */ {
 public:
  inline GroupMembers() : GroupMembers(nullptr) {}
  ~GroupMembers() override;
  explicit PROTOBUF_CONSTEXPR GroupMembers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupMembers(const GroupMembers& from);
  GroupMembers(GroupMembers&& from) noexcept
    : GroupMembers() {
    *this = ::std::move(from);
  }

  inline GroupMembers& operator=(const GroupMembers& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupMembers& operator=(GroupMembers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupMembers& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupMembers* internal_default_instance() {
    return reinterpret_cast<const GroupMembers*>(
               &_GroupMembers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GroupMembers& a, GroupMembers& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupMembers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupMembers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupMembers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupMembers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupMembers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupMembers& from) {
    GroupMembers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupMembers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.GroupMembers";
  }
  protected:
  explicit GroupMembers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 3,
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
  };
  // map<string, string> members = 3;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_members() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_members();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      members() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_members();

  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.GroupMembers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GroupMembers_MembersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> members_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class ChoiceGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChoiceGroup) */ {
 public:
  inline ChoiceGroup() : ChoiceGroup(nullptr) {}
  ~ChoiceGroup() override;
  explicit PROTOBUF_CONSTEXPR ChoiceGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChoiceGroup(const ChoiceGroup& from);
  ChoiceGroup(ChoiceGroup&& from) noexcept
    : ChoiceGroup() {
    *this = ::std::move(from);
  }

  inline ChoiceGroup& operator=(const ChoiceGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoiceGroup& operator=(ChoiceGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoiceGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChoiceGroup* internal_default_instance() {
    return reinterpret_cast<const ChoiceGroup*>(
               &_ChoiceGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ChoiceGroup& a, ChoiceGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ChoiceGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoiceGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoiceGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChoiceGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChoiceGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChoiceGroup& from) {
    ChoiceGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChoiceGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChoiceGroup";
  }
  protected:
  explicit ChoiceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
    kStatueFieldNumber = 3,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string statue = 3;
  void clear_statue();
  const std::string& statue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statue();
  PROTOBUF_NODISCARD std::string* release_statue();
  void set_allocated_statue(std::string* statue);
  private:
  const std::string& _internal_statue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statue(const std::string& value);
  std::string* _internal_mutable_statue();
  public:

  // @@protoc_insertion_point(class_scope:chat.ChoiceGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class FindRequest_ResponseEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FindRequest_ResponseEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FindRequest_ResponseEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  FindRequest_ResponseEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FindRequest_ResponseEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FindRequest_ResponseEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FindRequest_ResponseEntry_DoNotUse& other);
  static const FindRequest_ResponseEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FindRequest_ResponseEntry_DoNotUse*>(&_FindRequest_ResponseEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.FindRequest.ResponseEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class FindRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.FindRequest) */ {
 public:
  inline FindRequest() : FindRequest(nullptr) {}
  ~FindRequest() override;
  explicit PROTOBUF_CONSTEXPR FindRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindRequest(const FindRequest& from);
  FindRequest(FindRequest&& from) noexcept
    : FindRequest() {
    *this = ::std::move(from);
  }

  inline FindRequest& operator=(const FindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindRequest& operator=(FindRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindRequest* internal_default_instance() {
    return reinterpret_cast<const FindRequest*>(
               &_FindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FindRequest& a, FindRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindRequest& from) {
    FindRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.FindRequest";
  }
  protected:
  explicit FindRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // map<string, bytes> response = 1;
  int response_size() const;
  private:
  int _internal_response_size() const;
  public:
  void clear_response();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_response() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_response();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      response() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_response();

  // @@protoc_insertion_point(class_scope:chat.FindRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FindRequest_ResponseEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class GroupList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.GroupList) */ {
 public:
  inline GroupList() : GroupList(nullptr) {}
  ~GroupList() override;
  explicit PROTOBUF_CONSTEXPR GroupList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupList(const GroupList& from);
  GroupList(GroupList&& from) noexcept
    : GroupList() {
    *this = ::std::move(from);
  }

  inline GroupList& operator=(const GroupList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupList& operator=(GroupList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupList* internal_default_instance() {
    return reinterpret_cast<const GroupList*>(
               &_GroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GroupList& a, GroupList& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupList& from) {
    GroupList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.GroupList";
  }
  protected:
  explicit GroupList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 3,
    kUsernameFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // repeated string groups = 3;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  const std::string& groups(int index) const;
  std::string* mutable_groups(int index);
  void set_groups(int index, const std::string& value);
  void set_groups(int index, std::string&& value);
  void set_groups(int index, const char* value);
  void set_groups(int index, const char* value, size_t size);
  std::string* add_groups();
  void add_groups(const std::string& value);
  void add_groups(std::string&& value);
  void add_groups(const char* value);
  void add_groups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups();
  private:
  const std::string& _internal_groups(int index) const;
  std::string* _internal_add_groups();
  public:

  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string time = 2;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // @@protoc_insertion_point(class_scope:chat.GroupList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class JoinGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.JoinGroup) */ {
 public:
  inline JoinGroup() : JoinGroup(nullptr) {}
  ~JoinGroup() override;
  explicit PROTOBUF_CONSTEXPR JoinGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGroup(const JoinGroup& from);
  JoinGroup(JoinGroup&& from) noexcept
    : JoinGroup() {
    *this = ::std::move(from);
  }

  inline JoinGroup& operator=(const JoinGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGroup& operator=(JoinGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGroup* internal_default_instance() {
    return reinterpret_cast<const JoinGroup*>(
               &_JoinGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(JoinGroup& a, JoinGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinGroup& from) {
    JoinGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.JoinGroup";
  }
  protected:
  explicit JoinGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kTimeFieldNumber = 5,
    kMsgFieldNumber = 6,
    kDecideFieldNumber = 4,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string time = 5;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string msg = 6;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool decide = 4;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.JoinGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class JoinGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.JoinGroupResponse) */ {
 public:
  inline JoinGroupResponse() : JoinGroupResponse(nullptr) {}
  ~JoinGroupResponse() override;
  explicit PROTOBUF_CONSTEXPR JoinGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGroupResponse(const JoinGroupResponse& from);
  JoinGroupResponse(JoinGroupResponse&& from) noexcept
    : JoinGroupResponse() {
    *this = ::std::move(from);
  }

  inline JoinGroupResponse& operator=(const JoinGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGroupResponse& operator=(JoinGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGroupResponse* internal_default_instance() {
    return reinterpret_cast<const JoinGroupResponse*>(
               &_JoinGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(JoinGroupResponse& a, JoinGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinGroupResponse& from) {
    JoinGroupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.JoinGroupResponse";
  }
  protected:
  explicit JoinGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUNameFieldNumber = 1,
    kGNameFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kTimeFieldNumber = 5,
    kMsgFieldNumber = 6,
    kDecideFieldNumber = 4,
  };
  // string u_name = 1;
  void clear_u_name();
  const std::string& u_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_name();
  PROTOBUF_NODISCARD std::string* release_u_name();
  void set_allocated_u_name(std::string* u_name);
  private:
  const std::string& _internal_u_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_name(const std::string& value);
  std::string* _internal_mutable_u_name();
  public:

  // string g_name = 2;
  void clear_g_name();
  const std::string& g_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_name();
  PROTOBUF_NODISCARD std::string* release_g_name();
  void set_allocated_g_name(std::string* g_name);
  private:
  const std::string& _internal_g_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_name(const std::string& value);
  std::string* _internal_mutable_g_name();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string time = 5;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string msg = 6;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool decide = 4;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.JoinGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class AddGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.AddGroup) */ {
 public:
  inline AddGroup() : AddGroup(nullptr) {}
  ~AddGroup() override;
  explicit PROTOBUF_CONSTEXPR AddGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddGroup(const AddGroup& from);
  AddGroup(AddGroup&& from) noexcept
    : AddGroup() {
    *this = ::std::move(from);
  }

  inline AddGroup& operator=(const AddGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddGroup& operator=(AddGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddGroup* internal_default_instance() {
    return reinterpret_cast<const AddGroup*>(
               &_AddGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AddGroup& a, AddGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(AddGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddGroup& from) {
    AddGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.AddGroup";
  }
  protected:
  explicit AddGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kGroupNameFieldNumber = 2,
    kTimeFieldNumber = 3,
    kMsgFieldNumber = 4,
    kSuccessFieldNumber = 5,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string group_name = 2;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string msg = 4;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 5;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.AddGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class LookFileRequest_ResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LookFileRequest_ResultEntry_DoNotUse, 
    std::string, ::chat::FileList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LookFileRequest_ResultEntry_DoNotUse, 
    std::string, ::chat::FileList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LookFileRequest_ResultEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LookFileRequest_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LookFileRequest_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LookFileRequest_ResultEntry_DoNotUse& other);
  static const LookFileRequest_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LookFileRequest_ResultEntry_DoNotUse*>(&_LookFileRequest_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.LookFileRequest.ResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class LookFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.LookFileRequest) */ {
 public:
  inline LookFileRequest() : LookFileRequest(nullptr) {}
  ~LookFileRequest() override;
  explicit PROTOBUF_CONSTEXPR LookFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookFileRequest(const LookFileRequest& from);
  LookFileRequest(LookFileRequest&& from) noexcept
    : LookFileRequest() {
    *this = ::std::move(from);
  }

  inline LookFileRequest& operator=(const LookFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookFileRequest& operator=(LookFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookFileRequest* internal_default_instance() {
    return reinterpret_cast<const LookFileRequest*>(
               &_LookFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(LookFileRequest& a, LookFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LookFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookFileRequest& from) {
    LookFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.LookFileRequest";
  }
  protected:
  explicit LookFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kUsernameFieldNumber = 1,
  };
  // map<string, .chat.FileList> result = 2;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >*
      mutable_result();

  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chat.LookFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LookFileRequest_ResultEntry_DoNotUse,
        std::string, ::chat::FileList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class FileList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.FileList) */ {
 public:
  inline FileList() : FileList(nullptr) {}
  ~FileList() override;
  explicit PROTOBUF_CONSTEXPR FileList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileList(const FileList& from);
  FileList(FileList&& from) noexcept
    : FileList() {
    *this = ::std::move(from);
  }

  inline FileList& operator=(const FileList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileList& operator=(FileList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileList* internal_default_instance() {
    return reinterpret_cast<const FileList*>(
               &_FileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(FileList& a, FileList& b) {
    a.Swap(&b);
  }
  inline void Swap(FileList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileList& from) {
    FileList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.FileList";
  }
  protected:
  explicit FileList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
  };
  // repeated string files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // @@protoc_insertion_point(class_scope:chat.FileList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class SendFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.SendFile) */ {
 public:
  inline SendFile() : SendFile(nullptr) {}
  ~SendFile() override;
  explicit PROTOBUF_CONSTEXPR SendFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendFile(const SendFile& from);
  SendFile(SendFile&& from) noexcept
    : SendFile() {
    *this = ::std::move(from);
  }

  inline SendFile& operator=(const SendFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendFile& operator=(SendFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendFile* internal_default_instance() {
    return reinterpret_cast<const SendFile*>(
               &_SendFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SendFile& a, SendFile& b) {
    a.Swap(&b);
  }
  inline void Swap(SendFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendFile& from) {
    SendFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.SendFile";
  }
  protected:
  explicit SendFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string file_name = 2;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // @@protoc_insertion_point(class_scope:chat.SendFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class RecvFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.RecvFile) */ {
 public:
  inline RecvFile() : RecvFile(nullptr) {}
  ~RecvFile() override;
  explicit PROTOBUF_CONSTEXPR RecvFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecvFile(const RecvFile& from);
  RecvFile(RecvFile&& from) noexcept
    : RecvFile() {
    *this = ::std::move(from);
  }

  inline RecvFile& operator=(const RecvFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecvFile& operator=(RecvFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecvFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecvFile* internal_default_instance() {
    return reinterpret_cast<const RecvFile*>(
               &_RecvFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RecvFile& a, RecvFile& b) {
    a.Swap(&b);
  }
  inline void Swap(RecvFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecvFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecvFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecvFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecvFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecvFile& from) {
    RecvFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecvFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.RecvFile";
  }
  protected:
  explicit RecvFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string file_name = 2;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // @@protoc_insertion_point(class_scope:chat.RecvFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class BlockFriend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.BlockFriend) */ {
 public:
  inline BlockFriend() : BlockFriend(nullptr) {}
  ~BlockFriend() override;
  explicit PROTOBUF_CONSTEXPR BlockFriend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockFriend(const BlockFriend& from);
  BlockFriend(BlockFriend&& from) noexcept
    : BlockFriend() {
    *this = ::std::move(from);
  }

  inline BlockFriend& operator=(const BlockFriend& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockFriend& operator=(BlockFriend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockFriend& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockFriend* internal_default_instance() {
    return reinterpret_cast<const BlockFriend*>(
               &_BlockFriend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(BlockFriend& a, BlockFriend& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockFriend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockFriend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockFriend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockFriend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockFriend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockFriend& from) {
    BlockFriend::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockFriend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.BlockFriend";
  }
  protected:
  explicit BlockFriend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.BlockFriend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class OfflineMSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.OfflineMSG) */ {
 public:
  inline OfflineMSG() : OfflineMSG(nullptr) {}
  ~OfflineMSG() override;
  explicit PROTOBUF_CONSTEXPR OfflineMSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfflineMSG(const OfflineMSG& from);
  OfflineMSG(OfflineMSG&& from) noexcept
    : OfflineMSG() {
    *this = ::std::move(from);
  }

  inline OfflineMSG& operator=(const OfflineMSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineMSG& operator=(OfflineMSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfflineMSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineMSG* internal_default_instance() {
    return reinterpret_cast<const OfflineMSG*>(
               &_OfflineMSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(OfflineMSG& a, OfflineMSG& b) {
    a.Swap(&b);
  }
  inline void Swap(OfflineMSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineMSG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfflineMSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfflineMSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfflineMSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OfflineMSG& from) {
    OfflineMSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.OfflineMSG";
  }
  protected:
  explicit OfflineMSG(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kNameFieldNumber = 2,
    kUsernameFieldNumber = 3,
  };
  // repeated string msg = 1;
  int msg_size() const;
  private:
  int _internal_msg_size() const;
  public:
  void clear_msg();
  const std::string& msg(int index) const;
  std::string* mutable_msg(int index);
  void set_msg(int index, const std::string& value);
  void set_msg(int index, std::string&& value);
  void set_msg(int index, const char* value);
  void set_msg(int index, const char* value, size_t size);
  std::string* add_msg();
  void add_msg(const std::string& value);
  void add_msg(std::string&& value);
  void add_msg(const char* value);
  void add_msg(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& msg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_msg();
  private:
  const std::string& _internal_msg(int index) const;
  std::string* _internal_add_msg();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chat.OfflineMSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class UserRequest_ResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UserRequest_ResultEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UserRequest_ResultEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UserRequest_ResultEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UserRequest_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UserRequest_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UserRequest_ResultEntry_DoNotUse& other);
  static const UserRequest_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UserRequest_ResultEntry_DoNotUse*>(&_UserRequest_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.UserRequest.ResultEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.UserRequest.ResultEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class UserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.UserRequest) */ {
 public:
  inline UserRequest() : UserRequest(nullptr) {}
  ~UserRequest() override;
  explicit PROTOBUF_CONSTEXPR UserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRequest(const UserRequest& from);
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRequest& from) {
    UserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.UserRequest";
  }
  protected:
  explicit UserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kUsernameFieldNumber = 1,
  };
  // map<string, string> result = 3;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_result();

  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chat.UserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UserRequest_ResultEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() override;
  explicit PROTOBUF_CONSTEXPR Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Login& from) {
    Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.Login";
  }
  protected:
  explicit Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kLoginFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bool login = 2;
  void clear_login();
  bool login() const;
  void set_login(bool value);
  private:
  bool _internal_login() const;
  void _internal_set_login(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    bool login_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse_ResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoginResponse_ResultEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoginResponse_ResultEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  LoginResponse_ResultEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LoginResponse_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoginResponse_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoginResponse_ResultEntry_DoNotUse& other);
  static const LoginResponse_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoginResponse_ResultEntry_DoNotUse*>(&_LoginResponse_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.LoginResponse.ResultEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.LoginResponse.ResultEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kUsernameFieldNumber = 1,
  };
  // map<string, string> result = 2;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_result();

  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chat.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoginResponse_ResultEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class DeleteFriendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DeleteFriendResponse) */ {
 public:
  inline DeleteFriendResponse() : DeleteFriendResponse(nullptr) {}
  ~DeleteFriendResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteFriendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFriendResponse(const DeleteFriendResponse& from);
  DeleteFriendResponse(DeleteFriendResponse&& from) noexcept
    : DeleteFriendResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFriendResponse& operator=(const DeleteFriendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFriendResponse& operator=(DeleteFriendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFriendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFriendResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFriendResponse*>(
               &_DeleteFriendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DeleteFriendResponse& a, DeleteFriendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFriendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFriendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFriendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFriendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFriendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFriendResponse& from) {
    DeleteFriendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFriendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DeleteFriendResponse";
  }
  protected:
  explicit DeleteFriendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.DeleteFriendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    bool result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class DeleteFriendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DeleteFriendRequest) */ {
 public:
  inline DeleteFriendRequest() : DeleteFriendRequest(nullptr) {}
  ~DeleteFriendRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFriendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFriendRequest(const DeleteFriendRequest& from);
  DeleteFriendRequest(DeleteFriendRequest&& from) noexcept
    : DeleteFriendRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFriendRequest& operator=(const DeleteFriendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFriendRequest& operator=(DeleteFriendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFriendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFriendRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFriendRequest*>(
               &_DeleteFriendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DeleteFriendRequest& a, DeleteFriendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFriendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFriendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFriendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFriendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFriendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFriendRequest& from) {
    DeleteFriendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFriendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DeleteFriendRequest";
  }
  protected:
  explicit DeleteFriendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromNameFieldNumber = 1,
    kToNameFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // string from_name = 1;
  void clear_from_name();
  const std::string& from_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_name();
  PROTOBUF_NODISCARD std::string* release_from_name();
  void set_allocated_from_name(std::string* from_name);
  private:
  const std::string& _internal_from_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_name(const std::string& value);
  std::string* _internal_mutable_from_name();
  public:

  // string to_name = 2;
  void clear_to_name();
  const std::string& to_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_name();
  PROTOBUF_NODISCARD std::string* release_to_name();
  void set_allocated_to_name(std::string* to_name);
  private:
  const std::string& _internal_to_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_name(const std::string& value);
  std::string* _internal_mutable_to_name();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // @@protoc_insertion_point(class_scope:chat.DeleteFriendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class AddFriendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.AddFriendRequest) */ {
 public:
  inline AddFriendRequest() : AddFriendRequest(nullptr) {}
  ~AddFriendRequest() override;
  explicit PROTOBUF_CONSTEXPR AddFriendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFriendRequest(const AddFriendRequest& from);
  AddFriendRequest(AddFriendRequest&& from) noexcept
    : AddFriendRequest() {
    *this = ::std::move(from);
  }

  inline AddFriendRequest& operator=(const AddFriendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFriendRequest& operator=(AddFriendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFriendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFriendRequest* internal_default_instance() {
    return reinterpret_cast<const AddFriendRequest*>(
               &_AddFriendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(AddFriendRequest& a, AddFriendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFriendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFriendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFriendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFriendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFriendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddFriendRequest& from) {
    AddFriendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.AddFriendRequest";
  }
  protected:
  explicit AddFriendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromUsernameFieldNumber = 1,
    kToUsernameFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // string from_username = 1;
  void clear_from_username();
  const std::string& from_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_username();
  PROTOBUF_NODISCARD std::string* release_from_username();
  void set_allocated_from_username(std::string* from_username);
  private:
  const std::string& _internal_from_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_username(const std::string& value);
  std::string* _internal_mutable_from_username();
  public:

  // string to_username = 2;
  void clear_to_username();
  const std::string& to_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_username();
  PROTOBUF_NODISCARD std::string* release_to_username();
  void set_allocated_to_username(std::string* to_username);
  private:
  const std::string& _internal_to_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_username(const std::string& value);
  std::string* _internal_mutable_to_username();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // @@protoc_insertion_point(class_scope:chat.AddFriendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class AddFriendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.AddFriendResponse) */ {
 public:
  inline AddFriendResponse() : AddFriendResponse(nullptr) {}
  ~AddFriendResponse() override;
  explicit PROTOBUF_CONSTEXPR AddFriendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFriendResponse(const AddFriendResponse& from);
  AddFriendResponse(AddFriendResponse&& from) noexcept
    : AddFriendResponse() {
    *this = ::std::move(from);
  }

  inline AddFriendResponse& operator=(const AddFriendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFriendResponse& operator=(AddFriendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFriendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFriendResponse* internal_default_instance() {
    return reinterpret_cast<const AddFriendResponse*>(
               &_AddFriendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(AddFriendResponse& a, AddFriendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFriendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFriendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFriendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFriendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFriendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddFriendResponse& from) {
    AddFriendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.AddFriendResponse";
  }
  protected:
  explicit AddFriendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromNameFieldNumber = 2,
    kToNameFieldNumber = 3,
    kMsgFieldNumber = 4,
    kTimeFieldNumber = 5,
    kDecideFieldNumber = 1,
  };
  // string from_name = 2;
  void clear_from_name();
  const std::string& from_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_name();
  PROTOBUF_NODISCARD std::string* release_from_name();
  void set_allocated_from_name(std::string* from_name);
  private:
  const std::string& _internal_from_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_name(const std::string& value);
  std::string* _internal_mutable_from_name();
  public:

  // string to_name = 3;
  void clear_to_name();
  const std::string& to_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_name();
  PROTOBUF_NODISCARD std::string* release_to_name();
  void set_allocated_to_name(std::string* to_name);
  private:
  const std::string& _internal_to_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_name(const std::string& value);
  std::string* _internal_mutable_to_name();
  public:

  // string msg = 4;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string time = 5;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // bool decide = 1;
  void clear_decide();
  bool decide() const;
  void set_decide(bool value);
  private:
  bool _internal_decide() const;
  void _internal_set_decide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.AddFriendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    bool decide_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class FriendLists_FriendsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FriendLists_FriendsEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FriendLists_FriendsEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  FriendLists_FriendsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FriendLists_FriendsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FriendLists_FriendsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FriendLists_FriendsEntry_DoNotUse& other);
  static const FriendLists_FriendsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FriendLists_FriendsEntry_DoNotUse*>(&_FriendLists_FriendsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "chat.FriendLists.FriendsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_user_5fchat_2eproto;
};

// -------------------------------------------------------------------

class FriendLists final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.FriendLists) */ {
 public:
  inline FriendLists() : FriendLists(nullptr) {}
  ~FriendLists() override;
  explicit PROTOBUF_CONSTEXPR FriendLists(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendLists(const FriendLists& from);
  FriendLists(FriendLists&& from) noexcept
    : FriendLists() {
    *this = ::std::move(from);
  }

  inline FriendLists& operator=(const FriendLists& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendLists& operator=(FriendLists&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendLists& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendLists* internal_default_instance() {
    return reinterpret_cast<const FriendLists*>(
               &_FriendLists_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(FriendLists& a, FriendLists& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendLists* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendLists* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendLists* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendLists>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendLists& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendLists& from) {
    FriendLists::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendLists* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.FriendLists";
  }
  protected:
  explicit FriendLists(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFriendsFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // map<string, bool> friends = 1;
  int friends_size() const;
  private:
  int _internal_friends_size() const;
  public:
  void clear_friends();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      _internal_friends() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      _internal_mutable_friends();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      friends() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      mutable_friends();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:chat.FriendLists)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FriendLists_FriendsEntry_DoNotUse,
        std::string, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> friends_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// -------------------------------------------------------------------

class FriendChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.FriendChatMessage) */ {
 public:
  inline FriendChatMessage() : FriendChatMessage(nullptr) {}
  ~FriendChatMessage() override;
  explicit PROTOBUF_CONSTEXPR FriendChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendChatMessage(const FriendChatMessage& from);
  FriendChatMessage(FriendChatMessage&& from) noexcept
    : FriendChatMessage() {
    *this = ::std::move(from);
  }

  inline FriendChatMessage& operator=(const FriendChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendChatMessage& operator=(FriendChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendChatMessage* internal_default_instance() {
    return reinterpret_cast<const FriendChatMessage*>(
               &_FriendChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(FriendChatMessage& a, FriendChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendChatMessage& from) {
    FriendChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.FriendChatMessage";
  }
  protected:
  explicit FriendChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromNameFieldNumber = 1,
    kToNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kTimeFieldNumber = 4,
    kBlockFieldNumber = 5,
  };
  // string from_name = 1;
  void clear_from_name();
  const std::string& from_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_name();
  PROTOBUF_NODISCARD std::string* release_from_name();
  void set_allocated_from_name(std::string* from_name);
  private:
  const std::string& _internal_from_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_name(const std::string& value);
  std::string* _internal_mutable_from_name();
  public:

  // string to_name = 2;
  void clear_to_name();
  const std::string& to_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_name();
  PROTOBUF_NODISCARD std::string* release_to_name();
  void set_allocated_to_name(std::string* to_name);
  private:
  const std::string& _internal_to_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_name(const std::string& value);
  std::string* _internal_mutable_to_name();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string time = 4;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // bool block = 5;
  void clear_block();
  bool block() const;
  void set_block(bool value);
  private:
  bool _internal_block() const;
  void _internal_set_block(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat.FriendChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    bool block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fchat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Chat

// .chat.Actions action = 1;
inline void Chat::clear_action() {
  _impl_.action_ = 0;
}
inline ::chat::Actions Chat::_internal_action() const {
  return static_cast< ::chat::Actions >(_impl_.action_);
}
inline ::chat::Actions Chat::action() const {
  // @@protoc_insertion_point(field_get:chat.Chat.action)
  return _internal_action();
}
inline void Chat::_internal_set_action(::chat::Actions value) {
  
  _impl_.action_ = value;
}
inline void Chat::set_action(::chat::Actions value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:chat.Chat.action)
}

// .chat.FriendChatMessage chat_fd = 2;
inline bool Chat::_internal_has_chat_fd() const {
  return this != internal_default_instance() && _impl_.chat_fd_ != nullptr;
}
inline bool Chat::has_chat_fd() const {
  return _internal_has_chat_fd();
}
inline void Chat::clear_chat_fd() {
  if (GetArenaForAllocation() == nullptr && _impl_.chat_fd_ != nullptr) {
    delete _impl_.chat_fd_;
  }
  _impl_.chat_fd_ = nullptr;
}
inline const ::chat::FriendChatMessage& Chat::_internal_chat_fd() const {
  const ::chat::FriendChatMessage* p = _impl_.chat_fd_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::FriendChatMessage&>(
      ::chat::_FriendChatMessage_default_instance_);
}
inline const ::chat::FriendChatMessage& Chat::chat_fd() const {
  // @@protoc_insertion_point(field_get:chat.Chat.chat_fd)
  return _internal_chat_fd();
}
inline void Chat::unsafe_arena_set_allocated_chat_fd(
    ::chat::FriendChatMessage* chat_fd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_fd_);
  }
  _impl_.chat_fd_ = chat_fd;
  if (chat_fd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.chat_fd)
}
inline ::chat::FriendChatMessage* Chat::release_chat_fd() {
  
  ::chat::FriendChatMessage* temp = _impl_.chat_fd_;
  _impl_.chat_fd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::FriendChatMessage* Chat::unsafe_arena_release_chat_fd() {
  // @@protoc_insertion_point(field_release:chat.Chat.chat_fd)
  
  ::chat::FriendChatMessage* temp = _impl_.chat_fd_;
  _impl_.chat_fd_ = nullptr;
  return temp;
}
inline ::chat::FriendChatMessage* Chat::_internal_mutable_chat_fd() {
  
  if (_impl_.chat_fd_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::FriendChatMessage>(GetArenaForAllocation());
    _impl_.chat_fd_ = p;
  }
  return _impl_.chat_fd_;
}
inline ::chat::FriendChatMessage* Chat::mutable_chat_fd() {
  ::chat::FriendChatMessage* _msg = _internal_mutable_chat_fd();
  // @@protoc_insertion_point(field_mutable:chat.Chat.chat_fd)
  return _msg;
}
inline void Chat::set_allocated_chat_fd(::chat::FriendChatMessage* chat_fd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_fd_;
  }
  if (chat_fd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat_fd);
    if (message_arena != submessage_arena) {
      chat_fd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat_fd, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chat_fd_ = chat_fd;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.chat_fd)
}

// .chat.AddFriendRequest friend_req = 4;
inline bool Chat::_internal_has_friend_req() const {
  return this != internal_default_instance() && _impl_.friend_req_ != nullptr;
}
inline bool Chat::has_friend_req() const {
  return _internal_has_friend_req();
}
inline void Chat::clear_friend_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.friend_req_ != nullptr) {
    delete _impl_.friend_req_;
  }
  _impl_.friend_req_ = nullptr;
}
inline const ::chat::AddFriendRequest& Chat::_internal_friend_req() const {
  const ::chat::AddFriendRequest* p = _impl_.friend_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::AddFriendRequest&>(
      ::chat::_AddFriendRequest_default_instance_);
}
inline const ::chat::AddFriendRequest& Chat::friend_req() const {
  // @@protoc_insertion_point(field_get:chat.Chat.friend_req)
  return _internal_friend_req();
}
inline void Chat::unsafe_arena_set_allocated_friend_req(
    ::chat::AddFriendRequest* friend_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_req_);
  }
  _impl_.friend_req_ = friend_req;
  if (friend_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.friend_req)
}
inline ::chat::AddFriendRequest* Chat::release_friend_req() {
  
  ::chat::AddFriendRequest* temp = _impl_.friend_req_;
  _impl_.friend_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::AddFriendRequest* Chat::unsafe_arena_release_friend_req() {
  // @@protoc_insertion_point(field_release:chat.Chat.friend_req)
  
  ::chat::AddFriendRequest* temp = _impl_.friend_req_;
  _impl_.friend_req_ = nullptr;
  return temp;
}
inline ::chat::AddFriendRequest* Chat::_internal_mutable_friend_req() {
  
  if (_impl_.friend_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::AddFriendRequest>(GetArenaForAllocation());
    _impl_.friend_req_ = p;
  }
  return _impl_.friend_req_;
}
inline ::chat::AddFriendRequest* Chat::mutable_friend_req() {
  ::chat::AddFriendRequest* _msg = _internal_mutable_friend_req();
  // @@protoc_insertion_point(field_mutable:chat.Chat.friend_req)
  return _msg;
}
inline void Chat::set_allocated_friend_req(::chat::AddFriendRequest* friend_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.friend_req_;
  }
  if (friend_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_req);
    if (message_arena != submessage_arena) {
      friend_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friend_req_ = friend_req;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.friend_req)
}

// .chat.AddFriendResponse friend_res = 5;
inline bool Chat::_internal_has_friend_res() const {
  return this != internal_default_instance() && _impl_.friend_res_ != nullptr;
}
inline bool Chat::has_friend_res() const {
  return _internal_has_friend_res();
}
inline void Chat::clear_friend_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.friend_res_ != nullptr) {
    delete _impl_.friend_res_;
  }
  _impl_.friend_res_ = nullptr;
}
inline const ::chat::AddFriendResponse& Chat::_internal_friend_res() const {
  const ::chat::AddFriendResponse* p = _impl_.friend_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::AddFriendResponse&>(
      ::chat::_AddFriendResponse_default_instance_);
}
inline const ::chat::AddFriendResponse& Chat::friend_res() const {
  // @@protoc_insertion_point(field_get:chat.Chat.friend_res)
  return _internal_friend_res();
}
inline void Chat::unsafe_arena_set_allocated_friend_res(
    ::chat::AddFriendResponse* friend_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_res_);
  }
  _impl_.friend_res_ = friend_res;
  if (friend_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.friend_res)
}
inline ::chat::AddFriendResponse* Chat::release_friend_res() {
  
  ::chat::AddFriendResponse* temp = _impl_.friend_res_;
  _impl_.friend_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::AddFriendResponse* Chat::unsafe_arena_release_friend_res() {
  // @@protoc_insertion_point(field_release:chat.Chat.friend_res)
  
  ::chat::AddFriendResponse* temp = _impl_.friend_res_;
  _impl_.friend_res_ = nullptr;
  return temp;
}
inline ::chat::AddFriendResponse* Chat::_internal_mutable_friend_res() {
  
  if (_impl_.friend_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::AddFriendResponse>(GetArenaForAllocation());
    _impl_.friend_res_ = p;
  }
  return _impl_.friend_res_;
}
inline ::chat::AddFriendResponse* Chat::mutable_friend_res() {
  ::chat::AddFriendResponse* _msg = _internal_mutable_friend_res();
  // @@protoc_insertion_point(field_mutable:chat.Chat.friend_res)
  return _msg;
}
inline void Chat::set_allocated_friend_res(::chat::AddFriendResponse* friend_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.friend_res_;
  }
  if (friend_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_res);
    if (message_arena != submessage_arena) {
      friend_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friend_res_ = friend_res;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.friend_res)
}

// .chat.FriendLists friends = 6;
inline bool Chat::_internal_has_friends() const {
  return this != internal_default_instance() && _impl_.friends_ != nullptr;
}
inline bool Chat::has_friends() const {
  return _internal_has_friends();
}
inline void Chat::clear_friends() {
  if (GetArenaForAllocation() == nullptr && _impl_.friends_ != nullptr) {
    delete _impl_.friends_;
  }
  _impl_.friends_ = nullptr;
}
inline const ::chat::FriendLists& Chat::_internal_friends() const {
  const ::chat::FriendLists* p = _impl_.friends_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::FriendLists&>(
      ::chat::_FriendLists_default_instance_);
}
inline const ::chat::FriendLists& Chat::friends() const {
  // @@protoc_insertion_point(field_get:chat.Chat.friends)
  return _internal_friends();
}
inline void Chat::unsafe_arena_set_allocated_friends(
    ::chat::FriendLists* friends) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friends_);
  }
  _impl_.friends_ = friends;
  if (friends) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.friends)
}
inline ::chat::FriendLists* Chat::release_friends() {
  
  ::chat::FriendLists* temp = _impl_.friends_;
  _impl_.friends_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::FriendLists* Chat::unsafe_arena_release_friends() {
  // @@protoc_insertion_point(field_release:chat.Chat.friends)
  
  ::chat::FriendLists* temp = _impl_.friends_;
  _impl_.friends_ = nullptr;
  return temp;
}
inline ::chat::FriendLists* Chat::_internal_mutable_friends() {
  
  if (_impl_.friends_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::FriendLists>(GetArenaForAllocation());
    _impl_.friends_ = p;
  }
  return _impl_.friends_;
}
inline ::chat::FriendLists* Chat::mutable_friends() {
  ::chat::FriendLists* _msg = _internal_mutable_friends();
  // @@protoc_insertion_point(field_mutable:chat.Chat.friends)
  return _msg;
}
inline void Chat::set_allocated_friends(::chat::FriendLists* friends) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.friends_;
  }
  if (friends) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friends);
    if (message_arena != submessage_arena) {
      friends = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friends, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friends_ = friends;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.friends)
}

// .chat.UserRequest req = 7;
inline bool Chat::_internal_has_req() const {
  return this != internal_default_instance() && _impl_.req_ != nullptr;
}
inline bool Chat::has_req() const {
  return _internal_has_req();
}
inline void Chat::clear_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.req_ != nullptr) {
    delete _impl_.req_;
  }
  _impl_.req_ = nullptr;
}
inline const ::chat::UserRequest& Chat::_internal_req() const {
  const ::chat::UserRequest* p = _impl_.req_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::UserRequest&>(
      ::chat::_UserRequest_default_instance_);
}
inline const ::chat::UserRequest& Chat::req() const {
  // @@protoc_insertion_point(field_get:chat.Chat.req)
  return _internal_req();
}
inline void Chat::unsafe_arena_set_allocated_req(
    ::chat::UserRequest* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.req_);
  }
  _impl_.req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.req)
}
inline ::chat::UserRequest* Chat::release_req() {
  
  ::chat::UserRequest* temp = _impl_.req_;
  _impl_.req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::UserRequest* Chat::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:chat.Chat.req)
  
  ::chat::UserRequest* temp = _impl_.req_;
  _impl_.req_ = nullptr;
  return temp;
}
inline ::chat::UserRequest* Chat::_internal_mutable_req() {
  
  if (_impl_.req_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::UserRequest>(GetArenaForAllocation());
    _impl_.req_ = p;
  }
  return _impl_.req_;
}
inline ::chat::UserRequest* Chat::mutable_req() {
  ::chat::UserRequest* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:chat.Chat.req)
  return _msg;
}
inline void Chat::set_allocated_req(::chat::UserRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.req_ = req;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.req)
}

// .chat.Login log = 8;
inline bool Chat::_internal_has_log() const {
  return this != internal_default_instance() && _impl_.log_ != nullptr;
}
inline bool Chat::has_log() const {
  return _internal_has_log();
}
inline void Chat::clear_log() {
  if (GetArenaForAllocation() == nullptr && _impl_.log_ != nullptr) {
    delete _impl_.log_;
  }
  _impl_.log_ = nullptr;
}
inline const ::chat::Login& Chat::_internal_log() const {
  const ::chat::Login* p = _impl_.log_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::Login&>(
      ::chat::_Login_default_instance_);
}
inline const ::chat::Login& Chat::log() const {
  // @@protoc_insertion_point(field_get:chat.Chat.log)
  return _internal_log();
}
inline void Chat::unsafe_arena_set_allocated_log(
    ::chat::Login* log) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.log_);
  }
  _impl_.log_ = log;
  if (log) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.log)
}
inline ::chat::Login* Chat::release_log() {
  
  ::chat::Login* temp = _impl_.log_;
  _impl_.log_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::Login* Chat::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_release:chat.Chat.log)
  
  ::chat::Login* temp = _impl_.log_;
  _impl_.log_ = nullptr;
  return temp;
}
inline ::chat::Login* Chat::_internal_mutable_log() {
  
  if (_impl_.log_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::Login>(GetArenaForAllocation());
    _impl_.log_ = p;
  }
  return _impl_.log_;
}
inline ::chat::Login* Chat::mutable_log() {
  ::chat::Login* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:chat.Chat.log)
  return _msg;
}
inline void Chat::set_allocated_log(::chat::Login* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.log_;
  }
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.log_ = log;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.log)
}

// .chat.DeleteFriendRequest friend_del_req = 10;
inline bool Chat::_internal_has_friend_del_req() const {
  return this != internal_default_instance() && _impl_.friend_del_req_ != nullptr;
}
inline bool Chat::has_friend_del_req() const {
  return _internal_has_friend_del_req();
}
inline void Chat::clear_friend_del_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.friend_del_req_ != nullptr) {
    delete _impl_.friend_del_req_;
  }
  _impl_.friend_del_req_ = nullptr;
}
inline const ::chat::DeleteFriendRequest& Chat::_internal_friend_del_req() const {
  const ::chat::DeleteFriendRequest* p = _impl_.friend_del_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::DeleteFriendRequest&>(
      ::chat::_DeleteFriendRequest_default_instance_);
}
inline const ::chat::DeleteFriendRequest& Chat::friend_del_req() const {
  // @@protoc_insertion_point(field_get:chat.Chat.friend_del_req)
  return _internal_friend_del_req();
}
inline void Chat::unsafe_arena_set_allocated_friend_del_req(
    ::chat::DeleteFriendRequest* friend_del_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_del_req_);
  }
  _impl_.friend_del_req_ = friend_del_req;
  if (friend_del_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.friend_del_req)
}
inline ::chat::DeleteFriendRequest* Chat::release_friend_del_req() {
  
  ::chat::DeleteFriendRequest* temp = _impl_.friend_del_req_;
  _impl_.friend_del_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::DeleteFriendRequest* Chat::unsafe_arena_release_friend_del_req() {
  // @@protoc_insertion_point(field_release:chat.Chat.friend_del_req)
  
  ::chat::DeleteFriendRequest* temp = _impl_.friend_del_req_;
  _impl_.friend_del_req_ = nullptr;
  return temp;
}
inline ::chat::DeleteFriendRequest* Chat::_internal_mutable_friend_del_req() {
  
  if (_impl_.friend_del_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DeleteFriendRequest>(GetArenaForAllocation());
    _impl_.friend_del_req_ = p;
  }
  return _impl_.friend_del_req_;
}
inline ::chat::DeleteFriendRequest* Chat::mutable_friend_del_req() {
  ::chat::DeleteFriendRequest* _msg = _internal_mutable_friend_del_req();
  // @@protoc_insertion_point(field_mutable:chat.Chat.friend_del_req)
  return _msg;
}
inline void Chat::set_allocated_friend_del_req(::chat::DeleteFriendRequest* friend_del_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.friend_del_req_;
  }
  if (friend_del_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_del_req);
    if (message_arena != submessage_arena) {
      friend_del_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_del_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friend_del_req_ = friend_del_req;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.friend_del_req)
}

// .chat.DeleteFriendResponse friend_del_res = 11;
inline bool Chat::_internal_has_friend_del_res() const {
  return this != internal_default_instance() && _impl_.friend_del_res_ != nullptr;
}
inline bool Chat::has_friend_del_res() const {
  return _internal_has_friend_del_res();
}
inline void Chat::clear_friend_del_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.friend_del_res_ != nullptr) {
    delete _impl_.friend_del_res_;
  }
  _impl_.friend_del_res_ = nullptr;
}
inline const ::chat::DeleteFriendResponse& Chat::_internal_friend_del_res() const {
  const ::chat::DeleteFriendResponse* p = _impl_.friend_del_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::DeleteFriendResponse&>(
      ::chat::_DeleteFriendResponse_default_instance_);
}
inline const ::chat::DeleteFriendResponse& Chat::friend_del_res() const {
  // @@protoc_insertion_point(field_get:chat.Chat.friend_del_res)
  return _internal_friend_del_res();
}
inline void Chat::unsafe_arena_set_allocated_friend_del_res(
    ::chat::DeleteFriendResponse* friend_del_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_del_res_);
  }
  _impl_.friend_del_res_ = friend_del_res;
  if (friend_del_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.friend_del_res)
}
inline ::chat::DeleteFriendResponse* Chat::release_friend_del_res() {
  
  ::chat::DeleteFriendResponse* temp = _impl_.friend_del_res_;
  _impl_.friend_del_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::DeleteFriendResponse* Chat::unsafe_arena_release_friend_del_res() {
  // @@protoc_insertion_point(field_release:chat.Chat.friend_del_res)
  
  ::chat::DeleteFriendResponse* temp = _impl_.friend_del_res_;
  _impl_.friend_del_res_ = nullptr;
  return temp;
}
inline ::chat::DeleteFriendResponse* Chat::_internal_mutable_friend_del_res() {
  
  if (_impl_.friend_del_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DeleteFriendResponse>(GetArenaForAllocation());
    _impl_.friend_del_res_ = p;
  }
  return _impl_.friend_del_res_;
}
inline ::chat::DeleteFriendResponse* Chat::mutable_friend_del_res() {
  ::chat::DeleteFriendResponse* _msg = _internal_mutable_friend_del_res();
  // @@protoc_insertion_point(field_mutable:chat.Chat.friend_del_res)
  return _msg;
}
inline void Chat::set_allocated_friend_del_res(::chat::DeleteFriendResponse* friend_del_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.friend_del_res_;
  }
  if (friend_del_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_del_res);
    if (message_arena != submessage_arena) {
      friend_del_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_del_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friend_del_res_ = friend_del_res;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.friend_del_res)
}

// .chat.LoginResponse response = 12;
inline bool Chat::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Chat::has_response() const {
  return _internal_has_response();
}
inline void Chat::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::chat::LoginResponse& Chat::_internal_response() const {
  const ::chat::LoginResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::LoginResponse&>(
      ::chat::_LoginResponse_default_instance_);
}
inline const ::chat::LoginResponse& Chat::response() const {
  // @@protoc_insertion_point(field_get:chat.Chat.response)
  return _internal_response();
}
inline void Chat::unsafe_arena_set_allocated_response(
    ::chat::LoginResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.response)
}
inline ::chat::LoginResponse* Chat::release_response() {
  
  ::chat::LoginResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::LoginResponse* Chat::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:chat.Chat.response)
  
  ::chat::LoginResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::chat::LoginResponse* Chat::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::LoginResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::chat::LoginResponse* Chat::mutable_response() {
  ::chat::LoginResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:chat.Chat.response)
  return _msg;
}
inline void Chat::set_allocated_response(::chat::LoginResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.response)
}

// .chat.OfflineMSG off_msg = 13;
inline bool Chat::_internal_has_off_msg() const {
  return this != internal_default_instance() && _impl_.off_msg_ != nullptr;
}
inline bool Chat::has_off_msg() const {
  return _internal_has_off_msg();
}
inline void Chat::clear_off_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.off_msg_ != nullptr) {
    delete _impl_.off_msg_;
  }
  _impl_.off_msg_ = nullptr;
}
inline const ::chat::OfflineMSG& Chat::_internal_off_msg() const {
  const ::chat::OfflineMSG* p = _impl_.off_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::OfflineMSG&>(
      ::chat::_OfflineMSG_default_instance_);
}
inline const ::chat::OfflineMSG& Chat::off_msg() const {
  // @@protoc_insertion_point(field_get:chat.Chat.off_msg)
  return _internal_off_msg();
}
inline void Chat::unsafe_arena_set_allocated_off_msg(
    ::chat::OfflineMSG* off_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.off_msg_);
  }
  _impl_.off_msg_ = off_msg;
  if (off_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.off_msg)
}
inline ::chat::OfflineMSG* Chat::release_off_msg() {
  
  ::chat::OfflineMSG* temp = _impl_.off_msg_;
  _impl_.off_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::OfflineMSG* Chat::unsafe_arena_release_off_msg() {
  // @@protoc_insertion_point(field_release:chat.Chat.off_msg)
  
  ::chat::OfflineMSG* temp = _impl_.off_msg_;
  _impl_.off_msg_ = nullptr;
  return temp;
}
inline ::chat::OfflineMSG* Chat::_internal_mutable_off_msg() {
  
  if (_impl_.off_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::OfflineMSG>(GetArenaForAllocation());
    _impl_.off_msg_ = p;
  }
  return _impl_.off_msg_;
}
inline ::chat::OfflineMSG* Chat::mutable_off_msg() {
  ::chat::OfflineMSG* _msg = _internal_mutable_off_msg();
  // @@protoc_insertion_point(field_mutable:chat.Chat.off_msg)
  return _msg;
}
inline void Chat::set_allocated_off_msg(::chat::OfflineMSG* off_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.off_msg_;
  }
  if (off_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(off_msg);
    if (message_arena != submessage_arena) {
      off_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, off_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.off_msg_ = off_msg;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.off_msg)
}

// .chat.BlockFriend block_friend = 14;
inline bool Chat::_internal_has_block_friend() const {
  return this != internal_default_instance() && _impl_.block_friend_ != nullptr;
}
inline bool Chat::has_block_friend() const {
  return _internal_has_block_friend();
}
inline void Chat::clear_block_friend() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_friend_ != nullptr) {
    delete _impl_.block_friend_;
  }
  _impl_.block_friend_ = nullptr;
}
inline const ::chat::BlockFriend& Chat::_internal_block_friend() const {
  const ::chat::BlockFriend* p = _impl_.block_friend_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::BlockFriend&>(
      ::chat::_BlockFriend_default_instance_);
}
inline const ::chat::BlockFriend& Chat::block_friend() const {
  // @@protoc_insertion_point(field_get:chat.Chat.block_friend)
  return _internal_block_friend();
}
inline void Chat::unsafe_arena_set_allocated_block_friend(
    ::chat::BlockFriend* block_friend) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_friend_);
  }
  _impl_.block_friend_ = block_friend;
  if (block_friend) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.block_friend)
}
inline ::chat::BlockFriend* Chat::release_block_friend() {
  
  ::chat::BlockFriend* temp = _impl_.block_friend_;
  _impl_.block_friend_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::BlockFriend* Chat::unsafe_arena_release_block_friend() {
  // @@protoc_insertion_point(field_release:chat.Chat.block_friend)
  
  ::chat::BlockFriend* temp = _impl_.block_friend_;
  _impl_.block_friend_ = nullptr;
  return temp;
}
inline ::chat::BlockFriend* Chat::_internal_mutable_block_friend() {
  
  if (_impl_.block_friend_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::BlockFriend>(GetArenaForAllocation());
    _impl_.block_friend_ = p;
  }
  return _impl_.block_friend_;
}
inline ::chat::BlockFriend* Chat::mutable_block_friend() {
  ::chat::BlockFriend* _msg = _internal_mutable_block_friend();
  // @@protoc_insertion_point(field_mutable:chat.Chat.block_friend)
  return _msg;
}
inline void Chat::set_allocated_block_friend(::chat::BlockFriend* block_friend) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_friend_;
  }
  if (block_friend) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_friend);
    if (message_arena != submessage_arena) {
      block_friend = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_friend, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_friend_ = block_friend;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.block_friend)
}

// .chat.SendFile send_file = 15;
inline bool Chat::_internal_has_send_file() const {
  return this != internal_default_instance() && _impl_.send_file_ != nullptr;
}
inline bool Chat::has_send_file() const {
  return _internal_has_send_file();
}
inline void Chat::clear_send_file() {
  if (GetArenaForAllocation() == nullptr && _impl_.send_file_ != nullptr) {
    delete _impl_.send_file_;
  }
  _impl_.send_file_ = nullptr;
}
inline const ::chat::SendFile& Chat::_internal_send_file() const {
  const ::chat::SendFile* p = _impl_.send_file_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::SendFile&>(
      ::chat::_SendFile_default_instance_);
}
inline const ::chat::SendFile& Chat::send_file() const {
  // @@protoc_insertion_point(field_get:chat.Chat.send_file)
  return _internal_send_file();
}
inline void Chat::unsafe_arena_set_allocated_send_file(
    ::chat::SendFile* send_file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.send_file_);
  }
  _impl_.send_file_ = send_file;
  if (send_file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.send_file)
}
inline ::chat::SendFile* Chat::release_send_file() {
  
  ::chat::SendFile* temp = _impl_.send_file_;
  _impl_.send_file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::SendFile* Chat::unsafe_arena_release_send_file() {
  // @@protoc_insertion_point(field_release:chat.Chat.send_file)
  
  ::chat::SendFile* temp = _impl_.send_file_;
  _impl_.send_file_ = nullptr;
  return temp;
}
inline ::chat::SendFile* Chat::_internal_mutable_send_file() {
  
  if (_impl_.send_file_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::SendFile>(GetArenaForAllocation());
    _impl_.send_file_ = p;
  }
  return _impl_.send_file_;
}
inline ::chat::SendFile* Chat::mutable_send_file() {
  ::chat::SendFile* _msg = _internal_mutable_send_file();
  // @@protoc_insertion_point(field_mutable:chat.Chat.send_file)
  return _msg;
}
inline void Chat::set_allocated_send_file(::chat::SendFile* send_file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.send_file_;
  }
  if (send_file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(send_file);
    if (message_arena != submessage_arena) {
      send_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_file, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.send_file_ = send_file;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.send_file)
}

// .chat.RecvFile recv_file = 16;
inline bool Chat::_internal_has_recv_file() const {
  return this != internal_default_instance() && _impl_.recv_file_ != nullptr;
}
inline bool Chat::has_recv_file() const {
  return _internal_has_recv_file();
}
inline void Chat::clear_recv_file() {
  if (GetArenaForAllocation() == nullptr && _impl_.recv_file_ != nullptr) {
    delete _impl_.recv_file_;
  }
  _impl_.recv_file_ = nullptr;
}
inline const ::chat::RecvFile& Chat::_internal_recv_file() const {
  const ::chat::RecvFile* p = _impl_.recv_file_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::RecvFile&>(
      ::chat::_RecvFile_default_instance_);
}
inline const ::chat::RecvFile& Chat::recv_file() const {
  // @@protoc_insertion_point(field_get:chat.Chat.recv_file)
  return _internal_recv_file();
}
inline void Chat::unsafe_arena_set_allocated_recv_file(
    ::chat::RecvFile* recv_file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recv_file_);
  }
  _impl_.recv_file_ = recv_file;
  if (recv_file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.recv_file)
}
inline ::chat::RecvFile* Chat::release_recv_file() {
  
  ::chat::RecvFile* temp = _impl_.recv_file_;
  _impl_.recv_file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::RecvFile* Chat::unsafe_arena_release_recv_file() {
  // @@protoc_insertion_point(field_release:chat.Chat.recv_file)
  
  ::chat::RecvFile* temp = _impl_.recv_file_;
  _impl_.recv_file_ = nullptr;
  return temp;
}
inline ::chat::RecvFile* Chat::_internal_mutable_recv_file() {
  
  if (_impl_.recv_file_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::RecvFile>(GetArenaForAllocation());
    _impl_.recv_file_ = p;
  }
  return _impl_.recv_file_;
}
inline ::chat::RecvFile* Chat::mutable_recv_file() {
  ::chat::RecvFile* _msg = _internal_mutable_recv_file();
  // @@protoc_insertion_point(field_mutable:chat.Chat.recv_file)
  return _msg;
}
inline void Chat::set_allocated_recv_file(::chat::RecvFile* recv_file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recv_file_;
  }
  if (recv_file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recv_file);
    if (message_arena != submessage_arena) {
      recv_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recv_file, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recv_file_ = recv_file;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.recv_file)
}

// .chat.LookFileRequest file_req = 17;
inline bool Chat::_internal_has_file_req() const {
  return this != internal_default_instance() && _impl_.file_req_ != nullptr;
}
inline bool Chat::has_file_req() const {
  return _internal_has_file_req();
}
inline void Chat::clear_file_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.file_req_ != nullptr) {
    delete _impl_.file_req_;
  }
  _impl_.file_req_ = nullptr;
}
inline const ::chat::LookFileRequest& Chat::_internal_file_req() const {
  const ::chat::LookFileRequest* p = _impl_.file_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::LookFileRequest&>(
      ::chat::_LookFileRequest_default_instance_);
}
inline const ::chat::LookFileRequest& Chat::file_req() const {
  // @@protoc_insertion_point(field_get:chat.Chat.file_req)
  return _internal_file_req();
}
inline void Chat::unsafe_arena_set_allocated_file_req(
    ::chat::LookFileRequest* file_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_req_);
  }
  _impl_.file_req_ = file_req;
  if (file_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.file_req)
}
inline ::chat::LookFileRequest* Chat::release_file_req() {
  
  ::chat::LookFileRequest* temp = _impl_.file_req_;
  _impl_.file_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::LookFileRequest* Chat::unsafe_arena_release_file_req() {
  // @@protoc_insertion_point(field_release:chat.Chat.file_req)
  
  ::chat::LookFileRequest* temp = _impl_.file_req_;
  _impl_.file_req_ = nullptr;
  return temp;
}
inline ::chat::LookFileRequest* Chat::_internal_mutable_file_req() {
  
  if (_impl_.file_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::LookFileRequest>(GetArenaForAllocation());
    _impl_.file_req_ = p;
  }
  return _impl_.file_req_;
}
inline ::chat::LookFileRequest* Chat::mutable_file_req() {
  ::chat::LookFileRequest* _msg = _internal_mutable_file_req();
  // @@protoc_insertion_point(field_mutable:chat.Chat.file_req)
  return _msg;
}
inline void Chat::set_allocated_file_req(::chat::LookFileRequest* file_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_req_;
  }
  if (file_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_req);
    if (message_arena != submessage_arena) {
      file_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.file_req_ = file_req;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.file_req)
}

// .chat.Group group = 18;
inline void Chat::clear_group() {
  _impl_.group_ = 0;
}
inline ::chat::Group Chat::_internal_group() const {
  return static_cast< ::chat::Group >(_impl_.group_);
}
inline ::chat::Group Chat::group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.group)
  return _internal_group();
}
inline void Chat::_internal_set_group(::chat::Group value) {
  
  _impl_.group_ = value;
}
inline void Chat::set_group(::chat::Group value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:chat.Chat.group)
}

// .chat.AddGroup add_group = 19;
inline bool Chat::_internal_has_add_group() const {
  return this != internal_default_instance() && _impl_.add_group_ != nullptr;
}
inline bool Chat::has_add_group() const {
  return _internal_has_add_group();
}
inline void Chat::clear_add_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.add_group_ != nullptr) {
    delete _impl_.add_group_;
  }
  _impl_.add_group_ = nullptr;
}
inline const ::chat::AddGroup& Chat::_internal_add_group() const {
  const ::chat::AddGroup* p = _impl_.add_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::AddGroup&>(
      ::chat::_AddGroup_default_instance_);
}
inline const ::chat::AddGroup& Chat::add_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.add_group)
  return _internal_add_group();
}
inline void Chat::unsafe_arena_set_allocated_add_group(
    ::chat::AddGroup* add_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.add_group_);
  }
  _impl_.add_group_ = add_group;
  if (add_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.add_group)
}
inline ::chat::AddGroup* Chat::release_add_group() {
  
  ::chat::AddGroup* temp = _impl_.add_group_;
  _impl_.add_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::AddGroup* Chat::unsafe_arena_release_add_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.add_group)
  
  ::chat::AddGroup* temp = _impl_.add_group_;
  _impl_.add_group_ = nullptr;
  return temp;
}
inline ::chat::AddGroup* Chat::_internal_mutable_add_group() {
  
  if (_impl_.add_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::AddGroup>(GetArenaForAllocation());
    _impl_.add_group_ = p;
  }
  return _impl_.add_group_;
}
inline ::chat::AddGroup* Chat::mutable_add_group() {
  ::chat::AddGroup* _msg = _internal_mutable_add_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.add_group)
  return _msg;
}
inline void Chat::set_allocated_add_group(::chat::AddGroup* add_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.add_group_;
  }
  if (add_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_group);
    if (message_arena != submessage_arena) {
      add_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.add_group_ = add_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.add_group)
}

// .chat.JoinGroup join_group = 20;
inline bool Chat::_internal_has_join_group() const {
  return this != internal_default_instance() && _impl_.join_group_ != nullptr;
}
inline bool Chat::has_join_group() const {
  return _internal_has_join_group();
}
inline void Chat::clear_join_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.join_group_ != nullptr) {
    delete _impl_.join_group_;
  }
  _impl_.join_group_ = nullptr;
}
inline const ::chat::JoinGroup& Chat::_internal_join_group() const {
  const ::chat::JoinGroup* p = _impl_.join_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::JoinGroup&>(
      ::chat::_JoinGroup_default_instance_);
}
inline const ::chat::JoinGroup& Chat::join_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.join_group)
  return _internal_join_group();
}
inline void Chat::unsafe_arena_set_allocated_join_group(
    ::chat::JoinGroup* join_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.join_group_);
  }
  _impl_.join_group_ = join_group;
  if (join_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.join_group)
}
inline ::chat::JoinGroup* Chat::release_join_group() {
  
  ::chat::JoinGroup* temp = _impl_.join_group_;
  _impl_.join_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::JoinGroup* Chat::unsafe_arena_release_join_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.join_group)
  
  ::chat::JoinGroup* temp = _impl_.join_group_;
  _impl_.join_group_ = nullptr;
  return temp;
}
inline ::chat::JoinGroup* Chat::_internal_mutable_join_group() {
  
  if (_impl_.join_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::JoinGroup>(GetArenaForAllocation());
    _impl_.join_group_ = p;
  }
  return _impl_.join_group_;
}
inline ::chat::JoinGroup* Chat::mutable_join_group() {
  ::chat::JoinGroup* _msg = _internal_mutable_join_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.join_group)
  return _msg;
}
inline void Chat::set_allocated_join_group(::chat::JoinGroup* join_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.join_group_;
  }
  if (join_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join_group);
    if (message_arena != submessage_arena) {
      join_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.join_group_ = join_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.join_group)
}

// .chat.JoinGroupResponse join_res = 21;
inline bool Chat::_internal_has_join_res() const {
  return this != internal_default_instance() && _impl_.join_res_ != nullptr;
}
inline bool Chat::has_join_res() const {
  return _internal_has_join_res();
}
inline void Chat::clear_join_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.join_res_ != nullptr) {
    delete _impl_.join_res_;
  }
  _impl_.join_res_ = nullptr;
}
inline const ::chat::JoinGroupResponse& Chat::_internal_join_res() const {
  const ::chat::JoinGroupResponse* p = _impl_.join_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::JoinGroupResponse&>(
      ::chat::_JoinGroupResponse_default_instance_);
}
inline const ::chat::JoinGroupResponse& Chat::join_res() const {
  // @@protoc_insertion_point(field_get:chat.Chat.join_res)
  return _internal_join_res();
}
inline void Chat::unsafe_arena_set_allocated_join_res(
    ::chat::JoinGroupResponse* join_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.join_res_);
  }
  _impl_.join_res_ = join_res;
  if (join_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.join_res)
}
inline ::chat::JoinGroupResponse* Chat::release_join_res() {
  
  ::chat::JoinGroupResponse* temp = _impl_.join_res_;
  _impl_.join_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::JoinGroupResponse* Chat::unsafe_arena_release_join_res() {
  // @@protoc_insertion_point(field_release:chat.Chat.join_res)
  
  ::chat::JoinGroupResponse* temp = _impl_.join_res_;
  _impl_.join_res_ = nullptr;
  return temp;
}
inline ::chat::JoinGroupResponse* Chat::_internal_mutable_join_res() {
  
  if (_impl_.join_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::JoinGroupResponse>(GetArenaForAllocation());
    _impl_.join_res_ = p;
  }
  return _impl_.join_res_;
}
inline ::chat::JoinGroupResponse* Chat::mutable_join_res() {
  ::chat::JoinGroupResponse* _msg = _internal_mutable_join_res();
  // @@protoc_insertion_point(field_mutable:chat.Chat.join_res)
  return _msg;
}
inline void Chat::set_allocated_join_res(::chat::JoinGroupResponse* join_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.join_res_;
  }
  if (join_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join_res);
    if (message_arena != submessage_arena) {
      join_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.join_res_ = join_res;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.join_res)
}

// .chat.GroupList group_list = 22;
inline bool Chat::_internal_has_group_list() const {
  return this != internal_default_instance() && _impl_.group_list_ != nullptr;
}
inline bool Chat::has_group_list() const {
  return _internal_has_group_list();
}
inline void Chat::clear_group_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_list_ != nullptr) {
    delete _impl_.group_list_;
  }
  _impl_.group_list_ = nullptr;
}
inline const ::chat::GroupList& Chat::_internal_group_list() const {
  const ::chat::GroupList* p = _impl_.group_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::GroupList&>(
      ::chat::_GroupList_default_instance_);
}
inline const ::chat::GroupList& Chat::group_list() const {
  // @@protoc_insertion_point(field_get:chat.Chat.group_list)
  return _internal_group_list();
}
inline void Chat::unsafe_arena_set_allocated_group_list(
    ::chat::GroupList* group_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_list_);
  }
  _impl_.group_list_ = group_list;
  if (group_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.group_list)
}
inline ::chat::GroupList* Chat::release_group_list() {
  
  ::chat::GroupList* temp = _impl_.group_list_;
  _impl_.group_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::GroupList* Chat::unsafe_arena_release_group_list() {
  // @@protoc_insertion_point(field_release:chat.Chat.group_list)
  
  ::chat::GroupList* temp = _impl_.group_list_;
  _impl_.group_list_ = nullptr;
  return temp;
}
inline ::chat::GroupList* Chat::_internal_mutable_group_list() {
  
  if (_impl_.group_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::GroupList>(GetArenaForAllocation());
    _impl_.group_list_ = p;
  }
  return _impl_.group_list_;
}
inline ::chat::GroupList* Chat::mutable_group_list() {
  ::chat::GroupList* _msg = _internal_mutable_group_list();
  // @@protoc_insertion_point(field_mutable:chat.Chat.group_list)
  return _msg;
}
inline void Chat::set_allocated_group_list(::chat::GroupList* group_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_list_;
  }
  if (group_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_list);
    if (message_arena != submessage_arena) {
      group_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_list_ = group_list;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.group_list)
}

// .chat.FindRequest group_notify = 23;
inline bool Chat::_internal_has_group_notify() const {
  return this != internal_default_instance() && _impl_.group_notify_ != nullptr;
}
inline bool Chat::has_group_notify() const {
  return _internal_has_group_notify();
}
inline void Chat::clear_group_notify() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_notify_ != nullptr) {
    delete _impl_.group_notify_;
  }
  _impl_.group_notify_ = nullptr;
}
inline const ::chat::FindRequest& Chat::_internal_group_notify() const {
  const ::chat::FindRequest* p = _impl_.group_notify_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::FindRequest&>(
      ::chat::_FindRequest_default_instance_);
}
inline const ::chat::FindRequest& Chat::group_notify() const {
  // @@protoc_insertion_point(field_get:chat.Chat.group_notify)
  return _internal_group_notify();
}
inline void Chat::unsafe_arena_set_allocated_group_notify(
    ::chat::FindRequest* group_notify) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_notify_);
  }
  _impl_.group_notify_ = group_notify;
  if (group_notify) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.group_notify)
}
inline ::chat::FindRequest* Chat::release_group_notify() {
  
  ::chat::FindRequest* temp = _impl_.group_notify_;
  _impl_.group_notify_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::FindRequest* Chat::unsafe_arena_release_group_notify() {
  // @@protoc_insertion_point(field_release:chat.Chat.group_notify)
  
  ::chat::FindRequest* temp = _impl_.group_notify_;
  _impl_.group_notify_ = nullptr;
  return temp;
}
inline ::chat::FindRequest* Chat::_internal_mutable_group_notify() {
  
  if (_impl_.group_notify_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::FindRequest>(GetArenaForAllocation());
    _impl_.group_notify_ = p;
  }
  return _impl_.group_notify_;
}
inline ::chat::FindRequest* Chat::mutable_group_notify() {
  ::chat::FindRequest* _msg = _internal_mutable_group_notify();
  // @@protoc_insertion_point(field_mutable:chat.Chat.group_notify)
  return _msg;
}
inline void Chat::set_allocated_group_notify(::chat::FindRequest* group_notify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_notify_;
  }
  if (group_notify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_notify);
    if (message_arena != submessage_arena) {
      group_notify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_notify, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_notify_ = group_notify;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.group_notify)
}

// .chat.ChoiceGroup group_choice = 24;
inline bool Chat::_internal_has_group_choice() const {
  return this != internal_default_instance() && _impl_.group_choice_ != nullptr;
}
inline bool Chat::has_group_choice() const {
  return _internal_has_group_choice();
}
inline void Chat::clear_group_choice() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_choice_ != nullptr) {
    delete _impl_.group_choice_;
  }
  _impl_.group_choice_ = nullptr;
}
inline const ::chat::ChoiceGroup& Chat::_internal_group_choice() const {
  const ::chat::ChoiceGroup* p = _impl_.group_choice_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::ChoiceGroup&>(
      ::chat::_ChoiceGroup_default_instance_);
}
inline const ::chat::ChoiceGroup& Chat::group_choice() const {
  // @@protoc_insertion_point(field_get:chat.Chat.group_choice)
  return _internal_group_choice();
}
inline void Chat::unsafe_arena_set_allocated_group_choice(
    ::chat::ChoiceGroup* group_choice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_choice_);
  }
  _impl_.group_choice_ = group_choice;
  if (group_choice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.group_choice)
}
inline ::chat::ChoiceGroup* Chat::release_group_choice() {
  
  ::chat::ChoiceGroup* temp = _impl_.group_choice_;
  _impl_.group_choice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::ChoiceGroup* Chat::unsafe_arena_release_group_choice() {
  // @@protoc_insertion_point(field_release:chat.Chat.group_choice)
  
  ::chat::ChoiceGroup* temp = _impl_.group_choice_;
  _impl_.group_choice_ = nullptr;
  return temp;
}
inline ::chat::ChoiceGroup* Chat::_internal_mutable_group_choice() {
  
  if (_impl_.group_choice_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ChoiceGroup>(GetArenaForAllocation());
    _impl_.group_choice_ = p;
  }
  return _impl_.group_choice_;
}
inline ::chat::ChoiceGroup* Chat::mutable_group_choice() {
  ::chat::ChoiceGroup* _msg = _internal_mutable_group_choice();
  // @@protoc_insertion_point(field_mutable:chat.Chat.group_choice)
  return _msg;
}
inline void Chat::set_allocated_group_choice(::chat::ChoiceGroup* group_choice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_choice_;
  }
  if (group_choice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_choice);
    if (message_arena != submessage_arena) {
      group_choice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_choice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_choice_ = group_choice;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.group_choice)
}

// .chat.GroupMembers group_members = 25;
inline bool Chat::_internal_has_group_members() const {
  return this != internal_default_instance() && _impl_.group_members_ != nullptr;
}
inline bool Chat::has_group_members() const {
  return _internal_has_group_members();
}
inline void Chat::clear_group_members() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_members_ != nullptr) {
    delete _impl_.group_members_;
  }
  _impl_.group_members_ = nullptr;
}
inline const ::chat::GroupMembers& Chat::_internal_group_members() const {
  const ::chat::GroupMembers* p = _impl_.group_members_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::GroupMembers&>(
      ::chat::_GroupMembers_default_instance_);
}
inline const ::chat::GroupMembers& Chat::group_members() const {
  // @@protoc_insertion_point(field_get:chat.Chat.group_members)
  return _internal_group_members();
}
inline void Chat::unsafe_arena_set_allocated_group_members(
    ::chat::GroupMembers* group_members) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_members_);
  }
  _impl_.group_members_ = group_members;
  if (group_members) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.group_members)
}
inline ::chat::GroupMembers* Chat::release_group_members() {
  
  ::chat::GroupMembers* temp = _impl_.group_members_;
  _impl_.group_members_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::GroupMembers* Chat::unsafe_arena_release_group_members() {
  // @@protoc_insertion_point(field_release:chat.Chat.group_members)
  
  ::chat::GroupMembers* temp = _impl_.group_members_;
  _impl_.group_members_ = nullptr;
  return temp;
}
inline ::chat::GroupMembers* Chat::_internal_mutable_group_members() {
  
  if (_impl_.group_members_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::GroupMembers>(GetArenaForAllocation());
    _impl_.group_members_ = p;
  }
  return _impl_.group_members_;
}
inline ::chat::GroupMembers* Chat::mutable_group_members() {
  ::chat::GroupMembers* _msg = _internal_mutable_group_members();
  // @@protoc_insertion_point(field_mutable:chat.Chat.group_members)
  return _msg;
}
inline void Chat::set_allocated_group_members(::chat::GroupMembers* group_members) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_members_;
  }
  if (group_members) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_members);
    if (message_arena != submessage_arena) {
      group_members = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_members, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_members_ = group_members;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.group_members)
}

// .chat.GroupChat group_chat = 26;
inline bool Chat::_internal_has_group_chat() const {
  return this != internal_default_instance() && _impl_.group_chat_ != nullptr;
}
inline bool Chat::has_group_chat() const {
  return _internal_has_group_chat();
}
inline void Chat::clear_group_chat() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_chat_ != nullptr) {
    delete _impl_.group_chat_;
  }
  _impl_.group_chat_ = nullptr;
}
inline const ::chat::GroupChat& Chat::_internal_group_chat() const {
  const ::chat::GroupChat* p = _impl_.group_chat_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::GroupChat&>(
      ::chat::_GroupChat_default_instance_);
}
inline const ::chat::GroupChat& Chat::group_chat() const {
  // @@protoc_insertion_point(field_get:chat.Chat.group_chat)
  return _internal_group_chat();
}
inline void Chat::unsafe_arena_set_allocated_group_chat(
    ::chat::GroupChat* group_chat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_chat_);
  }
  _impl_.group_chat_ = group_chat;
  if (group_chat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.group_chat)
}
inline ::chat::GroupChat* Chat::release_group_chat() {
  
  ::chat::GroupChat* temp = _impl_.group_chat_;
  _impl_.group_chat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::GroupChat* Chat::unsafe_arena_release_group_chat() {
  // @@protoc_insertion_point(field_release:chat.Chat.group_chat)
  
  ::chat::GroupChat* temp = _impl_.group_chat_;
  _impl_.group_chat_ = nullptr;
  return temp;
}
inline ::chat::GroupChat* Chat::_internal_mutable_group_chat() {
  
  if (_impl_.group_chat_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::GroupChat>(GetArenaForAllocation());
    _impl_.group_chat_ = p;
  }
  return _impl_.group_chat_;
}
inline ::chat::GroupChat* Chat::mutable_group_chat() {
  ::chat::GroupChat* _msg = _internal_mutable_group_chat();
  // @@protoc_insertion_point(field_mutable:chat.Chat.group_chat)
  return _msg;
}
inline void Chat::set_allocated_group_chat(::chat::GroupChat* group_chat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_chat_;
  }
  if (group_chat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_chat);
    if (message_arena != submessage_arena) {
      group_chat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_chat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_chat_ = group_chat;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.group_chat)
}

// .chat.GroupChatList chat_list = 27;
inline bool Chat::_internal_has_chat_list() const {
  return this != internal_default_instance() && _impl_.chat_list_ != nullptr;
}
inline bool Chat::has_chat_list() const {
  return _internal_has_chat_list();
}
inline void Chat::clear_chat_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.chat_list_ != nullptr) {
    delete _impl_.chat_list_;
  }
  _impl_.chat_list_ = nullptr;
}
inline const ::chat::GroupChatList& Chat::_internal_chat_list() const {
  const ::chat::GroupChatList* p = _impl_.chat_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::GroupChatList&>(
      ::chat::_GroupChatList_default_instance_);
}
inline const ::chat::GroupChatList& Chat::chat_list() const {
  // @@protoc_insertion_point(field_get:chat.Chat.chat_list)
  return _internal_chat_list();
}
inline void Chat::unsafe_arena_set_allocated_chat_list(
    ::chat::GroupChatList* chat_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_list_);
  }
  _impl_.chat_list_ = chat_list;
  if (chat_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.chat_list)
}
inline ::chat::GroupChatList* Chat::release_chat_list() {
  
  ::chat::GroupChatList* temp = _impl_.chat_list_;
  _impl_.chat_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::GroupChatList* Chat::unsafe_arena_release_chat_list() {
  // @@protoc_insertion_point(field_release:chat.Chat.chat_list)
  
  ::chat::GroupChatList* temp = _impl_.chat_list_;
  _impl_.chat_list_ = nullptr;
  return temp;
}
inline ::chat::GroupChatList* Chat::_internal_mutable_chat_list() {
  
  if (_impl_.chat_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::GroupChatList>(GetArenaForAllocation());
    _impl_.chat_list_ = p;
  }
  return _impl_.chat_list_;
}
inline ::chat::GroupChatList* Chat::mutable_chat_list() {
  ::chat::GroupChatList* _msg = _internal_mutable_chat_list();
  // @@protoc_insertion_point(field_mutable:chat.Chat.chat_list)
  return _msg;
}
inline void Chat::set_allocated_chat_list(::chat::GroupChatList* chat_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_list_;
  }
  if (chat_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat_list);
    if (message_arena != submessage_arena) {
      chat_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chat_list_ = chat_list;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.chat_list)
}

// .chat.LeaveGroup leave_group = 28;
inline bool Chat::_internal_has_leave_group() const {
  return this != internal_default_instance() && _impl_.leave_group_ != nullptr;
}
inline bool Chat::has_leave_group() const {
  return _internal_has_leave_group();
}
inline void Chat::clear_leave_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.leave_group_ != nullptr) {
    delete _impl_.leave_group_;
  }
  _impl_.leave_group_ = nullptr;
}
inline const ::chat::LeaveGroup& Chat::_internal_leave_group() const {
  const ::chat::LeaveGroup* p = _impl_.leave_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::LeaveGroup&>(
      ::chat::_LeaveGroup_default_instance_);
}
inline const ::chat::LeaveGroup& Chat::leave_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.leave_group)
  return _internal_leave_group();
}
inline void Chat::unsafe_arena_set_allocated_leave_group(
    ::chat::LeaveGroup* leave_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leave_group_);
  }
  _impl_.leave_group_ = leave_group;
  if (leave_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.leave_group)
}
inline ::chat::LeaveGroup* Chat::release_leave_group() {
  
  ::chat::LeaveGroup* temp = _impl_.leave_group_;
  _impl_.leave_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::LeaveGroup* Chat::unsafe_arena_release_leave_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.leave_group)
  
  ::chat::LeaveGroup* temp = _impl_.leave_group_;
  _impl_.leave_group_ = nullptr;
  return temp;
}
inline ::chat::LeaveGroup* Chat::_internal_mutable_leave_group() {
  
  if (_impl_.leave_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::LeaveGroup>(GetArenaForAllocation());
    _impl_.leave_group_ = p;
  }
  return _impl_.leave_group_;
}
inline ::chat::LeaveGroup* Chat::mutable_leave_group() {
  ::chat::LeaveGroup* _msg = _internal_mutable_leave_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.leave_group)
  return _msg;
}
inline void Chat::set_allocated_leave_group(::chat::LeaveGroup* leave_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.leave_group_;
  }
  if (leave_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(leave_group);
    if (message_arena != submessage_arena) {
      leave_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leave_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leave_group_ = leave_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.leave_group)
}

// .chat.AddMember add_member = 29;
inline bool Chat::_internal_has_add_member() const {
  return this != internal_default_instance() && _impl_.add_member_ != nullptr;
}
inline bool Chat::has_add_member() const {
  return _internal_has_add_member();
}
inline void Chat::clear_add_member() {
  if (GetArenaForAllocation() == nullptr && _impl_.add_member_ != nullptr) {
    delete _impl_.add_member_;
  }
  _impl_.add_member_ = nullptr;
}
inline const ::chat::AddMember& Chat::_internal_add_member() const {
  const ::chat::AddMember* p = _impl_.add_member_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::AddMember&>(
      ::chat::_AddMember_default_instance_);
}
inline const ::chat::AddMember& Chat::add_member() const {
  // @@protoc_insertion_point(field_get:chat.Chat.add_member)
  return _internal_add_member();
}
inline void Chat::unsafe_arena_set_allocated_add_member(
    ::chat::AddMember* add_member) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.add_member_);
  }
  _impl_.add_member_ = add_member;
  if (add_member) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.add_member)
}
inline ::chat::AddMember* Chat::release_add_member() {
  
  ::chat::AddMember* temp = _impl_.add_member_;
  _impl_.add_member_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::AddMember* Chat::unsafe_arena_release_add_member() {
  // @@protoc_insertion_point(field_release:chat.Chat.add_member)
  
  ::chat::AddMember* temp = _impl_.add_member_;
  _impl_.add_member_ = nullptr;
  return temp;
}
inline ::chat::AddMember* Chat::_internal_mutable_add_member() {
  
  if (_impl_.add_member_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::AddMember>(GetArenaForAllocation());
    _impl_.add_member_ = p;
  }
  return _impl_.add_member_;
}
inline ::chat::AddMember* Chat::mutable_add_member() {
  ::chat::AddMember* _msg = _internal_mutable_add_member();
  // @@protoc_insertion_point(field_mutable:chat.Chat.add_member)
  return _msg;
}
inline void Chat::set_allocated_add_member(::chat::AddMember* add_member) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.add_member_;
  }
  if (add_member) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_member);
    if (message_arena != submessage_arena) {
      add_member = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_member, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.add_member_ = add_member;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.add_member)
}

// .chat.DelMember del_member = 30;
inline bool Chat::_internal_has_del_member() const {
  return this != internal_default_instance() && _impl_.del_member_ != nullptr;
}
inline bool Chat::has_del_member() const {
  return _internal_has_del_member();
}
inline void Chat::clear_del_member() {
  if (GetArenaForAllocation() == nullptr && _impl_.del_member_ != nullptr) {
    delete _impl_.del_member_;
  }
  _impl_.del_member_ = nullptr;
}
inline const ::chat::DelMember& Chat::_internal_del_member() const {
  const ::chat::DelMember* p = _impl_.del_member_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::DelMember&>(
      ::chat::_DelMember_default_instance_);
}
inline const ::chat::DelMember& Chat::del_member() const {
  // @@protoc_insertion_point(field_get:chat.Chat.del_member)
  return _internal_del_member();
}
inline void Chat::unsafe_arena_set_allocated_del_member(
    ::chat::DelMember* del_member) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.del_member_);
  }
  _impl_.del_member_ = del_member;
  if (del_member) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.del_member)
}
inline ::chat::DelMember* Chat::release_del_member() {
  
  ::chat::DelMember* temp = _impl_.del_member_;
  _impl_.del_member_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::DelMember* Chat::unsafe_arena_release_del_member() {
  // @@protoc_insertion_point(field_release:chat.Chat.del_member)
  
  ::chat::DelMember* temp = _impl_.del_member_;
  _impl_.del_member_ = nullptr;
  return temp;
}
inline ::chat::DelMember* Chat::_internal_mutable_del_member() {
  
  if (_impl_.del_member_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DelMember>(GetArenaForAllocation());
    _impl_.del_member_ = p;
  }
  return _impl_.del_member_;
}
inline ::chat::DelMember* Chat::mutable_del_member() {
  ::chat::DelMember* _msg = _internal_mutable_del_member();
  // @@protoc_insertion_point(field_mutable:chat.Chat.del_member)
  return _msg;
}
inline void Chat::set_allocated_del_member(::chat::DelMember* del_member) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.del_member_;
  }
  if (del_member) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(del_member);
    if (message_arena != submessage_arena) {
      del_member = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, del_member, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.del_member_ = del_member;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.del_member)
}

// .chat.AddMemberResponse add_member_res = 31;
inline bool Chat::_internal_has_add_member_res() const {
  return this != internal_default_instance() && _impl_.add_member_res_ != nullptr;
}
inline bool Chat::has_add_member_res() const {
  return _internal_has_add_member_res();
}
inline void Chat::clear_add_member_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.add_member_res_ != nullptr) {
    delete _impl_.add_member_res_;
  }
  _impl_.add_member_res_ = nullptr;
}
inline const ::chat::AddMemberResponse& Chat::_internal_add_member_res() const {
  const ::chat::AddMemberResponse* p = _impl_.add_member_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::AddMemberResponse&>(
      ::chat::_AddMemberResponse_default_instance_);
}
inline const ::chat::AddMemberResponse& Chat::add_member_res() const {
  // @@protoc_insertion_point(field_get:chat.Chat.add_member_res)
  return _internal_add_member_res();
}
inline void Chat::unsafe_arena_set_allocated_add_member_res(
    ::chat::AddMemberResponse* add_member_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.add_member_res_);
  }
  _impl_.add_member_res_ = add_member_res;
  if (add_member_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.add_member_res)
}
inline ::chat::AddMemberResponse* Chat::release_add_member_res() {
  
  ::chat::AddMemberResponse* temp = _impl_.add_member_res_;
  _impl_.add_member_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::AddMemberResponse* Chat::unsafe_arena_release_add_member_res() {
  // @@protoc_insertion_point(field_release:chat.Chat.add_member_res)
  
  ::chat::AddMemberResponse* temp = _impl_.add_member_res_;
  _impl_.add_member_res_ = nullptr;
  return temp;
}
inline ::chat::AddMemberResponse* Chat::_internal_mutable_add_member_res() {
  
  if (_impl_.add_member_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::AddMemberResponse>(GetArenaForAllocation());
    _impl_.add_member_res_ = p;
  }
  return _impl_.add_member_res_;
}
inline ::chat::AddMemberResponse* Chat::mutable_add_member_res() {
  ::chat::AddMemberResponse* _msg = _internal_mutable_add_member_res();
  // @@protoc_insertion_point(field_mutable:chat.Chat.add_member_res)
  return _msg;
}
inline void Chat::set_allocated_add_member_res(::chat::AddMemberResponse* add_member_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.add_member_res_;
  }
  if (add_member_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_member_res);
    if (message_arena != submessage_arena) {
      add_member_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_member_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.add_member_res_ = add_member_res;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.add_member_res)
}

// .chat.DelMemberResponse del_member_res = 32;
inline bool Chat::_internal_has_del_member_res() const {
  return this != internal_default_instance() && _impl_.del_member_res_ != nullptr;
}
inline bool Chat::has_del_member_res() const {
  return _internal_has_del_member_res();
}
inline void Chat::clear_del_member_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.del_member_res_ != nullptr) {
    delete _impl_.del_member_res_;
  }
  _impl_.del_member_res_ = nullptr;
}
inline const ::chat::DelMemberResponse& Chat::_internal_del_member_res() const {
  const ::chat::DelMemberResponse* p = _impl_.del_member_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::DelMemberResponse&>(
      ::chat::_DelMemberResponse_default_instance_);
}
inline const ::chat::DelMemberResponse& Chat::del_member_res() const {
  // @@protoc_insertion_point(field_get:chat.Chat.del_member_res)
  return _internal_del_member_res();
}
inline void Chat::unsafe_arena_set_allocated_del_member_res(
    ::chat::DelMemberResponse* del_member_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.del_member_res_);
  }
  _impl_.del_member_res_ = del_member_res;
  if (del_member_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.del_member_res)
}
inline ::chat::DelMemberResponse* Chat::release_del_member_res() {
  
  ::chat::DelMemberResponse* temp = _impl_.del_member_res_;
  _impl_.del_member_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::DelMemberResponse* Chat::unsafe_arena_release_del_member_res() {
  // @@protoc_insertion_point(field_release:chat.Chat.del_member_res)
  
  ::chat::DelMemberResponse* temp = _impl_.del_member_res_;
  _impl_.del_member_res_ = nullptr;
  return temp;
}
inline ::chat::DelMemberResponse* Chat::_internal_mutable_del_member_res() {
  
  if (_impl_.del_member_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DelMemberResponse>(GetArenaForAllocation());
    _impl_.del_member_res_ = p;
  }
  return _impl_.del_member_res_;
}
inline ::chat::DelMemberResponse* Chat::mutable_del_member_res() {
  ::chat::DelMemberResponse* _msg = _internal_mutable_del_member_res();
  // @@protoc_insertion_point(field_mutable:chat.Chat.del_member_res)
  return _msg;
}
inline void Chat::set_allocated_del_member_res(::chat::DelMemberResponse* del_member_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.del_member_res_;
  }
  if (del_member_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(del_member_res);
    if (message_arena != submessage_arena) {
      del_member_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, del_member_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.del_member_res_ = del_member_res;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.del_member_res)
}

// .chat.DisbandGroup disband_group = 33;
inline bool Chat::_internal_has_disband_group() const {
  return this != internal_default_instance() && _impl_.disband_group_ != nullptr;
}
inline bool Chat::has_disband_group() const {
  return _internal_has_disband_group();
}
inline void Chat::clear_disband_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.disband_group_ != nullptr) {
    delete _impl_.disband_group_;
  }
  _impl_.disband_group_ = nullptr;
}
inline const ::chat::DisbandGroup& Chat::_internal_disband_group() const {
  const ::chat::DisbandGroup* p = _impl_.disband_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::DisbandGroup&>(
      ::chat::_DisbandGroup_default_instance_);
}
inline const ::chat::DisbandGroup& Chat::disband_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.disband_group)
  return _internal_disband_group();
}
inline void Chat::unsafe_arena_set_allocated_disband_group(
    ::chat::DisbandGroup* disband_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disband_group_);
  }
  _impl_.disband_group_ = disband_group;
  if (disband_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.disband_group)
}
inline ::chat::DisbandGroup* Chat::release_disband_group() {
  
  ::chat::DisbandGroup* temp = _impl_.disband_group_;
  _impl_.disband_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::DisbandGroup* Chat::unsafe_arena_release_disband_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.disband_group)
  
  ::chat::DisbandGroup* temp = _impl_.disband_group_;
  _impl_.disband_group_ = nullptr;
  return temp;
}
inline ::chat::DisbandGroup* Chat::_internal_mutable_disband_group() {
  
  if (_impl_.disband_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DisbandGroup>(GetArenaForAllocation());
    _impl_.disband_group_ = p;
  }
  return _impl_.disband_group_;
}
inline ::chat::DisbandGroup* Chat::mutable_disband_group() {
  ::chat::DisbandGroup* _msg = _internal_mutable_disband_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.disband_group)
  return _msg;
}
inline void Chat::set_allocated_disband_group(::chat::DisbandGroup* disband_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disband_group_;
  }
  if (disband_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disband_group);
    if (message_arena != submessage_arena) {
      disband_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disband_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.disband_group_ = disband_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.disband_group)
}

// .chat.AddManager add_manager = 34;
inline bool Chat::_internal_has_add_manager() const {
  return this != internal_default_instance() && _impl_.add_manager_ != nullptr;
}
inline bool Chat::has_add_manager() const {
  return _internal_has_add_manager();
}
inline void Chat::clear_add_manager() {
  if (GetArenaForAllocation() == nullptr && _impl_.add_manager_ != nullptr) {
    delete _impl_.add_manager_;
  }
  _impl_.add_manager_ = nullptr;
}
inline const ::chat::AddManager& Chat::_internal_add_manager() const {
  const ::chat::AddManager* p = _impl_.add_manager_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::AddManager&>(
      ::chat::_AddManager_default_instance_);
}
inline const ::chat::AddManager& Chat::add_manager() const {
  // @@protoc_insertion_point(field_get:chat.Chat.add_manager)
  return _internal_add_manager();
}
inline void Chat::unsafe_arena_set_allocated_add_manager(
    ::chat::AddManager* add_manager) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.add_manager_);
  }
  _impl_.add_manager_ = add_manager;
  if (add_manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.add_manager)
}
inline ::chat::AddManager* Chat::release_add_manager() {
  
  ::chat::AddManager* temp = _impl_.add_manager_;
  _impl_.add_manager_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::AddManager* Chat::unsafe_arena_release_add_manager() {
  // @@protoc_insertion_point(field_release:chat.Chat.add_manager)
  
  ::chat::AddManager* temp = _impl_.add_manager_;
  _impl_.add_manager_ = nullptr;
  return temp;
}
inline ::chat::AddManager* Chat::_internal_mutable_add_manager() {
  
  if (_impl_.add_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::AddManager>(GetArenaForAllocation());
    _impl_.add_manager_ = p;
  }
  return _impl_.add_manager_;
}
inline ::chat::AddManager* Chat::mutable_add_manager() {
  ::chat::AddManager* _msg = _internal_mutable_add_manager();
  // @@protoc_insertion_point(field_mutable:chat.Chat.add_manager)
  return _msg;
}
inline void Chat::set_allocated_add_manager(::chat::AddManager* add_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.add_manager_;
  }
  if (add_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_manager);
    if (message_arena != submessage_arena) {
      add_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_manager, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.add_manager_ = add_manager;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.add_manager)
}

// .chat.DelManager del_manager = 35;
inline bool Chat::_internal_has_del_manager() const {
  return this != internal_default_instance() && _impl_.del_manager_ != nullptr;
}
inline bool Chat::has_del_manager() const {
  return _internal_has_del_manager();
}
inline void Chat::clear_del_manager() {
  if (GetArenaForAllocation() == nullptr && _impl_.del_manager_ != nullptr) {
    delete _impl_.del_manager_;
  }
  _impl_.del_manager_ = nullptr;
}
inline const ::chat::DelManager& Chat::_internal_del_manager() const {
  const ::chat::DelManager* p = _impl_.del_manager_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::DelManager&>(
      ::chat::_DelManager_default_instance_);
}
inline const ::chat::DelManager& Chat::del_manager() const {
  // @@protoc_insertion_point(field_get:chat.Chat.del_manager)
  return _internal_del_manager();
}
inline void Chat::unsafe_arena_set_allocated_del_manager(
    ::chat::DelManager* del_manager) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.del_manager_);
  }
  _impl_.del_manager_ = del_manager;
  if (del_manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.del_manager)
}
inline ::chat::DelManager* Chat::release_del_manager() {
  
  ::chat::DelManager* temp = _impl_.del_manager_;
  _impl_.del_manager_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::DelManager* Chat::unsafe_arena_release_del_manager() {
  // @@protoc_insertion_point(field_release:chat.Chat.del_manager)
  
  ::chat::DelManager* temp = _impl_.del_manager_;
  _impl_.del_manager_ = nullptr;
  return temp;
}
inline ::chat::DelManager* Chat::_internal_mutable_del_manager() {
  
  if (_impl_.del_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DelManager>(GetArenaForAllocation());
    _impl_.del_manager_ = p;
  }
  return _impl_.del_manager_;
}
inline ::chat::DelManager* Chat::mutable_del_manager() {
  ::chat::DelManager* _msg = _internal_mutable_del_manager();
  // @@protoc_insertion_point(field_mutable:chat.Chat.del_manager)
  return _msg;
}
inline void Chat::set_allocated_del_manager(::chat::DelManager* del_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.del_manager_;
  }
  if (del_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(del_manager);
    if (message_arena != submessage_arena) {
      del_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, del_manager, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.del_manager_ = del_manager;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.del_manager)
}

// .chat.RecvFileGroup recv_file_group = 36;
inline bool Chat::_internal_has_recv_file_group() const {
  return this != internal_default_instance() && _impl_.recv_file_group_ != nullptr;
}
inline bool Chat::has_recv_file_group() const {
  return _internal_has_recv_file_group();
}
inline void Chat::clear_recv_file_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.recv_file_group_ != nullptr) {
    delete _impl_.recv_file_group_;
  }
  _impl_.recv_file_group_ = nullptr;
}
inline const ::chat::RecvFileGroup& Chat::_internal_recv_file_group() const {
  const ::chat::RecvFileGroup* p = _impl_.recv_file_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::RecvFileGroup&>(
      ::chat::_RecvFileGroup_default_instance_);
}
inline const ::chat::RecvFileGroup& Chat::recv_file_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.recv_file_group)
  return _internal_recv_file_group();
}
inline void Chat::unsafe_arena_set_allocated_recv_file_group(
    ::chat::RecvFileGroup* recv_file_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recv_file_group_);
  }
  _impl_.recv_file_group_ = recv_file_group;
  if (recv_file_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.recv_file_group)
}
inline ::chat::RecvFileGroup* Chat::release_recv_file_group() {
  
  ::chat::RecvFileGroup* temp = _impl_.recv_file_group_;
  _impl_.recv_file_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::RecvFileGroup* Chat::unsafe_arena_release_recv_file_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.recv_file_group)
  
  ::chat::RecvFileGroup* temp = _impl_.recv_file_group_;
  _impl_.recv_file_group_ = nullptr;
  return temp;
}
inline ::chat::RecvFileGroup* Chat::_internal_mutable_recv_file_group() {
  
  if (_impl_.recv_file_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::RecvFileGroup>(GetArenaForAllocation());
    _impl_.recv_file_group_ = p;
  }
  return _impl_.recv_file_group_;
}
inline ::chat::RecvFileGroup* Chat::mutable_recv_file_group() {
  ::chat::RecvFileGroup* _msg = _internal_mutable_recv_file_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.recv_file_group)
  return _msg;
}
inline void Chat::set_allocated_recv_file_group(::chat::RecvFileGroup* recv_file_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recv_file_group_;
  }
  if (recv_file_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recv_file_group);
    if (message_arena != submessage_arena) {
      recv_file_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recv_file_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recv_file_group_ = recv_file_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.recv_file_group)
}

// .chat.SendFileGroup send_file_group = 37;
inline bool Chat::_internal_has_send_file_group() const {
  return this != internal_default_instance() && _impl_.send_file_group_ != nullptr;
}
inline bool Chat::has_send_file_group() const {
  return _internal_has_send_file_group();
}
inline void Chat::clear_send_file_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.send_file_group_ != nullptr) {
    delete _impl_.send_file_group_;
  }
  _impl_.send_file_group_ = nullptr;
}
inline const ::chat::SendFileGroup& Chat::_internal_send_file_group() const {
  const ::chat::SendFileGroup* p = _impl_.send_file_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::SendFileGroup&>(
      ::chat::_SendFileGroup_default_instance_);
}
inline const ::chat::SendFileGroup& Chat::send_file_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.send_file_group)
  return _internal_send_file_group();
}
inline void Chat::unsafe_arena_set_allocated_send_file_group(
    ::chat::SendFileGroup* send_file_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.send_file_group_);
  }
  _impl_.send_file_group_ = send_file_group;
  if (send_file_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.send_file_group)
}
inline ::chat::SendFileGroup* Chat::release_send_file_group() {
  
  ::chat::SendFileGroup* temp = _impl_.send_file_group_;
  _impl_.send_file_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::SendFileGroup* Chat::unsafe_arena_release_send_file_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.send_file_group)
  
  ::chat::SendFileGroup* temp = _impl_.send_file_group_;
  _impl_.send_file_group_ = nullptr;
  return temp;
}
inline ::chat::SendFileGroup* Chat::_internal_mutable_send_file_group() {
  
  if (_impl_.send_file_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::SendFileGroup>(GetArenaForAllocation());
    _impl_.send_file_group_ = p;
  }
  return _impl_.send_file_group_;
}
inline ::chat::SendFileGroup* Chat::mutable_send_file_group() {
  ::chat::SendFileGroup* _msg = _internal_mutable_send_file_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.send_file_group)
  return _msg;
}
inline void Chat::set_allocated_send_file_group(::chat::SendFileGroup* send_file_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.send_file_group_;
  }
  if (send_file_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(send_file_group);
    if (message_arena != submessage_arena) {
      send_file_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_file_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.send_file_group_ = send_file_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.send_file_group)
}

// .chat.FileListGroup file_list_group = 38;
inline bool Chat::_internal_has_file_list_group() const {
  return this != internal_default_instance() && _impl_.file_list_group_ != nullptr;
}
inline bool Chat::has_file_list_group() const {
  return _internal_has_file_list_group();
}
inline void Chat::clear_file_list_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.file_list_group_ != nullptr) {
    delete _impl_.file_list_group_;
  }
  _impl_.file_list_group_ = nullptr;
}
inline const ::chat::FileListGroup& Chat::_internal_file_list_group() const {
  const ::chat::FileListGroup* p = _impl_.file_list_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::FileListGroup&>(
      ::chat::_FileListGroup_default_instance_);
}
inline const ::chat::FileListGroup& Chat::file_list_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.file_list_group)
  return _internal_file_list_group();
}
inline void Chat::unsafe_arena_set_allocated_file_list_group(
    ::chat::FileListGroup* file_list_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_list_group_);
  }
  _impl_.file_list_group_ = file_list_group;
  if (file_list_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.file_list_group)
}
inline ::chat::FileListGroup* Chat::release_file_list_group() {
  
  ::chat::FileListGroup* temp = _impl_.file_list_group_;
  _impl_.file_list_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::FileListGroup* Chat::unsafe_arena_release_file_list_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.file_list_group)
  
  ::chat::FileListGroup* temp = _impl_.file_list_group_;
  _impl_.file_list_group_ = nullptr;
  return temp;
}
inline ::chat::FileListGroup* Chat::_internal_mutable_file_list_group() {
  
  if (_impl_.file_list_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::FileListGroup>(GetArenaForAllocation());
    _impl_.file_list_group_ = p;
  }
  return _impl_.file_list_group_;
}
inline ::chat::FileListGroup* Chat::mutable_file_list_group() {
  ::chat::FileListGroup* _msg = _internal_mutable_file_list_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.file_list_group)
  return _msg;
}
inline void Chat::set_allocated_file_list_group(::chat::FileListGroup* file_list_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_list_group_;
  }
  if (file_list_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_list_group);
    if (message_arena != submessage_arena) {
      file_list_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_list_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.file_list_group_ = file_list_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.file_list_group)
}

// .chat.LookFileRequestGroup look_fiele_req_group = 39;
inline bool Chat::_internal_has_look_fiele_req_group() const {
  return this != internal_default_instance() && _impl_.look_fiele_req_group_ != nullptr;
}
inline bool Chat::has_look_fiele_req_group() const {
  return _internal_has_look_fiele_req_group();
}
inline void Chat::clear_look_fiele_req_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.look_fiele_req_group_ != nullptr) {
    delete _impl_.look_fiele_req_group_;
  }
  _impl_.look_fiele_req_group_ = nullptr;
}
inline const ::chat::LookFileRequestGroup& Chat::_internal_look_fiele_req_group() const {
  const ::chat::LookFileRequestGroup* p = _impl_.look_fiele_req_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::LookFileRequestGroup&>(
      ::chat::_LookFileRequestGroup_default_instance_);
}
inline const ::chat::LookFileRequestGroup& Chat::look_fiele_req_group() const {
  // @@protoc_insertion_point(field_get:chat.Chat.look_fiele_req_group)
  return _internal_look_fiele_req_group();
}
inline void Chat::unsafe_arena_set_allocated_look_fiele_req_group(
    ::chat::LookFileRequestGroup* look_fiele_req_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.look_fiele_req_group_);
  }
  _impl_.look_fiele_req_group_ = look_fiele_req_group;
  if (look_fiele_req_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.look_fiele_req_group)
}
inline ::chat::LookFileRequestGroup* Chat::release_look_fiele_req_group() {
  
  ::chat::LookFileRequestGroup* temp = _impl_.look_fiele_req_group_;
  _impl_.look_fiele_req_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::LookFileRequestGroup* Chat::unsafe_arena_release_look_fiele_req_group() {
  // @@protoc_insertion_point(field_release:chat.Chat.look_fiele_req_group)
  
  ::chat::LookFileRequestGroup* temp = _impl_.look_fiele_req_group_;
  _impl_.look_fiele_req_group_ = nullptr;
  return temp;
}
inline ::chat::LookFileRequestGroup* Chat::_internal_mutable_look_fiele_req_group() {
  
  if (_impl_.look_fiele_req_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::LookFileRequestGroup>(GetArenaForAllocation());
    _impl_.look_fiele_req_group_ = p;
  }
  return _impl_.look_fiele_req_group_;
}
inline ::chat::LookFileRequestGroup* Chat::mutable_look_fiele_req_group() {
  ::chat::LookFileRequestGroup* _msg = _internal_mutable_look_fiele_req_group();
  // @@protoc_insertion_point(field_mutable:chat.Chat.look_fiele_req_group)
  return _msg;
}
inline void Chat::set_allocated_look_fiele_req_group(::chat::LookFileRequestGroup* look_fiele_req_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.look_fiele_req_group_;
  }
  if (look_fiele_req_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(look_fiele_req_group);
    if (message_arena != submessage_arena) {
      look_fiele_req_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, look_fiele_req_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.look_fiele_req_group_ = look_fiele_req_group;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.look_fiele_req_group)
}

// string heart = 9;
inline void Chat::clear_heart() {
  _impl_.heart_.ClearToEmpty();
}
inline const std::string& Chat::heart() const {
  // @@protoc_insertion_point(field_get:chat.Chat.heart)
  return _internal_heart();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_heart(ArgT0&& arg0, ArgT... args) {
 
 _impl_.heart_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.Chat.heart)
}
inline std::string* Chat::mutable_heart() {
  std::string* _s = _internal_mutable_heart();
  // @@protoc_insertion_point(field_mutable:chat.Chat.heart)
  return _s;
}
inline const std::string& Chat::_internal_heart() const {
  return _impl_.heart_.Get();
}
inline void Chat::_internal_set_heart(const std::string& value) {
  
  _impl_.heart_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_heart() {
  
  return _impl_.heart_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_heart() {
  // @@protoc_insertion_point(field_release:chat.Chat.heart)
  return _impl_.heart_.Release();
}
inline void Chat::set_allocated_heart(std::string* heart) {
  if (heart != nullptr) {
    
  } else {
    
  }
  _impl_.heart_.SetAllocated(heart, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.heart_.IsDefault()) {
    _impl_.heart_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.heart)
}

// .chat.delAccount del_account = 40;
inline bool Chat::_internal_has_del_account() const {
  return this != internal_default_instance() && _impl_.del_account_ != nullptr;
}
inline bool Chat::has_del_account() const {
  return _internal_has_del_account();
}
inline void Chat::clear_del_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.del_account_ != nullptr) {
    delete _impl_.del_account_;
  }
  _impl_.del_account_ = nullptr;
}
inline const ::chat::delAccount& Chat::_internal_del_account() const {
  const ::chat::delAccount* p = _impl_.del_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::delAccount&>(
      ::chat::_delAccount_default_instance_);
}
inline const ::chat::delAccount& Chat::del_account() const {
  // @@protoc_insertion_point(field_get:chat.Chat.del_account)
  return _internal_del_account();
}
inline void Chat::unsafe_arena_set_allocated_del_account(
    ::chat::delAccount* del_account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.del_account_);
  }
  _impl_.del_account_ = del_account;
  if (del_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.Chat.del_account)
}
inline ::chat::delAccount* Chat::release_del_account() {
  
  ::chat::delAccount* temp = _impl_.del_account_;
  _impl_.del_account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::delAccount* Chat::unsafe_arena_release_del_account() {
  // @@protoc_insertion_point(field_release:chat.Chat.del_account)
  
  ::chat::delAccount* temp = _impl_.del_account_;
  _impl_.del_account_ = nullptr;
  return temp;
}
inline ::chat::delAccount* Chat::_internal_mutable_del_account() {
  
  if (_impl_.del_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::delAccount>(GetArenaForAllocation());
    _impl_.del_account_ = p;
  }
  return _impl_.del_account_;
}
inline ::chat::delAccount* Chat::mutable_del_account() {
  ::chat::delAccount* _msg = _internal_mutable_del_account();
  // @@protoc_insertion_point(field_mutable:chat.Chat.del_account)
  return _msg;
}
inline void Chat::set_allocated_del_account(::chat::delAccount* del_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.del_account_;
  }
  if (del_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(del_account);
    if (message_arena != submessage_arena) {
      del_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, del_account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.del_account_ = del_account;
  // @@protoc_insertion_point(field_set_allocated:chat.Chat.del_account)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// delAccount

// string name = 1;
inline void delAccount::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& delAccount::name() const {
  // @@protoc_insertion_point(field_get:chat.delAccount.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void delAccount::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.delAccount.name)
}
inline std::string* delAccount::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.delAccount.name)
  return _s;
}
inline const std::string& delAccount::_internal_name() const {
  return _impl_.name_.Get();
}
inline void delAccount::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* delAccount::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* delAccount::release_name() {
  // @@protoc_insertion_point(field_release:chat.delAccount.name)
  return _impl_.name_.Release();
}
inline void delAccount::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.delAccount.name)
}

// map<string, string> group_name = 2;
inline int delAccount::_internal_group_name_size() const {
  return _impl_.group_name_.size();
}
inline int delAccount::group_name_size() const {
  return _internal_group_name_size();
}
inline void delAccount::clear_group_name() {
  _impl_.group_name_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
delAccount::_internal_group_name() const {
  return _impl_.group_name_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
delAccount::group_name() const {
  // @@protoc_insertion_point(field_map:chat.delAccount.group_name)
  return _internal_group_name();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
delAccount::_internal_mutable_group_name() {
  return _impl_.group_name_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
delAccount::mutable_group_name() {
  // @@protoc_insertion_point(field_mutable_map:chat.delAccount.group_name)
  return _internal_mutable_group_name();
}

// repeated string friends = 4;
inline int delAccount::_internal_friends_size() const {
  return _impl_.friends_.size();
}
inline int delAccount::friends_size() const {
  return _internal_friends_size();
}
inline void delAccount::clear_friends() {
  _impl_.friends_.Clear();
}
inline std::string* delAccount::add_friends() {
  std::string* _s = _internal_add_friends();
  // @@protoc_insertion_point(field_add_mutable:chat.delAccount.friends)
  return _s;
}
inline const std::string& delAccount::_internal_friends(int index) const {
  return _impl_.friends_.Get(index);
}
inline const std::string& delAccount::friends(int index) const {
  // @@protoc_insertion_point(field_get:chat.delAccount.friends)
  return _internal_friends(index);
}
inline std::string* delAccount::mutable_friends(int index) {
  // @@protoc_insertion_point(field_mutable:chat.delAccount.friends)
  return _impl_.friends_.Mutable(index);
}
inline void delAccount::set_friends(int index, const std::string& value) {
  _impl_.friends_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chat.delAccount.friends)
}
inline void delAccount::set_friends(int index, std::string&& value) {
  _impl_.friends_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chat.delAccount.friends)
}
inline void delAccount::set_friends(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.friends_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chat.delAccount.friends)
}
inline void delAccount::set_friends(int index, const char* value, size_t size) {
  _impl_.friends_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chat.delAccount.friends)
}
inline std::string* delAccount::_internal_add_friends() {
  return _impl_.friends_.Add();
}
inline void delAccount::add_friends(const std::string& value) {
  _impl_.friends_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chat.delAccount.friends)
}
inline void delAccount::add_friends(std::string&& value) {
  _impl_.friends_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chat.delAccount.friends)
}
inline void delAccount::add_friends(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.friends_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chat.delAccount.friends)
}
inline void delAccount::add_friends(const char* value, size_t size) {
  _impl_.friends_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chat.delAccount.friends)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
delAccount::friends() const {
  // @@protoc_insertion_point(field_list:chat.delAccount.friends)
  return _impl_.friends_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
delAccount::mutable_friends() {
  // @@protoc_insertion_point(field_mutable_list:chat.delAccount.friends)
  return &_impl_.friends_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LookFileRequestGroup

// string username = 1;
inline void LookFileRequestGroup::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LookFileRequestGroup::username() const {
  // @@protoc_insertion_point(field_get:chat.LookFileRequestGroup.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookFileRequestGroup::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LookFileRequestGroup.username)
}
inline std::string* LookFileRequestGroup::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.LookFileRequestGroup.username)
  return _s;
}
inline const std::string& LookFileRequestGroup::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LookFileRequestGroup::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LookFileRequestGroup::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LookFileRequestGroup::release_username() {
  // @@protoc_insertion_point(field_release:chat.LookFileRequestGroup.username)
  return _impl_.username_.Release();
}
inline void LookFileRequestGroup::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LookFileRequestGroup.username)
}

// map<string, .chat.FileListGroup> result = 2;
inline int LookFileRequestGroup::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int LookFileRequestGroup::result_size() const {
  return _internal_result_size();
}
inline void LookFileRequestGroup::clear_result() {
  _impl_.result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >&
LookFileRequestGroup::_internal_result() const {
  return _impl_.result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >&
LookFileRequestGroup::result() const {
  // @@protoc_insertion_point(field_map:chat.LookFileRequestGroup.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >*
LookFileRequestGroup::_internal_mutable_result() {
  return _impl_.result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileListGroup >*
LookFileRequestGroup::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:chat.LookFileRequestGroup.result)
  return _internal_mutable_result();
}

// string u_name = 3;
inline void LookFileRequestGroup::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& LookFileRequestGroup::u_name() const {
  // @@protoc_insertion_point(field_get:chat.LookFileRequestGroup.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookFileRequestGroup::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LookFileRequestGroup.u_name)
}
inline std::string* LookFileRequestGroup::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.LookFileRequestGroup.u_name)
  return _s;
}
inline const std::string& LookFileRequestGroup::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void LookFileRequestGroup::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LookFileRequestGroup::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LookFileRequestGroup::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.LookFileRequestGroup.u_name)
  return _impl_.u_name_.Release();
}
inline void LookFileRequestGroup::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LookFileRequestGroup.u_name)
}

// string g_name = 4;
inline void LookFileRequestGroup::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& LookFileRequestGroup::g_name() const {
  // @@protoc_insertion_point(field_get:chat.LookFileRequestGroup.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookFileRequestGroup::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LookFileRequestGroup.g_name)
}
inline std::string* LookFileRequestGroup::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.LookFileRequestGroup.g_name)
  return _s;
}
inline const std::string& LookFileRequestGroup::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void LookFileRequestGroup::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LookFileRequestGroup::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LookFileRequestGroup::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.LookFileRequestGroup.g_name)
  return _impl_.g_name_.Release();
}
inline void LookFileRequestGroup::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LookFileRequestGroup.g_name)
}

// -------------------------------------------------------------------

// FileListGroup

// repeated string files = 1;
inline int FileListGroup::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int FileListGroup::files_size() const {
  return _internal_files_size();
}
inline void FileListGroup::clear_files() {
  _impl_.files_.Clear();
}
inline std::string* FileListGroup::add_files() {
  std::string* _s = _internal_add_files();
  // @@protoc_insertion_point(field_add_mutable:chat.FileListGroup.files)
  return _s;
}
inline const std::string& FileListGroup::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const std::string& FileListGroup::files(int index) const {
  // @@protoc_insertion_point(field_get:chat.FileListGroup.files)
  return _internal_files(index);
}
inline std::string* FileListGroup::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:chat.FileListGroup.files)
  return _impl_.files_.Mutable(index);
}
inline void FileListGroup::set_files(int index, const std::string& value) {
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chat.FileListGroup.files)
}
inline void FileListGroup::set_files(int index, std::string&& value) {
  _impl_.files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chat.FileListGroup.files)
}
inline void FileListGroup::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chat.FileListGroup.files)
}
inline void FileListGroup::set_files(int index, const char* value, size_t size) {
  _impl_.files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chat.FileListGroup.files)
}
inline std::string* FileListGroup::_internal_add_files() {
  return _impl_.files_.Add();
}
inline void FileListGroup::add_files(const std::string& value) {
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chat.FileListGroup.files)
}
inline void FileListGroup::add_files(std::string&& value) {
  _impl_.files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chat.FileListGroup.files)
}
inline void FileListGroup::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chat.FileListGroup.files)
}
inline void FileListGroup::add_files(const char* value, size_t size) {
  _impl_.files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chat.FileListGroup.files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FileListGroup::files() const {
  // @@protoc_insertion_point(field_list:chat.FileListGroup.files)
  return _impl_.files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FileListGroup::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:chat.FileListGroup.files)
  return &_impl_.files_;
}

// -------------------------------------------------------------------

// SendFileGroup

// string name = 5;
inline void SendFileGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SendFileGroup::name() const {
  // @@protoc_insertion_point(field_get:chat.SendFileGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFileGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFileGroup.name)
}
inline std::string* SendFileGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.SendFileGroup.name)
  return _s;
}
inline const std::string& SendFileGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SendFileGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFileGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFileGroup::release_name() {
  // @@protoc_insertion_point(field_release:chat.SendFileGroup.name)
  return _impl_.name_.Release();
}
inline void SendFileGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFileGroup.name)
}

// string g_name = 4;
inline void SendFileGroup::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& SendFileGroup::g_name() const {
  // @@protoc_insertion_point(field_get:chat.SendFileGroup.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFileGroup::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFileGroup.g_name)
}
inline std::string* SendFileGroup::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.SendFileGroup.g_name)
  return _s;
}
inline const std::string& SendFileGroup::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void SendFileGroup::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFileGroup::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFileGroup::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.SendFileGroup.g_name)
  return _impl_.g_name_.Release();
}
inline void SendFileGroup::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFileGroup.g_name)
}

// string u_name = 1;
inline void SendFileGroup::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& SendFileGroup::u_name() const {
  // @@protoc_insertion_point(field_get:chat.SendFileGroup.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFileGroup::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFileGroup.u_name)
}
inline std::string* SendFileGroup::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.SendFileGroup.u_name)
  return _s;
}
inline const std::string& SendFileGroup::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void SendFileGroup::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFileGroup::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFileGroup::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.SendFileGroup.u_name)
  return _impl_.u_name_.Release();
}
inline void SendFileGroup::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFileGroup.u_name)
}

// string file_name = 2;
inline void SendFileGroup::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& SendFileGroup::file_name() const {
  // @@protoc_insertion_point(field_get:chat.SendFileGroup.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFileGroup::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFileGroup.file_name)
}
inline std::string* SendFileGroup::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:chat.SendFileGroup.file_name)
  return _s;
}
inline const std::string& SendFileGroup::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void SendFileGroup::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFileGroup::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFileGroup::release_file_name() {
  // @@protoc_insertion_point(field_release:chat.SendFileGroup.file_name)
  return _impl_.file_name_.Release();
}
inline void SendFileGroup::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFileGroup.file_name)
}

// string time = 3;
inline void SendFileGroup::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& SendFileGroup::time() const {
  // @@protoc_insertion_point(field_get:chat.SendFileGroup.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFileGroup::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFileGroup.time)
}
inline std::string* SendFileGroup::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.SendFileGroup.time)
  return _s;
}
inline const std::string& SendFileGroup::_internal_time() const {
  return _impl_.time_.Get();
}
inline void SendFileGroup::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFileGroup::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFileGroup::release_time() {
  // @@protoc_insertion_point(field_release:chat.SendFileGroup.time)
  return _impl_.time_.Release();
}
inline void SendFileGroup::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFileGroup.time)
}

// -------------------------------------------------------------------

// RecvFileGroup

// string name = 1;
inline void RecvFileGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RecvFileGroup::name() const {
  // @@protoc_insertion_point(field_get:chat.RecvFileGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFileGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFileGroup.name)
}
inline std::string* RecvFileGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.RecvFileGroup.name)
  return _s;
}
inline const std::string& RecvFileGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RecvFileGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFileGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFileGroup::release_name() {
  // @@protoc_insertion_point(field_release:chat.RecvFileGroup.name)
  return _impl_.name_.Release();
}
inline void RecvFileGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFileGroup.name)
}

// string u_name = 4;
inline void RecvFileGroup::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& RecvFileGroup::u_name() const {
  // @@protoc_insertion_point(field_get:chat.RecvFileGroup.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFileGroup::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFileGroup.u_name)
}
inline std::string* RecvFileGroup::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.RecvFileGroup.u_name)
  return _s;
}
inline const std::string& RecvFileGroup::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void RecvFileGroup::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFileGroup::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFileGroup::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.RecvFileGroup.u_name)
  return _impl_.u_name_.Release();
}
inline void RecvFileGroup::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFileGroup.u_name)
}

// string g_name = 5;
inline void RecvFileGroup::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& RecvFileGroup::g_name() const {
  // @@protoc_insertion_point(field_get:chat.RecvFileGroup.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFileGroup::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFileGroup.g_name)
}
inline std::string* RecvFileGroup::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.RecvFileGroup.g_name)
  return _s;
}
inline const std::string& RecvFileGroup::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void RecvFileGroup::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFileGroup::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFileGroup::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.RecvFileGroup.g_name)
  return _impl_.g_name_.Release();
}
inline void RecvFileGroup::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFileGroup.g_name)
}

// string file_name = 2;
inline void RecvFileGroup::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& RecvFileGroup::file_name() const {
  // @@protoc_insertion_point(field_get:chat.RecvFileGroup.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFileGroup::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFileGroup.file_name)
}
inline std::string* RecvFileGroup::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:chat.RecvFileGroup.file_name)
  return _s;
}
inline const std::string& RecvFileGroup::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void RecvFileGroup::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFileGroup::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFileGroup::release_file_name() {
  // @@protoc_insertion_point(field_release:chat.RecvFileGroup.file_name)
  return _impl_.file_name_.Release();
}
inline void RecvFileGroup::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFileGroup.file_name)
}

// string time = 3;
inline void RecvFileGroup::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& RecvFileGroup::time() const {
  // @@protoc_insertion_point(field_get:chat.RecvFileGroup.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFileGroup::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFileGroup.time)
}
inline std::string* RecvFileGroup::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.RecvFileGroup.time)
  return _s;
}
inline const std::string& RecvFileGroup::_internal_time() const {
  return _impl_.time_.Get();
}
inline void RecvFileGroup::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFileGroup::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFileGroup::release_time() {
  // @@protoc_insertion_point(field_release:chat.RecvFileGroup.time)
  return _impl_.time_.Release();
}
inline void RecvFileGroup::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFileGroup.time)
}

// -------------------------------------------------------------------

// DelManager

// string u_name = 1;
inline void DelManager::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& DelManager::u_name() const {
  // @@protoc_insertion_point(field_get:chat.DelManager.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelManager::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelManager.u_name)
}
inline std::string* DelManager::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.DelManager.u_name)
  return _s;
}
inline const std::string& DelManager::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void DelManager::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DelManager::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DelManager::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.DelManager.u_name)
  return _impl_.u_name_.Release();
}
inline void DelManager::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelManager.u_name)
}

// string g_name = 2;
inline void DelManager::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& DelManager::g_name() const {
  // @@protoc_insertion_point(field_get:chat.DelManager.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelManager::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelManager.g_name)
}
inline std::string* DelManager::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.DelManager.g_name)
  return _s;
}
inline const std::string& DelManager::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void DelManager::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DelManager::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DelManager::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.DelManager.g_name)
  return _impl_.g_name_.Release();
}
inline void DelManager::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelManager.g_name)
}

// string username = 3;
inline void DelManager::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& DelManager::username() const {
  // @@protoc_insertion_point(field_get:chat.DelManager.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelManager::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelManager.username)
}
inline std::string* DelManager::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.DelManager.username)
  return _s;
}
inline const std::string& DelManager::_internal_username() const {
  return _impl_.username_.Get();
}
inline void DelManager::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* DelManager::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* DelManager::release_username() {
  // @@protoc_insertion_point(field_release:chat.DelManager.username)
  return _impl_.username_.Release();
}
inline void DelManager::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelManager.username)
}

// string msg = 4;
inline void DelManager::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& DelManager::msg() const {
  // @@protoc_insertion_point(field_get:chat.DelManager.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelManager::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelManager.msg)
}
inline std::string* DelManager::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.DelManager.msg)
  return _s;
}
inline const std::string& DelManager::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void DelManager::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* DelManager::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* DelManager::release_msg() {
  // @@protoc_insertion_point(field_release:chat.DelManager.msg)
  return _impl_.msg_.Release();
}
inline void DelManager::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelManager.msg)
}

// bool decide = 5;
inline void DelManager::clear_decide() {
  _impl_.decide_ = false;
}
inline bool DelManager::_internal_decide() const {
  return _impl_.decide_;
}
inline bool DelManager::decide() const {
  // @@protoc_insertion_point(field_get:chat.DelManager.decide)
  return _internal_decide();
}
inline void DelManager::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void DelManager::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.DelManager.decide)
}

// -------------------------------------------------------------------

// AddManager

// string u_name = 1;
inline void AddManager::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& AddManager::u_name() const {
  // @@protoc_insertion_point(field_get:chat.AddManager.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddManager::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddManager.u_name)
}
inline std::string* AddManager::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.AddManager.u_name)
  return _s;
}
inline const std::string& AddManager::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void AddManager::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddManager::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddManager::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.AddManager.u_name)
  return _impl_.u_name_.Release();
}
inline void AddManager::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddManager.u_name)
}

// string g_name = 2;
inline void AddManager::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& AddManager::g_name() const {
  // @@protoc_insertion_point(field_get:chat.AddManager.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddManager::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddManager.g_name)
}
inline std::string* AddManager::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.AddManager.g_name)
  return _s;
}
inline const std::string& AddManager::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void AddManager::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddManager::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddManager::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.AddManager.g_name)
  return _impl_.g_name_.Release();
}
inline void AddManager::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddManager.g_name)
}

// string username = 3;
inline void AddManager::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& AddManager::username() const {
  // @@protoc_insertion_point(field_get:chat.AddManager.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddManager::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddManager.username)
}
inline std::string* AddManager::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.AddManager.username)
  return _s;
}
inline const std::string& AddManager::_internal_username() const {
  return _impl_.username_.Get();
}
inline void AddManager::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* AddManager::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* AddManager::release_username() {
  // @@protoc_insertion_point(field_release:chat.AddManager.username)
  return _impl_.username_.Release();
}
inline void AddManager::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddManager.username)
}

// string msg = 4;
inline void AddManager::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& AddManager::msg() const {
  // @@protoc_insertion_point(field_get:chat.AddManager.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddManager::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddManager.msg)
}
inline std::string* AddManager::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.AddManager.msg)
  return _s;
}
inline const std::string& AddManager::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void AddManager::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* AddManager::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* AddManager::release_msg() {
  // @@protoc_insertion_point(field_release:chat.AddManager.msg)
  return _impl_.msg_.Release();
}
inline void AddManager::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddManager.msg)
}

// bool decide = 5;
inline void AddManager::clear_decide() {
  _impl_.decide_ = false;
}
inline bool AddManager::_internal_decide() const {
  return _impl_.decide_;
}
inline bool AddManager::decide() const {
  // @@protoc_insertion_point(field_get:chat.AddManager.decide)
  return _internal_decide();
}
inline void AddManager::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void AddManager::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.AddManager.decide)
}

// -------------------------------------------------------------------

// DisbandGroup

// string u_name = 1;
inline void DisbandGroup::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& DisbandGroup::u_name() const {
  // @@protoc_insertion_point(field_get:chat.DisbandGroup.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisbandGroup::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DisbandGroup.u_name)
}
inline std::string* DisbandGroup::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.DisbandGroup.u_name)
  return _s;
}
inline const std::string& DisbandGroup::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void DisbandGroup::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DisbandGroup::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DisbandGroup::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.DisbandGroup.u_name)
  return _impl_.u_name_.Release();
}
inline void DisbandGroup::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DisbandGroup.u_name)
}

// string g_name = 2;
inline void DisbandGroup::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& DisbandGroup::g_name() const {
  // @@protoc_insertion_point(field_get:chat.DisbandGroup.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisbandGroup::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DisbandGroup.g_name)
}
inline std::string* DisbandGroup::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.DisbandGroup.g_name)
  return _s;
}
inline const std::string& DisbandGroup::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void DisbandGroup::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DisbandGroup::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DisbandGroup::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.DisbandGroup.g_name)
  return _impl_.g_name_.Release();
}
inline void DisbandGroup::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DisbandGroup.g_name)
}

// -------------------------------------------------------------------

// DelMemberResponse

// string username = 1;
inline void DelMemberResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& DelMemberResponse::username() const {
  // @@protoc_insertion_point(field_get:chat.DelMemberResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMemberResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMemberResponse.username)
}
inline std::string* DelMemberResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.DelMemberResponse.username)
  return _s;
}
inline const std::string& DelMemberResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void DelMemberResponse::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMemberResponse::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMemberResponse::release_username() {
  // @@protoc_insertion_point(field_release:chat.DelMemberResponse.username)
  return _impl_.username_.Release();
}
inline void DelMemberResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMemberResponse.username)
}

// string u_name = 2;
inline void DelMemberResponse::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& DelMemberResponse::u_name() const {
  // @@protoc_insertion_point(field_get:chat.DelMemberResponse.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMemberResponse::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMemberResponse.u_name)
}
inline std::string* DelMemberResponse::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.DelMemberResponse.u_name)
  return _s;
}
inline const std::string& DelMemberResponse::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void DelMemberResponse::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMemberResponse::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMemberResponse::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.DelMemberResponse.u_name)
  return _impl_.u_name_.Release();
}
inline void DelMemberResponse::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMemberResponse.u_name)
}

// string g_name = 3;
inline void DelMemberResponse::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& DelMemberResponse::g_name() const {
  // @@protoc_insertion_point(field_get:chat.DelMemberResponse.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMemberResponse::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMemberResponse.g_name)
}
inline std::string* DelMemberResponse::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.DelMemberResponse.g_name)
  return _s;
}
inline const std::string& DelMemberResponse::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void DelMemberResponse::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMemberResponse::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMemberResponse::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.DelMemberResponse.g_name)
  return _impl_.g_name_.Release();
}
inline void DelMemberResponse::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMemberResponse.g_name)
}

// bool decide = 4;
inline void DelMemberResponse::clear_decide() {
  _impl_.decide_ = false;
}
inline bool DelMemberResponse::_internal_decide() const {
  return _impl_.decide_;
}
inline bool DelMemberResponse::decide() const {
  // @@protoc_insertion_point(field_get:chat.DelMemberResponse.decide)
  return _internal_decide();
}
inline void DelMemberResponse::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void DelMemberResponse::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.DelMemberResponse.decide)
}

// string msg = 5;
inline void DelMemberResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& DelMemberResponse::msg() const {
  // @@protoc_insertion_point(field_get:chat.DelMemberResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMemberResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMemberResponse.msg)
}
inline std::string* DelMemberResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.DelMemberResponse.msg)
  return _s;
}
inline const std::string& DelMemberResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void DelMemberResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMemberResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMemberResponse::release_msg() {
  // @@protoc_insertion_point(field_release:chat.DelMemberResponse.msg)
  return _impl_.msg_.Release();
}
inline void DelMemberResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMemberResponse.msg)
}

// string statue = 6;
inline void DelMemberResponse::clear_statue() {
  _impl_.statue_.ClearToEmpty();
}
inline const std::string& DelMemberResponse::statue() const {
  // @@protoc_insertion_point(field_get:chat.DelMemberResponse.statue)
  return _internal_statue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMemberResponse::set_statue(ArgT0&& arg0, ArgT... args) {
 
 _impl_.statue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMemberResponse.statue)
}
inline std::string* DelMemberResponse::mutable_statue() {
  std::string* _s = _internal_mutable_statue();
  // @@protoc_insertion_point(field_mutable:chat.DelMemberResponse.statue)
  return _s;
}
inline const std::string& DelMemberResponse::_internal_statue() const {
  return _impl_.statue_.Get();
}
inline void DelMemberResponse::_internal_set_statue(const std::string& value) {
  
  _impl_.statue_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMemberResponse::_internal_mutable_statue() {
  
  return _impl_.statue_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMemberResponse::release_statue() {
  // @@protoc_insertion_point(field_release:chat.DelMemberResponse.statue)
  return _impl_.statue_.Release();
}
inline void DelMemberResponse::set_allocated_statue(std::string* statue) {
  if (statue != nullptr) {
    
  } else {
    
  }
  _impl_.statue_.SetAllocated(statue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.statue_.IsDefault()) {
    _impl_.statue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMemberResponse.statue)
}

// -------------------------------------------------------------------

// DelMember

// string username = 1;
inline void DelMember::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& DelMember::username() const {
  // @@protoc_insertion_point(field_get:chat.DelMember.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMember::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMember.username)
}
inline std::string* DelMember::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.DelMember.username)
  return _s;
}
inline const std::string& DelMember::_internal_username() const {
  return _impl_.username_.Get();
}
inline void DelMember::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMember::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMember::release_username() {
  // @@protoc_insertion_point(field_release:chat.DelMember.username)
  return _impl_.username_.Release();
}
inline void DelMember::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMember.username)
}

// string u_name = 2;
inline void DelMember::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& DelMember::u_name() const {
  // @@protoc_insertion_point(field_get:chat.DelMember.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMember::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMember.u_name)
}
inline std::string* DelMember::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.DelMember.u_name)
  return _s;
}
inline const std::string& DelMember::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void DelMember::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMember::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMember::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.DelMember.u_name)
  return _impl_.u_name_.Release();
}
inline void DelMember::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMember.u_name)
}

// string g_name = 3;
inline void DelMember::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& DelMember::g_name() const {
  // @@protoc_insertion_point(field_get:chat.DelMember.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMember::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMember.g_name)
}
inline std::string* DelMember::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.DelMember.g_name)
  return _s;
}
inline const std::string& DelMember::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void DelMember::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMember::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMember::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.DelMember.g_name)
  return _impl_.g_name_.Release();
}
inline void DelMember::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMember.g_name)
}

// bool decide = 4;
inline void DelMember::clear_decide() {
  _impl_.decide_ = false;
}
inline bool DelMember::_internal_decide() const {
  return _impl_.decide_;
}
inline bool DelMember::decide() const {
  // @@protoc_insertion_point(field_get:chat.DelMember.decide)
  return _internal_decide();
}
inline void DelMember::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void DelMember::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.DelMember.decide)
}

// string msg = 5;
inline void DelMember::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& DelMember::msg() const {
  // @@protoc_insertion_point(field_get:chat.DelMember.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMember::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMember.msg)
}
inline std::string* DelMember::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.DelMember.msg)
  return _s;
}
inline const std::string& DelMember::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void DelMember::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMember::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMember::release_msg() {
  // @@protoc_insertion_point(field_release:chat.DelMember.msg)
  return _impl_.msg_.Release();
}
inline void DelMember::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMember.msg)
}

// string statue = 6;
inline void DelMember::clear_statue() {
  _impl_.statue_.ClearToEmpty();
}
inline const std::string& DelMember::statue() const {
  // @@protoc_insertion_point(field_get:chat.DelMember.statue)
  return _internal_statue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelMember::set_statue(ArgT0&& arg0, ArgT... args) {
 
 _impl_.statue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DelMember.statue)
}
inline std::string* DelMember::mutable_statue() {
  std::string* _s = _internal_mutable_statue();
  // @@protoc_insertion_point(field_mutable:chat.DelMember.statue)
  return _s;
}
inline const std::string& DelMember::_internal_statue() const {
  return _impl_.statue_.Get();
}
inline void DelMember::_internal_set_statue(const std::string& value) {
  
  _impl_.statue_.Set(value, GetArenaForAllocation());
}
inline std::string* DelMember::_internal_mutable_statue() {
  
  return _impl_.statue_.Mutable(GetArenaForAllocation());
}
inline std::string* DelMember::release_statue() {
  // @@protoc_insertion_point(field_release:chat.DelMember.statue)
  return _impl_.statue_.Release();
}
inline void DelMember::set_allocated_statue(std::string* statue) {
  if (statue != nullptr) {
    
  } else {
    
  }
  _impl_.statue_.SetAllocated(statue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.statue_.IsDefault()) {
    _impl_.statue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DelMember.statue)
}

// -------------------------------------------------------------------

// AddMemberResponse

// string username = 1;
inline void AddMemberResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& AddMemberResponse::username() const {
  // @@protoc_insertion_point(field_get:chat.AddMemberResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddMemberResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddMemberResponse.username)
}
inline std::string* AddMemberResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.AddMemberResponse.username)
  return _s;
}
inline const std::string& AddMemberResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void AddMemberResponse::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMemberResponse::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMemberResponse::release_username() {
  // @@protoc_insertion_point(field_release:chat.AddMemberResponse.username)
  return _impl_.username_.Release();
}
inline void AddMemberResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddMemberResponse.username)
}

// string u_name = 2;
inline void AddMemberResponse::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& AddMemberResponse::u_name() const {
  // @@protoc_insertion_point(field_get:chat.AddMemberResponse.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddMemberResponse::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddMemberResponse.u_name)
}
inline std::string* AddMemberResponse::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.AddMemberResponse.u_name)
  return _s;
}
inline const std::string& AddMemberResponse::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void AddMemberResponse::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMemberResponse::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMemberResponse::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.AddMemberResponse.u_name)
  return _impl_.u_name_.Release();
}
inline void AddMemberResponse::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddMemberResponse.u_name)
}

// string g_name = 3;
inline void AddMemberResponse::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& AddMemberResponse::g_name() const {
  // @@protoc_insertion_point(field_get:chat.AddMemberResponse.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddMemberResponse::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddMemberResponse.g_name)
}
inline std::string* AddMemberResponse::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.AddMemberResponse.g_name)
  return _s;
}
inline const std::string& AddMemberResponse::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void AddMemberResponse::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMemberResponse::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMemberResponse::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.AddMemberResponse.g_name)
  return _impl_.g_name_.Release();
}
inline void AddMemberResponse::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddMemberResponse.g_name)
}

// -------------------------------------------------------------------

// AddMember

// string username = 1;
inline void AddMember::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& AddMember::username() const {
  // @@protoc_insertion_point(field_get:chat.AddMember.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddMember::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddMember.username)
}
inline std::string* AddMember::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.AddMember.username)
  return _s;
}
inline const std::string& AddMember::_internal_username() const {
  return _impl_.username_.Get();
}
inline void AddMember::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMember::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMember::release_username() {
  // @@protoc_insertion_point(field_release:chat.AddMember.username)
  return _impl_.username_.Release();
}
inline void AddMember::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddMember.username)
}

// string u_name = 2;
inline void AddMember::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& AddMember::u_name() const {
  // @@protoc_insertion_point(field_get:chat.AddMember.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddMember::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddMember.u_name)
}
inline std::string* AddMember::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.AddMember.u_name)
  return _s;
}
inline const std::string& AddMember::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void AddMember::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMember::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMember::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.AddMember.u_name)
  return _impl_.u_name_.Release();
}
inline void AddMember::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddMember.u_name)
}

// string g_name = 3;
inline void AddMember::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& AddMember::g_name() const {
  // @@protoc_insertion_point(field_get:chat.AddMember.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddMember::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddMember.g_name)
}
inline std::string* AddMember::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.AddMember.g_name)
  return _s;
}
inline const std::string& AddMember::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void AddMember::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMember::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMember::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.AddMember.g_name)
  return _impl_.g_name_.Release();
}
inline void AddMember::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddMember.g_name)
}

// bool decide = 4;
inline void AddMember::clear_decide() {
  _impl_.decide_ = false;
}
inline bool AddMember::_internal_decide() const {
  return _impl_.decide_;
}
inline bool AddMember::decide() const {
  // @@protoc_insertion_point(field_get:chat.AddMember.decide)
  return _internal_decide();
}
inline void AddMember::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void AddMember::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.AddMember.decide)
}

// string msg = 5;
inline void AddMember::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& AddMember::msg() const {
  // @@protoc_insertion_point(field_get:chat.AddMember.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddMember::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddMember.msg)
}
inline std::string* AddMember::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.AddMember.msg)
  return _s;
}
inline const std::string& AddMember::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void AddMember::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMember::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMember::release_msg() {
  // @@protoc_insertion_point(field_release:chat.AddMember.msg)
  return _impl_.msg_.Release();
}
inline void AddMember::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddMember.msg)
}

// -------------------------------------------------------------------

// LeaveGroup

// string u_name = 1;
inline void LeaveGroup::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& LeaveGroup::u_name() const {
  // @@protoc_insertion_point(field_get:chat.LeaveGroup.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaveGroup::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LeaveGroup.u_name)
}
inline std::string* LeaveGroup::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.LeaveGroup.u_name)
  return _s;
}
inline const std::string& LeaveGroup::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void LeaveGroup::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaveGroup::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LeaveGroup::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.LeaveGroup.u_name)
  return _impl_.u_name_.Release();
}
inline void LeaveGroup::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LeaveGroup.u_name)
}

// string g_name = 2;
inline void LeaveGroup::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& LeaveGroup::g_name() const {
  // @@protoc_insertion_point(field_get:chat.LeaveGroup.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaveGroup::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LeaveGroup.g_name)
}
inline std::string* LeaveGroup::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.LeaveGroup.g_name)
  return _s;
}
inline const std::string& LeaveGroup::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void LeaveGroup::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaveGroup::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LeaveGroup::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.LeaveGroup.g_name)
  return _impl_.g_name_.Release();
}
inline void LeaveGroup::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LeaveGroup.g_name)
}

// bool decide = 3;
inline void LeaveGroup::clear_decide() {
  _impl_.decide_ = false;
}
inline bool LeaveGroup::_internal_decide() const {
  return _impl_.decide_;
}
inline bool LeaveGroup::decide() const {
  // @@protoc_insertion_point(field_get:chat.LeaveGroup.decide)
  return _internal_decide();
}
inline void LeaveGroup::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void LeaveGroup::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.LeaveGroup.decide)
}

// string statue = 4;
inline void LeaveGroup::clear_statue() {
  _impl_.statue_.ClearToEmpty();
}
inline const std::string& LeaveGroup::statue() const {
  // @@protoc_insertion_point(field_get:chat.LeaveGroup.statue)
  return _internal_statue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaveGroup::set_statue(ArgT0&& arg0, ArgT... args) {
 
 _impl_.statue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LeaveGroup.statue)
}
inline std::string* LeaveGroup::mutable_statue() {
  std::string* _s = _internal_mutable_statue();
  // @@protoc_insertion_point(field_mutable:chat.LeaveGroup.statue)
  return _s;
}
inline const std::string& LeaveGroup::_internal_statue() const {
  return _impl_.statue_.Get();
}
inline void LeaveGroup::_internal_set_statue(const std::string& value) {
  
  _impl_.statue_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaveGroup::_internal_mutable_statue() {
  
  return _impl_.statue_.Mutable(GetArenaForAllocation());
}
inline std::string* LeaveGroup::release_statue() {
  // @@protoc_insertion_point(field_release:chat.LeaveGroup.statue)
  return _impl_.statue_.Release();
}
inline void LeaveGroup::set_allocated_statue(std::string* statue) {
  if (statue != nullptr) {
    
  } else {
    
  }
  _impl_.statue_.SetAllocated(statue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.statue_.IsDefault()) {
    _impl_.statue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LeaveGroup.statue)
}

// -------------------------------------------------------------------

// GroupChatList

// repeated string msg = 1;
inline int GroupChatList::_internal_msg_size() const {
  return _impl_.msg_.size();
}
inline int GroupChatList::msg_size() const {
  return _internal_msg_size();
}
inline void GroupChatList::clear_msg() {
  _impl_.msg_.Clear();
}
inline std::string* GroupChatList::add_msg() {
  std::string* _s = _internal_add_msg();
  // @@protoc_insertion_point(field_add_mutable:chat.GroupChatList.msg)
  return _s;
}
inline const std::string& GroupChatList::_internal_msg(int index) const {
  return _impl_.msg_.Get(index);
}
inline const std::string& GroupChatList::msg(int index) const {
  // @@protoc_insertion_point(field_get:chat.GroupChatList.msg)
  return _internal_msg(index);
}
inline std::string* GroupChatList::mutable_msg(int index) {
  // @@protoc_insertion_point(field_mutable:chat.GroupChatList.msg)
  return _impl_.msg_.Mutable(index);
}
inline void GroupChatList::set_msg(int index, const std::string& value) {
  _impl_.msg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chat.GroupChatList.msg)
}
inline void GroupChatList::set_msg(int index, std::string&& value) {
  _impl_.msg_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chat.GroupChatList.msg)
}
inline void GroupChatList::set_msg(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.msg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chat.GroupChatList.msg)
}
inline void GroupChatList::set_msg(int index, const char* value, size_t size) {
  _impl_.msg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chat.GroupChatList.msg)
}
inline std::string* GroupChatList::_internal_add_msg() {
  return _impl_.msg_.Add();
}
inline void GroupChatList::add_msg(const std::string& value) {
  _impl_.msg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chat.GroupChatList.msg)
}
inline void GroupChatList::add_msg(std::string&& value) {
  _impl_.msg_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chat.GroupChatList.msg)
}
inline void GroupChatList::add_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.msg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chat.GroupChatList.msg)
}
inline void GroupChatList::add_msg(const char* value, size_t size) {
  _impl_.msg_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chat.GroupChatList.msg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GroupChatList::msg() const {
  // @@protoc_insertion_point(field_list:chat.GroupChatList.msg)
  return _impl_.msg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GroupChatList::mutable_msg() {
  // @@protoc_insertion_point(field_mutable_list:chat.GroupChatList.msg)
  return &_impl_.msg_;
}

// string u_name = 2;
inline void GroupChatList::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& GroupChatList::u_name() const {
  // @@protoc_insertion_point(field_get:chat.GroupChatList.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChatList::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupChatList.u_name)
}
inline std::string* GroupChatList::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.GroupChatList.u_name)
  return _s;
}
inline const std::string& GroupChatList::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void GroupChatList::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChatList::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChatList::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.GroupChatList.u_name)
  return _impl_.u_name_.Release();
}
inline void GroupChatList::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupChatList.u_name)
}

// string g_name = 3;
inline void GroupChatList::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& GroupChatList::g_name() const {
  // @@protoc_insertion_point(field_get:chat.GroupChatList.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChatList::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupChatList.g_name)
}
inline std::string* GroupChatList::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.GroupChatList.g_name)
  return _s;
}
inline const std::string& GroupChatList::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void GroupChatList::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChatList::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChatList::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.GroupChatList.g_name)
  return _impl_.g_name_.Release();
}
inline void GroupChatList::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupChatList.g_name)
}

// -------------------------------------------------------------------

// GroupChat

// string msg = 1;
inline void GroupChat::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& GroupChat::msg() const {
  // @@protoc_insertion_point(field_get:chat.GroupChat.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChat::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupChat.msg)
}
inline std::string* GroupChat::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.GroupChat.msg)
  return _s;
}
inline const std::string& GroupChat::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void GroupChat::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChat::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChat::release_msg() {
  // @@protoc_insertion_point(field_release:chat.GroupChat.msg)
  return _impl_.msg_.Release();
}
inline void GroupChat::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupChat.msg)
}

// string username = 2;
inline void GroupChat::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& GroupChat::username() const {
  // @@protoc_insertion_point(field_get:chat.GroupChat.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChat::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupChat.username)
}
inline std::string* GroupChat::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.GroupChat.username)
  return _s;
}
inline const std::string& GroupChat::_internal_username() const {
  return _impl_.username_.Get();
}
inline void GroupChat::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChat::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChat::release_username() {
  // @@protoc_insertion_point(field_release:chat.GroupChat.username)
  return _impl_.username_.Release();
}
inline void GroupChat::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupChat.username)
}

// string u_name = 3;
inline void GroupChat::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& GroupChat::u_name() const {
  // @@protoc_insertion_point(field_get:chat.GroupChat.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChat::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupChat.u_name)
}
inline std::string* GroupChat::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.GroupChat.u_name)
  return _s;
}
inline const std::string& GroupChat::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void GroupChat::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChat::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChat::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.GroupChat.u_name)
  return _impl_.u_name_.Release();
}
inline void GroupChat::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupChat.u_name)
}

// string g_name = 4;
inline void GroupChat::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& GroupChat::g_name() const {
  // @@protoc_insertion_point(field_get:chat.GroupChat.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChat::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupChat.g_name)
}
inline std::string* GroupChat::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.GroupChat.g_name)
  return _s;
}
inline const std::string& GroupChat::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void GroupChat::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChat::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChat::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.GroupChat.g_name)
  return _impl_.g_name_.Release();
}
inline void GroupChat::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupChat.g_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GroupMembers

// string u_name = 1;
inline void GroupMembers::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& GroupMembers::u_name() const {
  // @@protoc_insertion_point(field_get:chat.GroupMembers.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupMembers::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupMembers.u_name)
}
inline std::string* GroupMembers::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.GroupMembers.u_name)
  return _s;
}
inline const std::string& GroupMembers::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void GroupMembers::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupMembers::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupMembers::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.GroupMembers.u_name)
  return _impl_.u_name_.Release();
}
inline void GroupMembers::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupMembers.u_name)
}

// string g_name = 2;
inline void GroupMembers::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& GroupMembers::g_name() const {
  // @@protoc_insertion_point(field_get:chat.GroupMembers.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupMembers::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupMembers.g_name)
}
inline std::string* GroupMembers::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.GroupMembers.g_name)
  return _s;
}
inline const std::string& GroupMembers::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void GroupMembers::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupMembers::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupMembers::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.GroupMembers.g_name)
  return _impl_.g_name_.Release();
}
inline void GroupMembers::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupMembers.g_name)
}

// map<string, string> members = 3;
inline int GroupMembers::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int GroupMembers::members_size() const {
  return _internal_members_size();
}
inline void GroupMembers::clear_members() {
  _impl_.members_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GroupMembers::_internal_members() const {
  return _impl_.members_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GroupMembers::members() const {
  // @@protoc_insertion_point(field_map:chat.GroupMembers.members)
  return _internal_members();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GroupMembers::_internal_mutable_members() {
  return _impl_.members_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GroupMembers::mutable_members() {
  // @@protoc_insertion_point(field_mutable_map:chat.GroupMembers.members)
  return _internal_mutable_members();
}

// -------------------------------------------------------------------

// ChoiceGroup

// string u_name = 1;
inline void ChoiceGroup::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& ChoiceGroup::u_name() const {
  // @@protoc_insertion_point(field_get:chat.ChoiceGroup.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChoiceGroup::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChoiceGroup.u_name)
}
inline std::string* ChoiceGroup::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.ChoiceGroup.u_name)
  return _s;
}
inline const std::string& ChoiceGroup::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void ChoiceGroup::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChoiceGroup::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChoiceGroup::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.ChoiceGroup.u_name)
  return _impl_.u_name_.Release();
}
inline void ChoiceGroup::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChoiceGroup.u_name)
}

// string g_name = 2;
inline void ChoiceGroup::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& ChoiceGroup::g_name() const {
  // @@protoc_insertion_point(field_get:chat.ChoiceGroup.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChoiceGroup::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChoiceGroup.g_name)
}
inline std::string* ChoiceGroup::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.ChoiceGroup.g_name)
  return _s;
}
inline const std::string& ChoiceGroup::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void ChoiceGroup::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChoiceGroup::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChoiceGroup::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.ChoiceGroup.g_name)
  return _impl_.g_name_.Release();
}
inline void ChoiceGroup::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChoiceGroup.g_name)
}

// string statue = 3;
inline void ChoiceGroup::clear_statue() {
  _impl_.statue_.ClearToEmpty();
}
inline const std::string& ChoiceGroup::statue() const {
  // @@protoc_insertion_point(field_get:chat.ChoiceGroup.statue)
  return _internal_statue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChoiceGroup::set_statue(ArgT0&& arg0, ArgT... args) {
 
 _impl_.statue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChoiceGroup.statue)
}
inline std::string* ChoiceGroup::mutable_statue() {
  std::string* _s = _internal_mutable_statue();
  // @@protoc_insertion_point(field_mutable:chat.ChoiceGroup.statue)
  return _s;
}
inline const std::string& ChoiceGroup::_internal_statue() const {
  return _impl_.statue_.Get();
}
inline void ChoiceGroup::_internal_set_statue(const std::string& value) {
  
  _impl_.statue_.Set(value, GetArenaForAllocation());
}
inline std::string* ChoiceGroup::_internal_mutable_statue() {
  
  return _impl_.statue_.Mutable(GetArenaForAllocation());
}
inline std::string* ChoiceGroup::release_statue() {
  // @@protoc_insertion_point(field_release:chat.ChoiceGroup.statue)
  return _impl_.statue_.Release();
}
inline void ChoiceGroup::set_allocated_statue(std::string* statue) {
  if (statue != nullptr) {
    
  } else {
    
  }
  _impl_.statue_.SetAllocated(statue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.statue_.IsDefault()) {
    _impl_.statue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChoiceGroup.statue)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FindRequest

// map<string, bytes> response = 1;
inline int FindRequest::_internal_response_size() const {
  return _impl_.response_.size();
}
inline int FindRequest::response_size() const {
  return _internal_response_size();
}
inline void FindRequest::clear_response() {
  _impl_.response_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FindRequest::_internal_response() const {
  return _impl_.response_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FindRequest::response() const {
  // @@protoc_insertion_point(field_map:chat.FindRequest.response)
  return _internal_response();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FindRequest::_internal_mutable_response() {
  return _impl_.response_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FindRequest::mutable_response() {
  // @@protoc_insertion_point(field_mutable_map:chat.FindRequest.response)
  return _internal_mutable_response();
}

// -------------------------------------------------------------------

// GroupList

// string username = 1;
inline void GroupList::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& GroupList::username() const {
  // @@protoc_insertion_point(field_get:chat.GroupList.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupList::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupList.username)
}
inline std::string* GroupList::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.GroupList.username)
  return _s;
}
inline const std::string& GroupList::_internal_username() const {
  return _impl_.username_.Get();
}
inline void GroupList::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupList::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupList::release_username() {
  // @@protoc_insertion_point(field_release:chat.GroupList.username)
  return _impl_.username_.Release();
}
inline void GroupList::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupList.username)
}

// string time = 2;
inline void GroupList::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& GroupList::time() const {
  // @@protoc_insertion_point(field_get:chat.GroupList.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupList::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GroupList.time)
}
inline std::string* GroupList::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.GroupList.time)
  return _s;
}
inline const std::string& GroupList::_internal_time() const {
  return _impl_.time_.Get();
}
inline void GroupList::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupList::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupList::release_time() {
  // @@protoc_insertion_point(field_release:chat.GroupList.time)
  return _impl_.time_.Release();
}
inline void GroupList::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GroupList.time)
}

// repeated string groups = 3;
inline int GroupList::_internal_groups_size() const {
  return _impl_.groups_.size();
}
inline int GroupList::groups_size() const {
  return _internal_groups_size();
}
inline void GroupList::clear_groups() {
  _impl_.groups_.Clear();
}
inline std::string* GroupList::add_groups() {
  std::string* _s = _internal_add_groups();
  // @@protoc_insertion_point(field_add_mutable:chat.GroupList.groups)
  return _s;
}
inline const std::string& GroupList::_internal_groups(int index) const {
  return _impl_.groups_.Get(index);
}
inline const std::string& GroupList::groups(int index) const {
  // @@protoc_insertion_point(field_get:chat.GroupList.groups)
  return _internal_groups(index);
}
inline std::string* GroupList::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:chat.GroupList.groups)
  return _impl_.groups_.Mutable(index);
}
inline void GroupList::set_groups(int index, const std::string& value) {
  _impl_.groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chat.GroupList.groups)
}
inline void GroupList::set_groups(int index, std::string&& value) {
  _impl_.groups_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chat.GroupList.groups)
}
inline void GroupList::set_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chat.GroupList.groups)
}
inline void GroupList::set_groups(int index, const char* value, size_t size) {
  _impl_.groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chat.GroupList.groups)
}
inline std::string* GroupList::_internal_add_groups() {
  return _impl_.groups_.Add();
}
inline void GroupList::add_groups(const std::string& value) {
  _impl_.groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chat.GroupList.groups)
}
inline void GroupList::add_groups(std::string&& value) {
  _impl_.groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chat.GroupList.groups)
}
inline void GroupList::add_groups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chat.GroupList.groups)
}
inline void GroupList::add_groups(const char* value, size_t size) {
  _impl_.groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chat.GroupList.groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GroupList::groups() const {
  // @@protoc_insertion_point(field_list:chat.GroupList.groups)
  return _impl_.groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GroupList::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:chat.GroupList.groups)
  return &_impl_.groups_;
}

// -------------------------------------------------------------------

// JoinGroup

// string u_name = 1;
inline void JoinGroup::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& JoinGroup::u_name() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroup.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroup::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroup.u_name)
}
inline std::string* JoinGroup::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroup.u_name)
  return _s;
}
inline const std::string& JoinGroup::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void JoinGroup::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroup::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroup::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.JoinGroup.u_name)
  return _impl_.u_name_.Release();
}
inline void JoinGroup::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroup.u_name)
}

// string g_name = 2;
inline void JoinGroup::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& JoinGroup::g_name() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroup.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroup::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroup.g_name)
}
inline std::string* JoinGroup::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroup.g_name)
  return _s;
}
inline const std::string& JoinGroup::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void JoinGroup::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroup::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroup::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.JoinGroup.g_name)
  return _impl_.g_name_.Release();
}
inline void JoinGroup::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroup.g_name)
}

// string username = 3;
inline void JoinGroup::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& JoinGroup::username() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroup.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroup::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroup.username)
}
inline std::string* JoinGroup::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroup.username)
  return _s;
}
inline const std::string& JoinGroup::_internal_username() const {
  return _impl_.username_.Get();
}
inline void JoinGroup::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroup::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroup::release_username() {
  // @@protoc_insertion_point(field_release:chat.JoinGroup.username)
  return _impl_.username_.Release();
}
inline void JoinGroup::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroup.username)
}

// bool decide = 4;
inline void JoinGroup::clear_decide() {
  _impl_.decide_ = false;
}
inline bool JoinGroup::_internal_decide() const {
  return _impl_.decide_;
}
inline bool JoinGroup::decide() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroup.decide)
  return _internal_decide();
}
inline void JoinGroup::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void JoinGroup::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.JoinGroup.decide)
}

// string time = 5;
inline void JoinGroup::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& JoinGroup::time() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroup.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroup::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroup.time)
}
inline std::string* JoinGroup::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroup.time)
  return _s;
}
inline const std::string& JoinGroup::_internal_time() const {
  return _impl_.time_.Get();
}
inline void JoinGroup::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroup::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroup::release_time() {
  // @@protoc_insertion_point(field_release:chat.JoinGroup.time)
  return _impl_.time_.Release();
}
inline void JoinGroup::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroup.time)
}

// string msg = 6;
inline void JoinGroup::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& JoinGroup::msg() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroup.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroup::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroup.msg)
}
inline std::string* JoinGroup::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroup.msg)
  return _s;
}
inline const std::string& JoinGroup::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void JoinGroup::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroup::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroup::release_msg() {
  // @@protoc_insertion_point(field_release:chat.JoinGroup.msg)
  return _impl_.msg_.Release();
}
inline void JoinGroup::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroup.msg)
}

// -------------------------------------------------------------------

// JoinGroupResponse

// string u_name = 1;
inline void JoinGroupResponse::clear_u_name() {
  _impl_.u_name_.ClearToEmpty();
}
inline const std::string& JoinGroupResponse::u_name() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroupResponse.u_name)
  return _internal_u_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroupResponse::set_u_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.u_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroupResponse.u_name)
}
inline std::string* JoinGroupResponse::mutable_u_name() {
  std::string* _s = _internal_mutable_u_name();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroupResponse.u_name)
  return _s;
}
inline const std::string& JoinGroupResponse::_internal_u_name() const {
  return _impl_.u_name_.Get();
}
inline void JoinGroupResponse::_internal_set_u_name(const std::string& value) {
  
  _impl_.u_name_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::_internal_mutable_u_name() {
  
  return _impl_.u_name_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::release_u_name() {
  // @@protoc_insertion_point(field_release:chat.JoinGroupResponse.u_name)
  return _impl_.u_name_.Release();
}
inline void JoinGroupResponse::set_allocated_u_name(std::string* u_name) {
  if (u_name != nullptr) {
    
  } else {
    
  }
  _impl_.u_name_.SetAllocated(u_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_name_.IsDefault()) {
    _impl_.u_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroupResponse.u_name)
}

// string g_name = 2;
inline void JoinGroupResponse::clear_g_name() {
  _impl_.g_name_.ClearToEmpty();
}
inline const std::string& JoinGroupResponse::g_name() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroupResponse.g_name)
  return _internal_g_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroupResponse::set_g_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroupResponse.g_name)
}
inline std::string* JoinGroupResponse::mutable_g_name() {
  std::string* _s = _internal_mutable_g_name();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroupResponse.g_name)
  return _s;
}
inline const std::string& JoinGroupResponse::_internal_g_name() const {
  return _impl_.g_name_.Get();
}
inline void JoinGroupResponse::_internal_set_g_name(const std::string& value) {
  
  _impl_.g_name_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::_internal_mutable_g_name() {
  
  return _impl_.g_name_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::release_g_name() {
  // @@protoc_insertion_point(field_release:chat.JoinGroupResponse.g_name)
  return _impl_.g_name_.Release();
}
inline void JoinGroupResponse::set_allocated_g_name(std::string* g_name) {
  if (g_name != nullptr) {
    
  } else {
    
  }
  _impl_.g_name_.SetAllocated(g_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_name_.IsDefault()) {
    _impl_.g_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroupResponse.g_name)
}

// string username = 3;
inline void JoinGroupResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& JoinGroupResponse::username() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroupResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroupResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroupResponse.username)
}
inline std::string* JoinGroupResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroupResponse.username)
  return _s;
}
inline const std::string& JoinGroupResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void JoinGroupResponse::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::release_username() {
  // @@protoc_insertion_point(field_release:chat.JoinGroupResponse.username)
  return _impl_.username_.Release();
}
inline void JoinGroupResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroupResponse.username)
}

// bool decide = 4;
inline void JoinGroupResponse::clear_decide() {
  _impl_.decide_ = false;
}
inline bool JoinGroupResponse::_internal_decide() const {
  return _impl_.decide_;
}
inline bool JoinGroupResponse::decide() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroupResponse.decide)
  return _internal_decide();
}
inline void JoinGroupResponse::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void JoinGroupResponse::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.JoinGroupResponse.decide)
}

// string time = 5;
inline void JoinGroupResponse::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& JoinGroupResponse::time() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroupResponse.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroupResponse::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroupResponse.time)
}
inline std::string* JoinGroupResponse::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroupResponse.time)
  return _s;
}
inline const std::string& JoinGroupResponse::_internal_time() const {
  return _impl_.time_.Get();
}
inline void JoinGroupResponse::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::release_time() {
  // @@protoc_insertion_point(field_release:chat.JoinGroupResponse.time)
  return _impl_.time_.Release();
}
inline void JoinGroupResponse::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroupResponse.time)
}

// string msg = 6;
inline void JoinGroupResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& JoinGroupResponse::msg() const {
  // @@protoc_insertion_point(field_get:chat.JoinGroupResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGroupResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.JoinGroupResponse.msg)
}
inline std::string* JoinGroupResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.JoinGroupResponse.msg)
  return _s;
}
inline const std::string& JoinGroupResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void JoinGroupResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGroupResponse::release_msg() {
  // @@protoc_insertion_point(field_release:chat.JoinGroupResponse.msg)
  return _impl_.msg_.Release();
}
inline void JoinGroupResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.JoinGroupResponse.msg)
}

// -------------------------------------------------------------------

// AddGroup

// string username = 1;
inline void AddGroup::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& AddGroup::username() const {
  // @@protoc_insertion_point(field_get:chat.AddGroup.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddGroup::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddGroup.username)
}
inline std::string* AddGroup::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.AddGroup.username)
  return _s;
}
inline const std::string& AddGroup::_internal_username() const {
  return _impl_.username_.Get();
}
inline void AddGroup::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* AddGroup::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* AddGroup::release_username() {
  // @@protoc_insertion_point(field_release:chat.AddGroup.username)
  return _impl_.username_.Release();
}
inline void AddGroup::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddGroup.username)
}

// string group_name = 2;
inline void AddGroup::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
}
inline const std::string& AddGroup::group_name() const {
  // @@protoc_insertion_point(field_get:chat.AddGroup.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddGroup::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddGroup.group_name)
}
inline std::string* AddGroup::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:chat.AddGroup.group_name)
  return _s;
}
inline const std::string& AddGroup::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void AddGroup::_internal_set_group_name(const std::string& value) {
  
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddGroup::_internal_mutable_group_name() {
  
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddGroup::release_group_name() {
  // @@protoc_insertion_point(field_release:chat.AddGroup.group_name)
  return _impl_.group_name_.Release();
}
inline void AddGroup::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddGroup.group_name)
}

// string time = 3;
inline void AddGroup::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& AddGroup::time() const {
  // @@protoc_insertion_point(field_get:chat.AddGroup.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddGroup::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddGroup.time)
}
inline std::string* AddGroup::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.AddGroup.time)
  return _s;
}
inline const std::string& AddGroup::_internal_time() const {
  return _impl_.time_.Get();
}
inline void AddGroup::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* AddGroup::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* AddGroup::release_time() {
  // @@protoc_insertion_point(field_release:chat.AddGroup.time)
  return _impl_.time_.Release();
}
inline void AddGroup::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddGroup.time)
}

// string msg = 4;
inline void AddGroup::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& AddGroup::msg() const {
  // @@protoc_insertion_point(field_get:chat.AddGroup.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddGroup::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddGroup.msg)
}
inline std::string* AddGroup::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.AddGroup.msg)
  return _s;
}
inline const std::string& AddGroup::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void AddGroup::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* AddGroup::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* AddGroup::release_msg() {
  // @@protoc_insertion_point(field_release:chat.AddGroup.msg)
  return _impl_.msg_.Release();
}
inline void AddGroup::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddGroup.msg)
}

// bool success = 5;
inline void AddGroup::clear_success() {
  _impl_.success_ = false;
}
inline bool AddGroup::_internal_success() const {
  return _impl_.success_;
}
inline bool AddGroup::success() const {
  // @@protoc_insertion_point(field_get:chat.AddGroup.success)
  return _internal_success();
}
inline void AddGroup::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void AddGroup::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:chat.AddGroup.success)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LookFileRequest

// string username = 1;
inline void LookFileRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LookFileRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.LookFileRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookFileRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LookFileRequest.username)
}
inline std::string* LookFileRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.LookFileRequest.username)
  return _s;
}
inline const std::string& LookFileRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LookFileRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LookFileRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LookFileRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.LookFileRequest.username)
  return _impl_.username_.Release();
}
inline void LookFileRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LookFileRequest.username)
}

// map<string, .chat.FileList> result = 2;
inline int LookFileRequest::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int LookFileRequest::result_size() const {
  return _internal_result_size();
}
inline void LookFileRequest::clear_result() {
  _impl_.result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >&
LookFileRequest::_internal_result() const {
  return _impl_.result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >&
LookFileRequest::result() const {
  // @@protoc_insertion_point(field_map:chat.LookFileRequest.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >*
LookFileRequest::_internal_mutable_result() {
  return _impl_.result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::chat::FileList >*
LookFileRequest::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:chat.LookFileRequest.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// FileList

// repeated string files = 1;
inline int FileList::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int FileList::files_size() const {
  return _internal_files_size();
}
inline void FileList::clear_files() {
  _impl_.files_.Clear();
}
inline std::string* FileList::add_files() {
  std::string* _s = _internal_add_files();
  // @@protoc_insertion_point(field_add_mutable:chat.FileList.files)
  return _s;
}
inline const std::string& FileList::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const std::string& FileList::files(int index) const {
  // @@protoc_insertion_point(field_get:chat.FileList.files)
  return _internal_files(index);
}
inline std::string* FileList::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:chat.FileList.files)
  return _impl_.files_.Mutable(index);
}
inline void FileList::set_files(int index, const std::string& value) {
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chat.FileList.files)
}
inline void FileList::set_files(int index, std::string&& value) {
  _impl_.files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chat.FileList.files)
}
inline void FileList::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chat.FileList.files)
}
inline void FileList::set_files(int index, const char* value, size_t size) {
  _impl_.files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chat.FileList.files)
}
inline std::string* FileList::_internal_add_files() {
  return _impl_.files_.Add();
}
inline void FileList::add_files(const std::string& value) {
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chat.FileList.files)
}
inline void FileList::add_files(std::string&& value) {
  _impl_.files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chat.FileList.files)
}
inline void FileList::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chat.FileList.files)
}
inline void FileList::add_files(const char* value, size_t size) {
  _impl_.files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chat.FileList.files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FileList::files() const {
  // @@protoc_insertion_point(field_list:chat.FileList.files)
  return _impl_.files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FileList::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:chat.FileList.files)
  return &_impl_.files_;
}

// -------------------------------------------------------------------

// SendFile

// string name = 1;
inline void SendFile::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SendFile::name() const {
  // @@protoc_insertion_point(field_get:chat.SendFile.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFile::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFile.name)
}
inline std::string* SendFile::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.SendFile.name)
  return _s;
}
inline const std::string& SendFile::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SendFile::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFile::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFile::release_name() {
  // @@protoc_insertion_point(field_release:chat.SendFile.name)
  return _impl_.name_.Release();
}
inline void SendFile::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFile.name)
}

// string file_name = 2;
inline void SendFile::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& SendFile::file_name() const {
  // @@protoc_insertion_point(field_get:chat.SendFile.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFile::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFile.file_name)
}
inline std::string* SendFile::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:chat.SendFile.file_name)
  return _s;
}
inline const std::string& SendFile::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void SendFile::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFile::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFile::release_file_name() {
  // @@protoc_insertion_point(field_release:chat.SendFile.file_name)
  return _impl_.file_name_.Release();
}
inline void SendFile::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFile.file_name)
}

// string time = 3;
inline void SendFile::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& SendFile::time() const {
  // @@protoc_insertion_point(field_get:chat.SendFile.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendFile::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.SendFile.time)
}
inline std::string* SendFile::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.SendFile.time)
  return _s;
}
inline const std::string& SendFile::_internal_time() const {
  return _impl_.time_.Get();
}
inline void SendFile::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* SendFile::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* SendFile::release_time() {
  // @@protoc_insertion_point(field_release:chat.SendFile.time)
  return _impl_.time_.Release();
}
inline void SendFile::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.SendFile.time)
}

// -------------------------------------------------------------------

// RecvFile

// string name = 1;
inline void RecvFile::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RecvFile::name() const {
  // @@protoc_insertion_point(field_get:chat.RecvFile.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFile::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFile.name)
}
inline std::string* RecvFile::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.RecvFile.name)
  return _s;
}
inline const std::string& RecvFile::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RecvFile::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFile::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFile::release_name() {
  // @@protoc_insertion_point(field_release:chat.RecvFile.name)
  return _impl_.name_.Release();
}
inline void RecvFile::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFile.name)
}

// string file_name = 2;
inline void RecvFile::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& RecvFile::file_name() const {
  // @@protoc_insertion_point(field_get:chat.RecvFile.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFile::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFile.file_name)
}
inline std::string* RecvFile::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:chat.RecvFile.file_name)
  return _s;
}
inline const std::string& RecvFile::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void RecvFile::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFile::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFile::release_file_name() {
  // @@protoc_insertion_point(field_release:chat.RecvFile.file_name)
  return _impl_.file_name_.Release();
}
inline void RecvFile::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFile.file_name)
}

// string time = 3;
inline void RecvFile::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& RecvFile::time() const {
  // @@protoc_insertion_point(field_get:chat.RecvFile.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecvFile::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.RecvFile.time)
}
inline std::string* RecvFile::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.RecvFile.time)
  return _s;
}
inline const std::string& RecvFile::_internal_time() const {
  return _impl_.time_.Get();
}
inline void RecvFile::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* RecvFile::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* RecvFile::release_time() {
  // @@protoc_insertion_point(field_release:chat.RecvFile.time)
  return _impl_.time_.Release();
}
inline void RecvFile::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.RecvFile.time)
}

// -------------------------------------------------------------------

// BlockFriend

// string name = 1;
inline void BlockFriend::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BlockFriend::name() const {
  // @@protoc_insertion_point(field_get:chat.BlockFriend.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockFriend::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.BlockFriend.name)
}
inline std::string* BlockFriend::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.BlockFriend.name)
  return _s;
}
inline const std::string& BlockFriend::_internal_name() const {
  return _impl_.name_.Get();
}
inline void BlockFriend::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockFriend::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockFriend::release_name() {
  // @@protoc_insertion_point(field_release:chat.BlockFriend.name)
  return _impl_.name_.Release();
}
inline void BlockFriend::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.BlockFriend.name)
}

// -------------------------------------------------------------------

// OfflineMSG

// repeated string msg = 1;
inline int OfflineMSG::_internal_msg_size() const {
  return _impl_.msg_.size();
}
inline int OfflineMSG::msg_size() const {
  return _internal_msg_size();
}
inline void OfflineMSG::clear_msg() {
  _impl_.msg_.Clear();
}
inline std::string* OfflineMSG::add_msg() {
  std::string* _s = _internal_add_msg();
  // @@protoc_insertion_point(field_add_mutable:chat.OfflineMSG.msg)
  return _s;
}
inline const std::string& OfflineMSG::_internal_msg(int index) const {
  return _impl_.msg_.Get(index);
}
inline const std::string& OfflineMSG::msg(int index) const {
  // @@protoc_insertion_point(field_get:chat.OfflineMSG.msg)
  return _internal_msg(index);
}
inline std::string* OfflineMSG::mutable_msg(int index) {
  // @@protoc_insertion_point(field_mutable:chat.OfflineMSG.msg)
  return _impl_.msg_.Mutable(index);
}
inline void OfflineMSG::set_msg(int index, const std::string& value) {
  _impl_.msg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chat.OfflineMSG.msg)
}
inline void OfflineMSG::set_msg(int index, std::string&& value) {
  _impl_.msg_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chat.OfflineMSG.msg)
}
inline void OfflineMSG::set_msg(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.msg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chat.OfflineMSG.msg)
}
inline void OfflineMSG::set_msg(int index, const char* value, size_t size) {
  _impl_.msg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chat.OfflineMSG.msg)
}
inline std::string* OfflineMSG::_internal_add_msg() {
  return _impl_.msg_.Add();
}
inline void OfflineMSG::add_msg(const std::string& value) {
  _impl_.msg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chat.OfflineMSG.msg)
}
inline void OfflineMSG::add_msg(std::string&& value) {
  _impl_.msg_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chat.OfflineMSG.msg)
}
inline void OfflineMSG::add_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.msg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chat.OfflineMSG.msg)
}
inline void OfflineMSG::add_msg(const char* value, size_t size) {
  _impl_.msg_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chat.OfflineMSG.msg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OfflineMSG::msg() const {
  // @@protoc_insertion_point(field_list:chat.OfflineMSG.msg)
  return _impl_.msg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OfflineMSG::mutable_msg() {
  // @@protoc_insertion_point(field_mutable_list:chat.OfflineMSG.msg)
  return &_impl_.msg_;
}

// string name = 2;
inline void OfflineMSG::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& OfflineMSG::name() const {
  // @@protoc_insertion_point(field_get:chat.OfflineMSG.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfflineMSG::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.OfflineMSG.name)
}
inline std::string* OfflineMSG::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.OfflineMSG.name)
  return _s;
}
inline const std::string& OfflineMSG::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OfflineMSG::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OfflineMSG::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OfflineMSG::release_name() {
  // @@protoc_insertion_point(field_release:chat.OfflineMSG.name)
  return _impl_.name_.Release();
}
inline void OfflineMSG::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.OfflineMSG.name)
}

// string username = 3;
inline void OfflineMSG::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& OfflineMSG::username() const {
  // @@protoc_insertion_point(field_get:chat.OfflineMSG.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfflineMSG::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.OfflineMSG.username)
}
inline std::string* OfflineMSG::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.OfflineMSG.username)
  return _s;
}
inline const std::string& OfflineMSG::_internal_username() const {
  return _impl_.username_.Get();
}
inline void OfflineMSG::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* OfflineMSG::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* OfflineMSG::release_username() {
  // @@protoc_insertion_point(field_release:chat.OfflineMSG.username)
  return _impl_.username_.Release();
}
inline void OfflineMSG::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.OfflineMSG.username)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UserRequest

// string username = 1;
inline void UserRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.UserRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.UserRequest.username)
}
inline std::string* UserRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.UserRequest.username)
  return _s;
}
inline const std::string& UserRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.UserRequest.username)
  return _impl_.username_.Release();
}
inline void UserRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.UserRequest.username)
}

// map<string, string> result = 3;
inline int UserRequest::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int UserRequest::result_size() const {
  return _internal_result_size();
}
inline void UserRequest::clear_result() {
  _impl_.result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UserRequest::_internal_result() const {
  return _impl_.result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UserRequest::result() const {
  // @@protoc_insertion_point(field_map:chat.UserRequest.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UserRequest::_internal_mutable_result() {
  return _impl_.result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UserRequest::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:chat.UserRequest.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// Login

// bool login = 2;
inline void Login::clear_login() {
  _impl_.login_ = false;
}
inline bool Login::_internal_login() const {
  return _impl_.login_;
}
inline bool Login::login() const {
  // @@protoc_insertion_point(field_get:chat.Login.login)
  return _internal_login();
}
inline void Login::_internal_set_login(bool value) {
  
  _impl_.login_ = value;
}
inline void Login::set_login(bool value) {
  _internal_set_login(value);
  // @@protoc_insertion_point(field_set:chat.Login.login)
}

// string username = 1;
inline void Login::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:chat.Login.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.Login.username)
}
inline std::string* Login::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.Login.username)
  return _s;
}
inline const std::string& Login::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Login::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Login::release_username() {
  // @@protoc_insertion_point(field_release:chat.Login.username)
  return _impl_.username_.Release();
}
inline void Login::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.Login.username)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoginResponse

// string username = 1;
inline void LoginResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginResponse::username() const {
  // @@protoc_insertion_point(field_get:chat.LoginResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LoginResponse.username)
}
inline std::string* LoginResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.LoginResponse.username)
  return _s;
}
inline const std::string& LoginResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginResponse::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_username() {
  // @@protoc_insertion_point(field_release:chat.LoginResponse.username)
  return _impl_.username_.Release();
}
inline void LoginResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LoginResponse.username)
}

// map<string, string> result = 2;
inline int LoginResponse::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int LoginResponse::result_size() const {
  return _internal_result_size();
}
inline void LoginResponse::clear_result() {
  _impl_.result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoginResponse::_internal_result() const {
  return _impl_.result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoginResponse::result() const {
  // @@protoc_insertion_point(field_map:chat.LoginResponse.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoginResponse::_internal_mutable_result() {
  return _impl_.result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoginResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:chat.LoginResponse.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// DeleteFriendResponse

// bool result = 1;
inline void DeleteFriendResponse::clear_result() {
  _impl_.result_ = false;
}
inline bool DeleteFriendResponse::_internal_result() const {
  return _impl_.result_;
}
inline bool DeleteFriendResponse::result() const {
  // @@protoc_insertion_point(field_get:chat.DeleteFriendResponse.result)
  return _internal_result();
}
inline void DeleteFriendResponse::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void DeleteFriendResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:chat.DeleteFriendResponse.result)
}

// string username = 2;
inline void DeleteFriendResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& DeleteFriendResponse::username() const {
  // @@protoc_insertion_point(field_get:chat.DeleteFriendResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFriendResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DeleteFriendResponse.username)
}
inline std::string* DeleteFriendResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat.DeleteFriendResponse.username)
  return _s;
}
inline const std::string& DeleteFriendResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void DeleteFriendResponse::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFriendResponse::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFriendResponse::release_username() {
  // @@protoc_insertion_point(field_release:chat.DeleteFriendResponse.username)
  return _impl_.username_.Release();
}
inline void DeleteFriendResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DeleteFriendResponse.username)
}

// -------------------------------------------------------------------

// DeleteFriendRequest

// string from_name = 1;
inline void DeleteFriendRequest::clear_from_name() {
  _impl_.from_name_.ClearToEmpty();
}
inline const std::string& DeleteFriendRequest::from_name() const {
  // @@protoc_insertion_point(field_get:chat.DeleteFriendRequest.from_name)
  return _internal_from_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFriendRequest::set_from_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DeleteFriendRequest.from_name)
}
inline std::string* DeleteFriendRequest::mutable_from_name() {
  std::string* _s = _internal_mutable_from_name();
  // @@protoc_insertion_point(field_mutable:chat.DeleteFriendRequest.from_name)
  return _s;
}
inline const std::string& DeleteFriendRequest::_internal_from_name() const {
  return _impl_.from_name_.Get();
}
inline void DeleteFriendRequest::_internal_set_from_name(const std::string& value) {
  
  _impl_.from_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFriendRequest::_internal_mutable_from_name() {
  
  return _impl_.from_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFriendRequest::release_from_name() {
  // @@protoc_insertion_point(field_release:chat.DeleteFriendRequest.from_name)
  return _impl_.from_name_.Release();
}
inline void DeleteFriendRequest::set_allocated_from_name(std::string* from_name) {
  if (from_name != nullptr) {
    
  } else {
    
  }
  _impl_.from_name_.SetAllocated(from_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_name_.IsDefault()) {
    _impl_.from_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DeleteFriendRequest.from_name)
}

// string to_name = 2;
inline void DeleteFriendRequest::clear_to_name() {
  _impl_.to_name_.ClearToEmpty();
}
inline const std::string& DeleteFriendRequest::to_name() const {
  // @@protoc_insertion_point(field_get:chat.DeleteFriendRequest.to_name)
  return _internal_to_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFriendRequest::set_to_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DeleteFriendRequest.to_name)
}
inline std::string* DeleteFriendRequest::mutable_to_name() {
  std::string* _s = _internal_mutable_to_name();
  // @@protoc_insertion_point(field_mutable:chat.DeleteFriendRequest.to_name)
  return _s;
}
inline const std::string& DeleteFriendRequest::_internal_to_name() const {
  return _impl_.to_name_.Get();
}
inline void DeleteFriendRequest::_internal_set_to_name(const std::string& value) {
  
  _impl_.to_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFriendRequest::_internal_mutable_to_name() {
  
  return _impl_.to_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFriendRequest::release_to_name() {
  // @@protoc_insertion_point(field_release:chat.DeleteFriendRequest.to_name)
  return _impl_.to_name_.Release();
}
inline void DeleteFriendRequest::set_allocated_to_name(std::string* to_name) {
  if (to_name != nullptr) {
    
  } else {
    
  }
  _impl_.to_name_.SetAllocated(to_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_name_.IsDefault()) {
    _impl_.to_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DeleteFriendRequest.to_name)
}

// string time = 3;
inline void DeleteFriendRequest::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& DeleteFriendRequest::time() const {
  // @@protoc_insertion_point(field_get:chat.DeleteFriendRequest.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFriendRequest::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.DeleteFriendRequest.time)
}
inline std::string* DeleteFriendRequest::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.DeleteFriendRequest.time)
  return _s;
}
inline const std::string& DeleteFriendRequest::_internal_time() const {
  return _impl_.time_.Get();
}
inline void DeleteFriendRequest::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFriendRequest::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFriendRequest::release_time() {
  // @@protoc_insertion_point(field_release:chat.DeleteFriendRequest.time)
  return _impl_.time_.Release();
}
inline void DeleteFriendRequest::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.DeleteFriendRequest.time)
}

// -------------------------------------------------------------------

// AddFriendRequest

// string from_username = 1;
inline void AddFriendRequest::clear_from_username() {
  _impl_.from_username_.ClearToEmpty();
}
inline const std::string& AddFriendRequest::from_username() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendRequest.from_username)
  return _internal_from_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendRequest::set_from_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddFriendRequest.from_username)
}
inline std::string* AddFriendRequest::mutable_from_username() {
  std::string* _s = _internal_mutable_from_username();
  // @@protoc_insertion_point(field_mutable:chat.AddFriendRequest.from_username)
  return _s;
}
inline const std::string& AddFriendRequest::_internal_from_username() const {
  return _impl_.from_username_.Get();
}
inline void AddFriendRequest::_internal_set_from_username(const std::string& value) {
  
  _impl_.from_username_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendRequest::_internal_mutable_from_username() {
  
  return _impl_.from_username_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendRequest::release_from_username() {
  // @@protoc_insertion_point(field_release:chat.AddFriendRequest.from_username)
  return _impl_.from_username_.Release();
}
inline void AddFriendRequest::set_allocated_from_username(std::string* from_username) {
  if (from_username != nullptr) {
    
  } else {
    
  }
  _impl_.from_username_.SetAllocated(from_username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_username_.IsDefault()) {
    _impl_.from_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddFriendRequest.from_username)
}

// string to_username = 2;
inline void AddFriendRequest::clear_to_username() {
  _impl_.to_username_.ClearToEmpty();
}
inline const std::string& AddFriendRequest::to_username() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendRequest.to_username)
  return _internal_to_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendRequest::set_to_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddFriendRequest.to_username)
}
inline std::string* AddFriendRequest::mutable_to_username() {
  std::string* _s = _internal_mutable_to_username();
  // @@protoc_insertion_point(field_mutable:chat.AddFriendRequest.to_username)
  return _s;
}
inline const std::string& AddFriendRequest::_internal_to_username() const {
  return _impl_.to_username_.Get();
}
inline void AddFriendRequest::_internal_set_to_username(const std::string& value) {
  
  _impl_.to_username_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendRequest::_internal_mutable_to_username() {
  
  return _impl_.to_username_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendRequest::release_to_username() {
  // @@protoc_insertion_point(field_release:chat.AddFriendRequest.to_username)
  return _impl_.to_username_.Release();
}
inline void AddFriendRequest::set_allocated_to_username(std::string* to_username) {
  if (to_username != nullptr) {
    
  } else {
    
  }
  _impl_.to_username_.SetAllocated(to_username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_username_.IsDefault()) {
    _impl_.to_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddFriendRequest.to_username)
}

// string time = 3;
inline void AddFriendRequest::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& AddFriendRequest::time() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendRequest.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendRequest::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddFriendRequest.time)
}
inline std::string* AddFriendRequest::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.AddFriendRequest.time)
  return _s;
}
inline const std::string& AddFriendRequest::_internal_time() const {
  return _impl_.time_.Get();
}
inline void AddFriendRequest::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendRequest::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendRequest::release_time() {
  // @@protoc_insertion_point(field_release:chat.AddFriendRequest.time)
  return _impl_.time_.Release();
}
inline void AddFriendRequest::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddFriendRequest.time)
}

// -------------------------------------------------------------------

// AddFriendResponse

// bool decide = 1;
inline void AddFriendResponse::clear_decide() {
  _impl_.decide_ = false;
}
inline bool AddFriendResponse::_internal_decide() const {
  return _impl_.decide_;
}
inline bool AddFriendResponse::decide() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendResponse.decide)
  return _internal_decide();
}
inline void AddFriendResponse::_internal_set_decide(bool value) {
  
  _impl_.decide_ = value;
}
inline void AddFriendResponse::set_decide(bool value) {
  _internal_set_decide(value);
  // @@protoc_insertion_point(field_set:chat.AddFriendResponse.decide)
}

// string from_name = 2;
inline void AddFriendResponse::clear_from_name() {
  _impl_.from_name_.ClearToEmpty();
}
inline const std::string& AddFriendResponse::from_name() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendResponse.from_name)
  return _internal_from_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendResponse::set_from_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddFriendResponse.from_name)
}
inline std::string* AddFriendResponse::mutable_from_name() {
  std::string* _s = _internal_mutable_from_name();
  // @@protoc_insertion_point(field_mutable:chat.AddFriendResponse.from_name)
  return _s;
}
inline const std::string& AddFriendResponse::_internal_from_name() const {
  return _impl_.from_name_.Get();
}
inline void AddFriendResponse::_internal_set_from_name(const std::string& value) {
  
  _impl_.from_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendResponse::_internal_mutable_from_name() {
  
  return _impl_.from_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendResponse::release_from_name() {
  // @@protoc_insertion_point(field_release:chat.AddFriendResponse.from_name)
  return _impl_.from_name_.Release();
}
inline void AddFriendResponse::set_allocated_from_name(std::string* from_name) {
  if (from_name != nullptr) {
    
  } else {
    
  }
  _impl_.from_name_.SetAllocated(from_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_name_.IsDefault()) {
    _impl_.from_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddFriendResponse.from_name)
}

// string to_name = 3;
inline void AddFriendResponse::clear_to_name() {
  _impl_.to_name_.ClearToEmpty();
}
inline const std::string& AddFriendResponse::to_name() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendResponse.to_name)
  return _internal_to_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendResponse::set_to_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddFriendResponse.to_name)
}
inline std::string* AddFriendResponse::mutable_to_name() {
  std::string* _s = _internal_mutable_to_name();
  // @@protoc_insertion_point(field_mutable:chat.AddFriendResponse.to_name)
  return _s;
}
inline const std::string& AddFriendResponse::_internal_to_name() const {
  return _impl_.to_name_.Get();
}
inline void AddFriendResponse::_internal_set_to_name(const std::string& value) {
  
  _impl_.to_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendResponse::_internal_mutable_to_name() {
  
  return _impl_.to_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendResponse::release_to_name() {
  // @@protoc_insertion_point(field_release:chat.AddFriendResponse.to_name)
  return _impl_.to_name_.Release();
}
inline void AddFriendResponse::set_allocated_to_name(std::string* to_name) {
  if (to_name != nullptr) {
    
  } else {
    
  }
  _impl_.to_name_.SetAllocated(to_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_name_.IsDefault()) {
    _impl_.to_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddFriendResponse.to_name)
}

// string msg = 4;
inline void AddFriendResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& AddFriendResponse::msg() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddFriendResponse.msg)
}
inline std::string* AddFriendResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.AddFriendResponse.msg)
  return _s;
}
inline const std::string& AddFriendResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void AddFriendResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendResponse::release_msg() {
  // @@protoc_insertion_point(field_release:chat.AddFriendResponse.msg)
  return _impl_.msg_.Release();
}
inline void AddFriendResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddFriendResponse.msg)
}

// string time = 5;
inline void AddFriendResponse::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& AddFriendResponse::time() const {
  // @@protoc_insertion_point(field_get:chat.AddFriendResponse.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendResponse::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.AddFriendResponse.time)
}
inline std::string* AddFriendResponse::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.AddFriendResponse.time)
  return _s;
}
inline const std::string& AddFriendResponse::_internal_time() const {
  return _impl_.time_.Get();
}
inline void AddFriendResponse::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendResponse::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendResponse::release_time() {
  // @@protoc_insertion_point(field_release:chat.AddFriendResponse.time)
  return _impl_.time_.Release();
}
inline void AddFriendResponse::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.AddFriendResponse.time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FriendLists

// map<string, bool> friends = 1;
inline int FriendLists::_internal_friends_size() const {
  return _impl_.friends_.size();
}
inline int FriendLists::friends_size() const {
  return _internal_friends_size();
}
inline void FriendLists::clear_friends() {
  _impl_.friends_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
FriendLists::_internal_friends() const {
  return _impl_.friends_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
FriendLists::friends() const {
  // @@protoc_insertion_point(field_map:chat.FriendLists.friends)
  return _internal_friends();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
FriendLists::_internal_mutable_friends() {
  return _impl_.friends_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
FriendLists::mutable_friends() {
  // @@protoc_insertion_point(field_mutable_map:chat.FriendLists.friends)
  return _internal_mutable_friends();
}

// string name = 2;
inline void FriendLists::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FriendLists::name() const {
  // @@protoc_insertion_point(field_get:chat.FriendLists.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendLists::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.FriendLists.name)
}
inline std::string* FriendLists::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chat.FriendLists.name)
  return _s;
}
inline const std::string& FriendLists::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FriendLists::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendLists::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendLists::release_name() {
  // @@protoc_insertion_point(field_release:chat.FriendLists.name)
  return _impl_.name_.Release();
}
inline void FriendLists::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.FriendLists.name)
}

// -------------------------------------------------------------------

// FriendChatMessage

// string from_name = 1;
inline void FriendChatMessage::clear_from_name() {
  _impl_.from_name_.ClearToEmpty();
}
inline const std::string& FriendChatMessage::from_name() const {
  // @@protoc_insertion_point(field_get:chat.FriendChatMessage.from_name)
  return _internal_from_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendChatMessage::set_from_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.FriendChatMessage.from_name)
}
inline std::string* FriendChatMessage::mutable_from_name() {
  std::string* _s = _internal_mutable_from_name();
  // @@protoc_insertion_point(field_mutable:chat.FriendChatMessage.from_name)
  return _s;
}
inline const std::string& FriendChatMessage::_internal_from_name() const {
  return _impl_.from_name_.Get();
}
inline void FriendChatMessage::_internal_set_from_name(const std::string& value) {
  
  _impl_.from_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendChatMessage::_internal_mutable_from_name() {
  
  return _impl_.from_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendChatMessage::release_from_name() {
  // @@protoc_insertion_point(field_release:chat.FriendChatMessage.from_name)
  return _impl_.from_name_.Release();
}
inline void FriendChatMessage::set_allocated_from_name(std::string* from_name) {
  if (from_name != nullptr) {
    
  } else {
    
  }
  _impl_.from_name_.SetAllocated(from_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_name_.IsDefault()) {
    _impl_.from_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.FriendChatMessage.from_name)
}

// string to_name = 2;
inline void FriendChatMessage::clear_to_name() {
  _impl_.to_name_.ClearToEmpty();
}
inline const std::string& FriendChatMessage::to_name() const {
  // @@protoc_insertion_point(field_get:chat.FriendChatMessage.to_name)
  return _internal_to_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendChatMessage::set_to_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.FriendChatMessage.to_name)
}
inline std::string* FriendChatMessage::mutable_to_name() {
  std::string* _s = _internal_mutable_to_name();
  // @@protoc_insertion_point(field_mutable:chat.FriendChatMessage.to_name)
  return _s;
}
inline const std::string& FriendChatMessage::_internal_to_name() const {
  return _impl_.to_name_.Get();
}
inline void FriendChatMessage::_internal_set_to_name(const std::string& value) {
  
  _impl_.to_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendChatMessage::_internal_mutable_to_name() {
  
  return _impl_.to_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendChatMessage::release_to_name() {
  // @@protoc_insertion_point(field_release:chat.FriendChatMessage.to_name)
  return _impl_.to_name_.Release();
}
inline void FriendChatMessage::set_allocated_to_name(std::string* to_name) {
  if (to_name != nullptr) {
    
  } else {
    
  }
  _impl_.to_name_.SetAllocated(to_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_name_.IsDefault()) {
    _impl_.to_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.FriendChatMessage.to_name)
}

// string message = 3;
inline void FriendChatMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& FriendChatMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.FriendChatMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendChatMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.FriendChatMessage.message)
}
inline std::string* FriendChatMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:chat.FriendChatMessage.message)
  return _s;
}
inline const std::string& FriendChatMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void FriendChatMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendChatMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendChatMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.FriendChatMessage.message)
  return _impl_.message_.Release();
}
inline void FriendChatMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.FriendChatMessage.message)
}

// string time = 4;
inline void FriendChatMessage::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& FriendChatMessage::time() const {
  // @@protoc_insertion_point(field_get:chat.FriendChatMessage.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendChatMessage::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.FriendChatMessage.time)
}
inline std::string* FriendChatMessage::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:chat.FriendChatMessage.time)
  return _s;
}
inline const std::string& FriendChatMessage::_internal_time() const {
  return _impl_.time_.Get();
}
inline void FriendChatMessage::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendChatMessage::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendChatMessage::release_time() {
  // @@protoc_insertion_point(field_release:chat.FriendChatMessage.time)
  return _impl_.time_.Release();
}
inline void FriendChatMessage::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.FriendChatMessage.time)
}

// bool block = 5;
inline void FriendChatMessage::clear_block() {
  _impl_.block_ = false;
}
inline bool FriendChatMessage::_internal_block() const {
  return _impl_.block_;
}
inline bool FriendChatMessage::block() const {
  // @@protoc_insertion_point(field_get:chat.FriendChatMessage.block)
  return _internal_block();
}
inline void FriendChatMessage::_internal_set_block(bool value) {
  
  _impl_.block_ = value;
}
inline void FriendChatMessage::set_block(bool value) {
  _internal_set_block(value);
  // @@protoc_insertion_point(field_set:chat.FriendChatMessage.block)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::chat::Actions> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::Actions>() {
  return ::chat::Actions_descriptor();
}
template <> struct is_proto_enum< ::chat::Group> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::Group>() {
  return ::chat::Group_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_5fchat_2eproto
